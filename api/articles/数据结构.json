{"title":"数据结构","slug":"数据结构","date":"2021-09-16T12:23:37.000Z","updated":"2021-11-10T11:54:51.355Z","comments":true,"path":"api/articles/数据结构.json","excerpt":"在学习了一门高级程序语言（比如C++）后，我发现编程离不开对数据的操作，也就离不开形形色色的数据结构。比如C++中的数组，链表，队列，栈等结构，都有着十分广泛的应用。而数据结构这门课的目的就是深入学习这些东西。","covers":null,"content":"<p>在学习了一门高级程序语言（比如C++）后，我发现编程离不开对数据的操作，也就离不开形形色色的数据结构。比如C++中的数组，链表，队列，栈等结构，都有着十分广泛的应用。而数据结构这门课的目的就是深入学习这些东西。</p>\n<span id=\"more\"></span>\n\n\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h2><h3 id=\"C-程序设计\"><a href=\"#C-程序设计\" class=\"headerlink\" title=\"C++程序设计\"></a>C++程序设计</h3><p>C++的基本特性：</p>\n<ul>\n<li>参数传递方式，函数返回方式</li>\n<li>模板函数、递归函数、常量函数</li>\n<li>内存分配和释放函数</li>\n<li>异常处理结构</li>\n<li>类与模板</li>\n<li>类的成员（共享、保护、私有）</li>\n<li>友元、操作符重载</li>\n</ul>\n<h2 id=\"程序性能分析\"><a href=\"#程序性能分析\" class=\"headerlink\" title=\"程序性能分析\"></a>程序性能分析</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><h4 id=\"排序的基本概念\"><a href=\"#排序的基本概念\" class=\"headerlink\" title=\"排序的基本概念\"></a>排序的基本概念</h4><p>排序的目的：便于查找</p>\n<p>查找：顺序查找，二分查找</p>\n<p>排序的好坏：</p>\n<ul>\n<li><strong>时间效率</strong> —— 排序速度（全部比较次数）</li>\n<li><strong>空间效率</strong> —— 占内存辅助空间的大小</li>\n<li><strong>稳定性</strong> —— 若两个记录关键字值相等，排序后先后次序保持不变，则排序算法稳定。</li>\n</ul>\n<p>排序分为：</p>\n<ul>\n<li><strong>内部排序</strong>：排序过程中不使用计算机外部存储器的排序过程。<br>选择排序<br>插入排序<br>冒泡排序<br>计数排序<br>快速排序<br>归并排序<br>希尔排序<br>堆排序<br>基数排序</li>\n<li><strong>外部排序</strong>：在排序时需要堆外存进行访问的排序过程。</li>\n</ul>\n<p><strong>程序运行的效率</strong>是指程序正确执行的前提下，所用的时间最少、空间最少。</p>\n<p>程序性能是指运行一个程序所需要的的内存大小和时间。</p>\n<h3 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h3><p>空间复杂性：运行一个程序所需要的内存大小。</p>\n<p>空间复杂性的组成：</p>\n<ul>\n<li>指令空间：存储经过编译之后的程序指令。</li>\n<li>数据空间：存储所有常量和所有变量值。</li>\n<li>环境栈空间：保存函数调用时为恢复程序继续运行的有关信息所需的存储空间。</li>\n</ul>\n<p>数据空间：</p>\n<ul>\n<li>对于简单变量和常量，所需要的空间取决于计算机编译器和变量与常量的数目。</li>\n<li>对于复合变量，需要进行计算。</li>\n</ul>\n<p>环境栈空间：</p>\n<ul>\n<li>当函数被调用时，参数的定义，返回地址，局部变量的值以及传值形式参数的值保留在了环境栈中。</li>\n</ul>\n<p>任意程序 $P$ 所需空间 $S(P)$ 可以表示如下：<br>$$S(P)=c+S_p$$</p>\n<p>固定部分，一般包含指令空间，简单变量和定长复合变量的空间以及常量空间。</p>\n<p>可变部分：即与实例特征相关的部分。复合变量所需空间，动态分配的空间以及递归栈所需的空间。</p>\n<p>比较只需比较可变部分所需的空间。</p>\n<p>递归栈空间包括递归深度局部变量和形参的空间。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//顺序搜索</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;class T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">SequentialSearch</span><span class=\"hljs-params\">(T a[],<span class=\"hljs-keyword\">const</span> T&amp;x,<span class=\"hljs-keyword\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> i;<br>    <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;n&amp;&amp;a[i]!=x;i++);<br>    <span class=\"hljs-keyword\">if</span>(i==n)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-keyword\">return</span> i;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<p>选实例特征 $n$ ： $S(n)=0$ 。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;class T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">Sum</span><span class=\"hljs-params\">(T a[],<span class=\"hljs-keyword\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)<br>    tsum+=a[i];<br>  <span class=\"hljs-keyword\">return</span> tsum;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>$$S(n)=0$$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;class T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">Rsum</span><span class=\"hljs-params\">(T a[],<span class=\"hljs-keyword\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span>(n&gt;<span class=\"hljs-number\">0</span>)<span class=\"hljs-function\">s</span><br><span class=\"hljs-function\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">Rsum</span><span class=\"hljs-params\">(a,n<span class=\"hljs-number\">-1</span>)</span>+a[n-1]</span>;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>$$S(n)=(Addr+sizeof(int)+sizeof(ptr))*(n+1)$$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Factorial</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span>(n&lt;=<span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> n*<span class=\"hljs-built_in\">Factorial</span>(n<span class=\"hljs-number\">-1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>$$S(n)=(Addr+sizeof(int))*Max\\{ n,1 \\}$$</p>\n<p>小结：</p>\n<ul>\n<li>非递归算法：关注复合变量和动态空间分配</li>\n<li>递归算法：复合变量，动态空间分配，环境栈地址，参数变量，递归深度。</li>\n</ul>\n<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><p>时间复杂性：运行完该程序所需要的时间。</p>\n<p>时间复杂度的组成：编译时间和运行时间</p>\n<p>识别程序运行的关键操作。</p>\n<p>$$<br>t_p(n)<br>=c_aADD(n)+c_sSUB(n)+c_mMUL(n)+\\cdots<br>$$</p>\n<p>计数排序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">T</span>&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Rearrangs</span><span class=\"hljs-params\">(T a[],<span class=\"hljs-keyword\">int</span> n,<span class=\"hljs-keyword\">int</span> r[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  T*u = <span class=\"hljs-keyword\">new</span> T[n+<span class=\"hljs-number\">1</span>];<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)<br>    u[r[i]]=a[i];<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)<br>    a[i]=u[i];<br>  <span class=\"hljs-keyword\">delete</span> [] u;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>时间复杂度为： $\\dfrac{n(n-1)}{2}+2n$ 。</p>\n<p>选择排序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">T</span>&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SelectionSort</span><span class=\"hljs-params\">(T a[],<span class=\"hljs-keyword\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> size=<span class=\"hljs-number\">0</span>;size&lt;n<span class=\"hljs-number\">-1</span>;size++)<br>  &#123;<br>    <span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-built_in\">Min</span>(a,size,n);<br>    <span class=\"hljs-built_in\">Swap</span>(a[j],a[size]);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<p>时间复杂度为： $\\dfrac{(n-1)n}{2}+3(n-1)$ 。</p>\n<p>冒泡排序：</p>\n<p>元素的比较次数为 $\\dfrac{(n-1)n}{2}$ ，与选择排序相同。</p>\n<p>排序的时间复杂度不仅与 $n$ 有关，还与数组的初始排列有关，故有最好的、最坏的的操作数。</p>\n<p>插入排序：</p>\n<p>不是一个稳定的算法。</p>\n<p>最好的比较次数为 $n-1$ ，最坏的为 $\\dfrac{(n-1)n}{2}$ 。</p>\n<p>执行步数：</p>\n<ul>\n<li>操作计数忽略了其他操作的开销。</li>\n<li>执行步数统计程序的全部时间开销。</li>\n<li>执行步数也是实例特征的函数。</li>\n</ul>\n<p>执行步数的局限性：</p>\n<ul>\n<li>机器速度的影响</li>\n<li>受指令集的影响</li>\n<li>指令周期</li>\n<li>编译器</li>\n</ul>\n<h3 id=\"渐进符号\"><a href=\"#渐进符号\" class=\"headerlink\" title=\"渐进符号\"></a>渐进符号</h3><p>对于足够大的 $n$ ，我们给出 $f(n)$ 的上限和下限。</p>\n<p>$O,\\varOmega,\\varTheta,o$</p>\n<h4 id=\"大写-O-符号（渐进紧密上限）\"><a href=\"#大写-O-符号（渐进紧密上限）\" class=\"headerlink\" title=\"大写 $O$ 符号（渐进紧密上限）\"></a>大写 $O$ 符号（渐进紧密上限）</h4><p>定义： $f(n)=O(g(n))$ 当且仅当存在正的常数 $c$ 和 $n_0$ ，使得对于所有的 $n\\geq n_0$ ，有 $f(n)\\leq cg(n)$ 。</p>\n<h4 id=\"varOmega-符号（渐进紧密下限）\"><a href=\"#varOmega-符号（渐进紧密下限）\" class=\"headerlink\" title=\"$\\varOmega$ 符号（渐进紧密下限）\"></a>$\\varOmega$ 符号（渐进紧密下限）</h4><p>定义： $f(n)=\\varOmega(g(n))$ 当且仅当存在正的常数 $c$ 和 $n_0$ ，使得对所有的 $n\\geq n_0$ ，有 $f(n)\\geq cg(n)$ 。</p>\n<h4 id=\"varTheta-符号（渐进紧密限度）\"><a href=\"#varTheta-符号（渐进紧密限度）\" class=\"headerlink\" title=\"$\\varTheta$ 符号（渐进紧密限度）\"></a>$\\varTheta$ 符号（渐进紧密限度）</h4><p>定义： $f(n)=\\varTheta(g(n))$ 当且仅当存在正的常数 $c_1$ ， $c_2$ 和某个 $n_0$ ，使得对所有的 $n\\geq n_0$ ，有所有的 $n\\geq n_0$ ，有 $c_2g(n)\\geq f(n)\\geq c_1g(n)$ 。</p>\n<h4 id=\"小写-o-符号（非紧密上限）\"><a href=\"#小写-o-符号（非紧密上限）\" class=\"headerlink\" title=\"小写 $o$ 符号（非紧密上限）\"></a>小写 $o$ 符号（非紧密上限）</h4><p>定义： $f(n)=o(g(n))$ 当且仅当 $f(n)=O(g(n))$ 且 $f(n)\\neq \\varOmega(g(n))$ 。</p>\n<h4 id=\"小写-omega-符号（非紧密下限）\"><a href=\"#小写-omega-符号（非紧密下限）\" class=\"headerlink\" title=\"小写 $\\omega$ 符号（非紧密下限）\"></a>小写 $\\omega$ 符号（非紧密下限）</h4><h4 id=\"关于渐进符号的其他定理\"><a href=\"#关于渐进符号的其他定理\" class=\"headerlink\" title=\"关于渐进符号的其他定理\"></a>关于渐进符号的其他定理</h4><p>对于任一实数 $x&gt;0$ 和任一个实数 $\\delta&gt;0$ 下面的结论都是正确的：</p>\n<ol>\n<li>存在某个 $n_0$ 使得对于任何 $n\\geq n_0$ ，有 $(\\log{n})^{x}&lt;(\\log{n})^{x+\\delta}$ 。</li>\n<li>存在某个 $n_0$ 使得对于任何 $n\\geq n_0$ ，有 $(\\log{n})^{x}&lt;n$ 。</li>\n<li>存在某个 $n_0$ 使得对于任何 $n\\geq n_0$ ，有 $n^{x}&lt;n^{x+\\delta}$ 。</li>\n<li>对于任意实数 $y$ ，存在某个 $n_0$ 使得对于任何 $n\\geq n_0$ ，有 $n^x(\\log{n}^y)&lt;n^{x+\\delta}$ 。</li>\n<li>存在某个 $n_0$ 使得对于任何 $n\\geq n_0$ ，有 $n^x&lt;2^n$ 。</li>\n</ol>\n<h4 id=\"常用渐进标记\"><a href=\"#常用渐进标记\" class=\"headerlink\" title=\"常用渐进标记\"></a>常用渐进标记</h4><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>E1:</td>\n<td>$C$</td>\n<td>$\\varTheta(1)$</td>\n</tr>\n<tr>\n<td>E2:</td>\n<td>$\\sum_{i=0}^kc_in^i$</td>\n<td>$\\varTheta(n^k)$</td>\n</tr>\n<tr>\n<td>E3:</td>\n<td>$\\sum_{i=1}^ni$</td>\n<td>$\\varTheta(n^2)$</td>\n</tr>\n<tr>\n<td>E4:</td>\n<td>$\\sum_{i=1}^ni^2$</td>\n<td>$\\varTheta(n^3)$</td>\n</tr>\n<tr>\n<td>E5:</td>\n<td>$\\sum_{i=1}^ni^k$</td>\n<td>$\\varTheta(n^{k+1})$</td>\n</tr>\n<tr>\n<td>E6:</td>\n<td>$\\sum_{i=0}^nr^i(r&gt;1)$</td>\n<td>$\\varTheta(r^n)$</td>\n</tr>\n<tr>\n<td>E7:</td>\n<td>$n!$</td>\n<td>$\\varTheta((\\dfrac{n}{e})^n)$</td>\n</tr>\n<tr>\n<td>E8:</td>\n<td>$\\sum_{i=1}^n{\\dfrac{1}{i}}$</td>\n<td>$\\varTheta(\\log {n})$</td>\n</tr>\n</tbody></table>\n<h4 id=\"实用的规则\"><a href=\"#实用的规则\" class=\"headerlink\" title=\"实用的规则\"></a>实用的规则</h4><h2 id=\"数据描述\"><a href=\"#数据描述\" class=\"headerlink\" title=\"数据描述\"></a>数据描述</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>公式化描述：以数学公式来确定元素表中每个元素的存储位置。把所有元素依次连接存储在一片连续的存储空间中，即顺序表。</p>\n<p>链接描述：每个元素存储在存储器的不同区域，包含一个指向下一个元素的指针，以指针把所有元素链接起来，简称链表。</p>\n<p>间接寻址方式也可以描述存储在存储器的不同区域中的元素，保存一张存储元素地址的表，该表的第i项指向元素表中的第i个元素。</p>\n<h3 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h3><p>线性表的实例形式为： $(e_1,e_2,\\cdots,e_n)$ 。</p>\n<p>其中 $n$ 是有穷自然数，表的长度，当 $n=0$ 时，表为空。</p>\n<p> $e_i$ 是表中的元素。用  表示每个元素的大小。</p>\n<h3 id=\"公式化描述\"><a href=\"#公式化描述\" class=\"headerlink\" title=\"公式化描述\"></a>公式化描述</h3><p>采用数组表示，数组中每个位置被称为单元或节点，单元应足够大以便容纳数据元素。</p>\n<p>一个数组描述：一个线性表或多个线性表</p>\n<p>每个元素在数组中的位置：数学公式映射</p>\n<p>评价：</p>\n<ol>\n<li>在执行插入，删除等操作时复杂度与表的大小呈线性关系。</li>\n<li>空间利用率很低且受初始大小限制。</li>\n<li>例如：维护三个表，元素总数不会超过5000个，但需要总共有15000个元素的空间。</li>\n</ol>\n<p>解决浪费空间的方法（1）：</p>\n<ol>\n<li>将所有线性表放入一个数组中。</li>\n<li>引入附加数组对数组进行索引。</li>\n<li>特点：省空间，费时间，插入规则复杂。</li>\n</ol>\n<p>解决浪费空间的方法（2）：</p>\n<ol>\n<li>动态分配内存：空间不够时重新分配内存，冗余时减少。</li>\n<li>需要考虑增加和减少的量与时机。</li>\n</ol>\n<h3 id=\"链表描述\"><a href=\"#链表描述\" class=\"headerlink\" title=\"链表描述\"></a>链表描述</h3><p>在链表描述中，每个元素放在单元或节点中进行描述。</p>\n<p>每个节点中包含与该节点相关节点的位置信息。称为链或指针。</p>\n<ul>\n<li>每个节点中包含一个链接域，指向表中下一个元素。</li>\n<li>最后一个节点指向NULL。</li>\n<li>第一个指针指向第一个节点。</li>\n</ul>\n<p>链表的操作：</p>\n<ul>\n<li>插入</li>\n<li>删除</li>\n<li>遍历</li>\n<li>搜索</li>\n<li>排序</li>\n</ul>\n<p>循环链表：提高链表效率的方法</p>\n<ul>\n<li>单向循环链表或循环链表：把单链表的最后节点的指针指向第一个节点。</li>\n<li>带头节点循环链表：在链表的前部增加一个附加的节点，称之为头节点。</li>\n</ul>\n<p>与公式化描述方法的比较：</p>\n<ol>\n<li>空间<ul>\n<li>公式化描述：元素的空间及保存表长的空间</li>\n<li>链表：额外空间保存链接指针。</li>\n</ul>\n</li>\n<li>插入和删除操作<ul>\n<li>链表比公式描述方法快很多，当每个元素比较大时，更为明显。</li>\n</ul>\n</li>\n<li>访问第 $k$ 个元素的时间<ul>\n<li>公式化描述为 $\\varTheta(1)$ ，链表为 $\\varTheta(k)$ 。</li>\n</ul>\n</li>\n<li>使用链表可以描述多个表，并且不会降低空间利用率。公式化描述较为复杂。</li>\n</ol>\n<p>双向链表：</p>\n<ul>\n<li>每个节点有两个指针，一个指向左边的节点，一个指向右边的节点。</li>\n<li>也可以添加头节点及变成循环链表，来提高其性能。</li>\n</ul>\n<p>快慢指针的应用：</p>\n<ul>\n<li>求链表的中间节点</li>\n<li>求链表的倒数第 $k$ 个节点。</li>\n</ul>\n<h3 id=\"间接寻址\"><a href=\"#间接寻址\" class=\"headerlink\" title=\"间接寻址\"></a>间接寻址</h3><p>间接寻址是公式化描述和链表描述的组合。</p>\n<ul>\n<li>元素地址则被收集在一张表中。</li>\n<li>保留公式化描述的优点：根据索引在 $\\varTheta(1)$ 的时间内访问每个元素</li>\n<li>保留链表描述方法的重要特色，在类似插入，删除等操作是不必对元素进行实际的移动。</li>\n</ul>\n<p>概念：</p>\n<ul>\n<li>地址表与元素表</li>\n<li>存储元素地址的表：第 $i$ 项指向元素表中的第 $i$ 个元素。</li>\n</ul>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"箱子排序\"><a href=\"#箱子排序\" class=\"headerlink\" title=\"箱子排序\"></a>箱子排序</h4><p>箱子的实现：每个箱子都描述成一个链表</p>\n<p>对于箱子排序，需要能够：<br>1）从欲排序链表的首部开始，逐个删除每个节点，放入适当的箱子中。<br>2）收集并链接每个箱子中的节点，产生一个排序链表。</p>\n<h4 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h4><ul>\n<li><p>对于箱子排序，如果用 $range = n^c$ ，复杂性将变成 $\\varTheta(n+range)=\\varTheta(n^c)$ 。</p>\n</li>\n<li><p>采用一些基数 $r$ 分解这些数</p>\n</li>\n</ul>\n<p>基数排序：把数按照某种基数分解为数字，然后对数字进行排序。</p>\n<p>基数排序时对箱子排序方法的扩充，可使其在 $\\varTheta(n)$ 时间内对范围在 $0\\sim n^c-1$ 之间的 $n$ 个整数进行排序，其中 $c$ 是一个常量。</p>\n<ul>\n<li>当使用基数 $r=n$ ，对 $n$ 个介于 $0\\sim n^c-1$ 范围内的整数进行排序时，每个数可分解出 $c$ 个数字。可采用 $c$ 次箱子排序。每次排序时取 $range = n$ 。整个排序所需要的时间为 $\\varTheta(cn)=\\varTheta(n)$ 。（ $c$ 是一个常量）。</li>\n<li>基数排序的局限性，关键字的特殊性。</li>\n</ul>\n<h2 id=\"数组和矩阵\"><a href=\"#数组和矩阵\" class=\"headerlink\" title=\"数组和矩阵\"></a>数组和矩阵</h2><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组：数组是数据结构中最基本的类型，是一种循序的结构，是存储同一类数据的数据结构。</p>\n<p>二维数组：以行为主与以列为主，判断内存位置</p>\n<h3 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h3><p>矩阵：一个 $m\\times n$ 的矩阵是一个 $m$ 行， $n$ 列的表，其中 $m$ 和 $n$ 是矩阵的维数。</p>\n<p>矩阵转置，矩阵加，矩阵乘</p>\n<h3 id=\"特殊矩阵\"><a href=\"#特殊矩阵\" class=\"headerlink\" title=\"特殊矩阵\"></a>特殊矩阵</h3><ul>\n<li>对角矩阵</li>\n<li>三对角矩阵</li>\n<li>下三角矩阵</li>\n<li>上三角矩阵</li>\n<li>对称矩阵</li>\n</ul>\n<h3 id=\"稀疏矩阵\"><a href=\"#稀疏矩阵\" class=\"headerlink\" title=\"稀疏矩阵\"></a>稀疏矩阵</h3><p>稀疏矩阵：如果一个 $m\\times n$ 的矩阵有许多元素为0，则称该矩阵为稀疏矩阵，反之为稠密矩阵。</p>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><h3 id=\"抽象数据类型\"><a href=\"#抽象数据类型\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h3><p>栈：栈是一个线性表，其插入和删除操作都在表的同一端进行，其中一端被称为栈顶，另一端被称为栈底。</p>\n<p>栈是一个后进先出表。</p>\n<h3 id=\"公式化描述-1\"><a href=\"#公式化描述-1\" class=\"headerlink\" title=\"公式化描述\"></a>公式化描述</h3><p>令栈顶元素存储在 element[length-1] 中，栈底元素存储在 element[0] 中。</p>\n<h3 id=\"链表描述-1\"><a href=\"#链表描述-1\" class=\"headerlink\" title=\"链表描述\"></a>链表描述</h3><p>一个数组中可以描述多个堆栈。</p>\n<ul>\n<li>使 Add 操作在最坏情况下的时间复杂性从 $\\varTheta(1)\\rightarrow O(ArraySize)$ 。</li>\n<li>Delete 操作复杂度仍为 $\\varTheta(1)$ 。</li>\n</ul>\n<p>特殊：同时使用两个栈的共享。</p>\n<h3 id=\"应用-1\"><a href=\"#应用-1\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"括号匹配\"><a href=\"#括号匹配\" class=\"headerlink\" title=\"括号匹配\"></a>括号匹配</h4><p>从左到右扫描一个字符串，把所遇到的左括号入栈，每个右括号与最近的未匹配的左括号相匹配（栈顶的左括号），同时从栈顶删除该左括号。当括号不匹配或者扫描后栈不为空时，字符串括号就不是匹配的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tstack&lt;<span class=\"hljs-keyword\">char</span>&gt; op;<br>\t<span class=\"hljs-keyword\">char</span> s;<br>\t<span class=\"hljs-keyword\">while</span> ((s = <span class=\"hljs-built_in\">getchar</span>()) != <span class=\"hljs-string\">&#x27;\\n&#x27;</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (s == <span class=\"hljs-string\">&#x27;(&#x27;</span> || s == <span class=\"hljs-string\">&#x27;[&#x27;</span> || s == <span class=\"hljs-string\">&#x27;&#123;&#x27;</span>) &#123;<br>\t\t\top.<span class=\"hljs-built_in\">push</span>(s);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(s == <span class=\"hljs-string\">&#x27;)&#x27;</span>)&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">empty</span>())&#123;<br>\t\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">top</span>() == <span class=\"hljs-string\">&#x27;(&#x27;</span>) &#123;<br>\t\t\t\t\top.<span class=\"hljs-built_in\">pop</span>();<br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br><br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (s == <span class=\"hljs-string\">&#x27;]&#x27;</span>) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>\t\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">top</span>() == <span class=\"hljs-string\">&#x27;[&#x27;</span>) &#123;<br>\t\t\t\t\top.<span class=\"hljs-built_in\">pop</span>();<br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (s == <span class=\"hljs-string\">&#x27;&#125;&#x27;</span>) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>\t\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">top</span>() == <span class=\"hljs-string\">&#x27;&#123;&#x27;</span>) &#123;<br>\t\t\t\t\top.<span class=\"hljs-built_in\">pop</span>();<br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;True&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<h4 id=\"汉诺塔\"><a href=\"#汉诺塔\" class=\"headerlink\" title=\"汉诺塔\"></a>汉诺塔</h4><p>用栈组织三座塔。</p>\n<h4 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a>数值转换</h4><h4 id=\"计算器\"><a href=\"#计算器\" class=\"headerlink\" title=\"计算器\"></a>计算器</h4><h4 id=\"火车车厢重排\"><a href=\"#火车车厢重排\" class=\"headerlink\" title=\"火车车厢重排\"></a>火车车厢重排</h4><p>缓冲铁轨</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><h3 id=\"抽象数据类型-1\"><a href=\"#抽象数据类型-1\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h3><p>队列：队列是一个线性表，其插入和删除操作分别在表的不同端进行。添加新元素的一端被称为队尾（rear），而删除元素的一端被称为队首（front）。</p>\n<h3 id=\"公式化描述-2\"><a href=\"#公式化描述-2\" class=\"headerlink\" title=\"公式化描述\"></a>公式化描述</h3><p>公式化描述：用公式location(i)=i-1来描述一个队列。</p>\n<p>location(i)=location(1)+i-1</p>\n<p>location(i)=(location(1)+i-1)%MaxSize</p>\n<h3 id=\"链表描述-2\"><a href=\"#链表描述-2\" class=\"headerlink\" title=\"链表描述\"></a>链表描述</h3><p>通过两个变量front和rear来分别跟踪队列的两端</p>\n<h3 id=\"应用-2\"><a href=\"#应用-2\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"火车车厢重排-1\"><a href=\"#火车车厢重排-1\" class=\"headerlink\" title=\"火车车厢重排\"></a>火车车厢重排</h4><p>车厢进入缓冲铁轨的原则</p>\n<ul>\n<li>该缓冲铁轨中现有各车厢编号小于该车厢</li>\n<li>优先选择一个左端车厢编号最大的缓冲铁轨</li>\n<li>否则选择一个空的缓冲铁轨</li>\n</ul>\n<h2 id=\"跳表和散列\"><a href=\"#跳表和散列\" class=\"headerlink\" title=\"跳表和散列\"></a>跳表和散列</h2><h3 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h3><p>查找的概念：</p>\n<ul>\n<li>查找表是记录的集合，每个记录至少包含一个关键字。</li>\n<li>查找：关键字值-&gt;一个记录</li>\n<li>主关键字：唯一对应一个记录的关键字值。</li>\n<li>查找的结果：<ul>\n<li>成功查找</li>\n<li>不成功查找</li>\n</ul>\n</li>\n</ul>\n<p>常用的查找方法：</p>\n<ul>\n<li>顺序表查找（顺序查找，折半查找，索引顺序表查找）</li>\n<li>数表查找（二叉搜索树，AVL树，B-树）</li>\n<li>跳表和哈希表</li>\n</ul>\n<p>平均查找长度：$ASL=\\sum_{i=1}^np_ic_i$<br>$p_i$:查找第i个记录的概率<br>$c_i$：查找第i个记录的比较次数</p>\n<h3 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h3><p>字典是一些形如$(k,v)$的数对的计划，是检索功能和存储结构的统一。<br>随机访问或逐个访问</p>\n<h3 id=\"线性表描述\"><a href=\"#线性表描述\" class=\"headerlink\" title=\"线性表描述\"></a>线性表描述</h3><h3 id=\"跳表描述\"><a href=\"#跳表描述\" class=\"headerlink\" title=\"跳表描述\"></a>跳表描述</h3><p>给链表增加一些指针，当链表有序时，可以通过比较待查元素与指针的大小来缩小元素查找范围。</p>\n<h3 id=\"散列表（哈希表）描述\"><a href=\"#散列表（哈希表）描述\" class=\"headerlink\" title=\"散列表（哈希表）描述\"></a>散列表（哈希表）描述</h3><p>理想散列</p>\n<h3 id=\"文本压缩\"><a href=\"#文本压缩\" class=\"headerlink\" title=\"文本压缩\"></a>文本压缩</h3><h2 id=\"二叉树和其他树\"><a href=\"#二叉树和其他树\" class=\"headerlink\" title=\"二叉树和其他树\"></a>二叉树和其他树</h2><h3 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h3><p>树：一种层次化的数据，祖先-后代、上级-下属、整体-部分以及其他类似的关系。</p>\n<p>树：一个非空的有限元素的集合，其中一个元素为根，余下的元素（如果有的话）组成t的子树。</p>\n<p>树根是数中唯一一个没有父节点的元素。</p>\n<p>级：树根的级为1，其孩子级为2，以此类推。</p>\n<p>元素的度：孩子的个数，叶节点的度为零。</p>\n<p>树的度：所有元素度的最大值。</p>\n<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><h3 id=\"二叉树的特性\"><a href=\"#二叉树的特性\" class=\"headerlink\" title=\"二叉树的特性\"></a>二叉树的特性</h3><h3 id=\"二叉树的描述\"><a href=\"#二叉树的描述\" class=\"headerlink\" title=\"二叉树的描述\"></a>二叉树的描述</h3><h3 id=\"二叉树的常用操作\"><a href=\"#二叉树的常用操作\" class=\"headerlink\" title=\"二叉树的常用操作\"></a>二叉树的常用操作</h3><h3 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h3><h3 id=\"抽象数据类型-2\"><a href=\"#抽象数据类型-2\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h3><h3 id=\"二叉树类\"><a href=\"#二叉树类\" class=\"headerlink\" title=\"二叉树类\"></a>二叉树类</h3><h3 id=\"应用-3\"><a href=\"#应用-3\" class=\"headerlink\" title=\"应用\"></a>应用</h3>","more":"<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h2><h3 id=\"C-程序设计\"><a href=\"#C-程序设计\" class=\"headerlink\" title=\"C++程序设计\"></a>C++程序设计</h3><p>C++的基本特性：</p>\n<ul>\n<li>参数传递方式，函数返回方式</li>\n<li>模板函数、递归函数、常量函数</li>\n<li>内存分配和释放函数</li>\n<li>异常处理结构</li>\n<li>类与模板</li>\n<li>类的成员（共享、保护、私有）</li>\n<li>友元、操作符重载</li>\n</ul>\n<h2 id=\"程序性能分析\"><a href=\"#程序性能分析\" class=\"headerlink\" title=\"程序性能分析\"></a>程序性能分析</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><h4 id=\"排序的基本概念\"><a href=\"#排序的基本概念\" class=\"headerlink\" title=\"排序的基本概念\"></a>排序的基本概念</h4><p>排序的目的：便于查找</p>\n<p>查找：顺序查找，二分查找</p>\n<p>排序的好坏：</p>\n<ul>\n<li><strong>时间效率</strong> —— 排序速度（全部比较次数）</li>\n<li><strong>空间效率</strong> —— 占内存辅助空间的大小</li>\n<li><strong>稳定性</strong> —— 若两个记录关键字值相等，排序后先后次序保持不变，则排序算法稳定。</li>\n</ul>\n<p>排序分为：</p>\n<ul>\n<li><strong>内部排序</strong>：排序过程中不使用计算机外部存储器的排序过程。<br>选择排序<br>插入排序<br>冒泡排序<br>计数排序<br>快速排序<br>归并排序<br>希尔排序<br>堆排序<br>基数排序</li>\n<li><strong>外部排序</strong>：在排序时需要堆外存进行访问的排序过程。</li>\n</ul>\n<p><strong>程序运行的效率</strong>是指程序正确执行的前提下，所用的时间最少、空间最少。</p>\n<p>程序性能是指运行一个程序所需要的的内存大小和时间。</p>\n<h3 id=\"空间复杂度\"><a href=\"#空间复杂度\" class=\"headerlink\" title=\"空间复杂度\"></a>空间复杂度</h3><p>空间复杂性：运行一个程序所需要的内存大小。</p>\n<p>空间复杂性的组成：</p>\n<ul>\n<li>指令空间：存储经过编译之后的程序指令。</li>\n<li>数据空间：存储所有常量和所有变量值。</li>\n<li>环境栈空间：保存函数调用时为恢复程序继续运行的有关信息所需的存储空间。</li>\n</ul>\n<p>数据空间：</p>\n<ul>\n<li>对于简单变量和常量，所需要的空间取决于计算机编译器和变量与常量的数目。</li>\n<li>对于复合变量，需要进行计算。</li>\n</ul>\n<p>环境栈空间：</p>\n<ul>\n<li>当函数被调用时，参数的定义，返回地址，局部变量的值以及传值形式参数的值保留在了环境栈中。</li>\n</ul>\n<p>任意程序 $P$ 所需空间 $S(P)$ 可以表示如下：<br>$$S(P)=c+S_p$$</p>\n<p>固定部分，一般包含指令空间，简单变量和定长复合变量的空间以及常量空间。</p>\n<p>可变部分：即与实例特征相关的部分。复合变量所需空间，动态分配的空间以及递归栈所需的空间。</p>\n<p>比较只需比较可变部分所需的空间。</p>\n<p>递归栈空间包括递归深度局部变量和形参的空间。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//顺序搜索</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;class T&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">SequentialSearch</span><span class=\"hljs-params\">(T a[],<span class=\"hljs-keyword\">const</span> T&amp;x,<span class=\"hljs-keyword\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> i;<br>    <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;n&amp;&amp;a[i]!=x;i++);<br>    <span class=\"hljs-keyword\">if</span>(i==n)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-keyword\">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>选实例特征 $n$ ： $S(n)=0$ 。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;class T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">Sum</span><span class=\"hljs-params\">(T a[],<span class=\"hljs-keyword\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)<br>    tsum+=a[i];<br>  <span class=\"hljs-keyword\">return</span> tsum;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>$$S(n)=0$$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">template</span>&lt;class T&gt;</span><br><span class=\"hljs-function\">T <span class=\"hljs-title\">Rsum</span><span class=\"hljs-params\">(T a[],<span class=\"hljs-keyword\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span>(n&gt;<span class=\"hljs-number\">0</span>)<span class=\"hljs-function\">s</span><br><span class=\"hljs-function\">    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">Rsum</span><span class=\"hljs-params\">(a,n<span class=\"hljs-number\">-1</span>)</span>+a[n-1]</span>;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>$$S(n)=(Addr+sizeof(int)+sizeof(ptr))*(n+1)$$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">Factorial</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span>(n&lt;=<span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> n*<span class=\"hljs-built_in\">Factorial</span>(n<span class=\"hljs-number\">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>$$S(n)=(Addr+sizeof(int))*Max\\{ n,1 \\}$$</p>\n<p>小结：</p>\n<ul>\n<li>非递归算法：关注复合变量和动态空间分配</li>\n<li>递归算法：复合变量，动态空间分配，环境栈地址，参数变量，递归深度。</li>\n</ul>\n<h3 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h3><p>时间复杂性：运行完该程序所需要的时间。</p>\n<p>时间复杂度的组成：编译时间和运行时间</p>\n<p>识别程序运行的关键操作。</p>\n<p>$$<br>t_p(n)<br>=c_aADD(n)+c_sSUB(n)+c_mMUL(n)+\\cdots<br>$$</p>\n<p>计数排序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">T</span>&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Rearrangs</span><span class=\"hljs-params\">(T a[],<span class=\"hljs-keyword\">int</span> n,<span class=\"hljs-keyword\">int</span> r[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  T*u = <span class=\"hljs-keyword\">new</span> T[n+<span class=\"hljs-number\">1</span>];<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)<br>    u[r[i]]=a[i];<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)<br>    a[i]=u[i];<br>  <span class=\"hljs-keyword\">delete</span> [] u;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>时间复杂度为： $\\dfrac{n(n-1)}{2}+2n$ 。</p>\n<p>选择排序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">T</span>&gt;</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SelectionSort</span><span class=\"hljs-params\">(T a[],<span class=\"hljs-keyword\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> size=<span class=\"hljs-number\">0</span>;size&lt;n<span class=\"hljs-number\">-1</span>;size++)<br>  &#123;<br>    <span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-built_in\">Min</span>(a,size,n);<br>    <span class=\"hljs-built_in\">Swap</span>(a[j],a[size]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>时间复杂度为： $\\dfrac{(n-1)n}{2}+3(n-1)$ 。</p>\n<p>冒泡排序：</p>\n<p>元素的比较次数为 $\\dfrac{(n-1)n}{2}$ ，与选择排序相同。</p>\n<p>排序的时间复杂度不仅与 $n$ 有关，还与数组的初始排列有关，故有最好的、最坏的的操作数。</p>\n<p>插入排序：</p>\n<p>不是一个稳定的算法。</p>\n<p>最好的比较次数为 $n-1$ ，最坏的为 $\\dfrac{(n-1)n}{2}$ 。</p>\n<p>执行步数：</p>\n<ul>\n<li>操作计数忽略了其他操作的开销。</li>\n<li>执行步数统计程序的全部时间开销。</li>\n<li>执行步数也是实例特征的函数。</li>\n</ul>\n<p>执行步数的局限性：</p>\n<ul>\n<li>机器速度的影响</li>\n<li>受指令集的影响</li>\n<li>指令周期</li>\n<li>编译器</li>\n</ul>\n<h3 id=\"渐进符号\"><a href=\"#渐进符号\" class=\"headerlink\" title=\"渐进符号\"></a>渐进符号</h3><p>对于足够大的 $n$ ，我们给出 $f(n)$ 的上限和下限。</p>\n<p>$O,\\varOmega,\\varTheta,o$</p>\n<h4 id=\"大写-O-符号（渐进紧密上限）\"><a href=\"#大写-O-符号（渐进紧密上限）\" class=\"headerlink\" title=\"大写 $O$ 符号（渐进紧密上限）\"></a>大写 $O$ 符号（渐进紧密上限）</h4><p>定义： $f(n)=O(g(n))$ 当且仅当存在正的常数 $c$ 和 $n_0$ ，使得对于所有的 $n\\geq n_0$ ，有 $f(n)\\leq cg(n)$ 。</p>\n<h4 id=\"varOmega-符号（渐进紧密下限）\"><a href=\"#varOmega-符号（渐进紧密下限）\" class=\"headerlink\" title=\"$\\varOmega$ 符号（渐进紧密下限）\"></a>$\\varOmega$ 符号（渐进紧密下限）</h4><p>定义： $f(n)=\\varOmega(g(n))$ 当且仅当存在正的常数 $c$ 和 $n_0$ ，使得对所有的 $n\\geq n_0$ ，有 $f(n)\\geq cg(n)$ 。</p>\n<h4 id=\"varTheta-符号（渐进紧密限度）\"><a href=\"#varTheta-符号（渐进紧密限度）\" class=\"headerlink\" title=\"$\\varTheta$ 符号（渐进紧密限度）\"></a>$\\varTheta$ 符号（渐进紧密限度）</h4><p>定义： $f(n)=\\varTheta(g(n))$ 当且仅当存在正的常数 $c_1$ ， $c_2$ 和某个 $n_0$ ，使得对所有的 $n\\geq n_0$ ，有所有的 $n\\geq n_0$ ，有 $c_2g(n)\\geq f(n)\\geq c_1g(n)$ 。</p>\n<h4 id=\"小写-o-符号（非紧密上限）\"><a href=\"#小写-o-符号（非紧密上限）\" class=\"headerlink\" title=\"小写 $o$ 符号（非紧密上限）\"></a>小写 $o$ 符号（非紧密上限）</h4><p>定义： $f(n)=o(g(n))$ 当且仅当 $f(n)=O(g(n))$ 且 $f(n)\\neq \\varOmega(g(n))$ 。</p>\n<h4 id=\"小写-omega-符号（非紧密下限）\"><a href=\"#小写-omega-符号（非紧密下限）\" class=\"headerlink\" title=\"小写 $\\omega$ 符号（非紧密下限）\"></a>小写 $\\omega$ 符号（非紧密下限）</h4><h4 id=\"关于渐进符号的其他定理\"><a href=\"#关于渐进符号的其他定理\" class=\"headerlink\" title=\"关于渐进符号的其他定理\"></a>关于渐进符号的其他定理</h4><p>对于任一实数 $x&gt;0$ 和任一个实数 $\\delta&gt;0$ 下面的结论都是正确的：</p>\n<ol>\n<li>存在某个 $n_0$ 使得对于任何 $n\\geq n_0$ ，有 $(\\log{n})^{x}&lt;(\\log{n})^{x+\\delta}$ 。</li>\n<li>存在某个 $n_0$ 使得对于任何 $n\\geq n_0$ ，有 $(\\log{n})^{x}&lt;n$ 。</li>\n<li>存在某个 $n_0$ 使得对于任何 $n\\geq n_0$ ，有 $n^{x}&lt;n^{x+\\delta}$ 。</li>\n<li>对于任意实数 $y$ ，存在某个 $n_0$ 使得对于任何 $n\\geq n_0$ ，有 $n^x(\\log{n}^y)&lt;n^{x+\\delta}$ 。</li>\n<li>存在某个 $n_0$ 使得对于任何 $n\\geq n_0$ ，有 $n^x&lt;2^n$ 。</li>\n</ol>\n<h4 id=\"常用渐进标记\"><a href=\"#常用渐进标记\" class=\"headerlink\" title=\"常用渐进标记\"></a>常用渐进标记</h4><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>E1:</td>\n<td>$C$</td>\n<td>$\\varTheta(1)$</td>\n</tr>\n<tr>\n<td>E2:</td>\n<td>$\\sum_{i=0}^kc_in^i$</td>\n<td>$\\varTheta(n^k)$</td>\n</tr>\n<tr>\n<td>E3:</td>\n<td>$\\sum_{i=1}^ni$</td>\n<td>$\\varTheta(n^2)$</td>\n</tr>\n<tr>\n<td>E4:</td>\n<td>$\\sum_{i=1}^ni^2$</td>\n<td>$\\varTheta(n^3)$</td>\n</tr>\n<tr>\n<td>E5:</td>\n<td>$\\sum_{i=1}^ni^k$</td>\n<td>$\\varTheta(n^{k+1})$</td>\n</tr>\n<tr>\n<td>E6:</td>\n<td>$\\sum_{i=0}^nr^i(r&gt;1)$</td>\n<td>$\\varTheta(r^n)$</td>\n</tr>\n<tr>\n<td>E7:</td>\n<td>$n!$</td>\n<td>$\\varTheta((\\dfrac{n}{e})^n)$</td>\n</tr>\n<tr>\n<td>E8:</td>\n<td>$\\sum_{i=1}^n{\\dfrac{1}{i}}$</td>\n<td>$\\varTheta(\\log {n})$</td>\n</tr>\n</tbody></table>\n<h4 id=\"实用的规则\"><a href=\"#实用的规则\" class=\"headerlink\" title=\"实用的规则\"></a>实用的规则</h4><h2 id=\"数据描述\"><a href=\"#数据描述\" class=\"headerlink\" title=\"数据描述\"></a>数据描述</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>公式化描述：以数学公式来确定元素表中每个元素的存储位置。把所有元素依次连接存储在一片连续的存储空间中，即顺序表。</p>\n<p>链接描述：每个元素存储在存储器的不同区域，包含一个指向下一个元素的指针，以指针把所有元素链接起来，简称链表。</p>\n<p>间接寻址方式也可以描述存储在存储器的不同区域中的元素，保存一张存储元素地址的表，该表的第i项指向元素表中的第i个元素。</p>\n<h3 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h3><p>线性表的实例形式为： $(e_1,e_2,\\cdots,e_n)$ 。</p>\n<p>其中 $n$ 是有穷自然数，表的长度，当 $n=0$ 时，表为空。</p>\n<p> $e_i$ 是表中的元素。用  表示每个元素的大小。</p>\n<h3 id=\"公式化描述\"><a href=\"#公式化描述\" class=\"headerlink\" title=\"公式化描述\"></a>公式化描述</h3><p>采用数组表示，数组中每个位置被称为单元或节点，单元应足够大以便容纳数据元素。</p>\n<p>一个数组描述：一个线性表或多个线性表</p>\n<p>每个元素在数组中的位置：数学公式映射</p>\n<p>评价：</p>\n<ol>\n<li>在执行插入，删除等操作时复杂度与表的大小呈线性关系。</li>\n<li>空间利用率很低且受初始大小限制。</li>\n<li>例如：维护三个表，元素总数不会超过5000个，但需要总共有15000个元素的空间。</li>\n</ol>\n<p>解决浪费空间的方法（1）：</p>\n<ol>\n<li>将所有线性表放入一个数组中。</li>\n<li>引入附加数组对数组进行索引。</li>\n<li>特点：省空间，费时间，插入规则复杂。</li>\n</ol>\n<p>解决浪费空间的方法（2）：</p>\n<ol>\n<li>动态分配内存：空间不够时重新分配内存，冗余时减少。</li>\n<li>需要考虑增加和减少的量与时机。</li>\n</ol>\n<h3 id=\"链表描述\"><a href=\"#链表描述\" class=\"headerlink\" title=\"链表描述\"></a>链表描述</h3><p>在链表描述中，每个元素放在单元或节点中进行描述。</p>\n<p>每个节点中包含与该节点相关节点的位置信息。称为链或指针。</p>\n<ul>\n<li>每个节点中包含一个链接域，指向表中下一个元素。</li>\n<li>最后一个节点指向NULL。</li>\n<li>第一个指针指向第一个节点。</li>\n</ul>\n<p>链表的操作：</p>\n<ul>\n<li>插入</li>\n<li>删除</li>\n<li>遍历</li>\n<li>搜索</li>\n<li>排序</li>\n</ul>\n<p>循环链表：提高链表效率的方法</p>\n<ul>\n<li>单向循环链表或循环链表：把单链表的最后节点的指针指向第一个节点。</li>\n<li>带头节点循环链表：在链表的前部增加一个附加的节点，称之为头节点。</li>\n</ul>\n<p>与公式化描述方法的比较：</p>\n<ol>\n<li>空间<ul>\n<li>公式化描述：元素的空间及保存表长的空间</li>\n<li>链表：额外空间保存链接指针。</li>\n</ul>\n</li>\n<li>插入和删除操作<ul>\n<li>链表比公式描述方法快很多，当每个元素比较大时，更为明显。</li>\n</ul>\n</li>\n<li>访问第 $k$ 个元素的时间<ul>\n<li>公式化描述为 $\\varTheta(1)$ ，链表为 $\\varTheta(k)$ 。</li>\n</ul>\n</li>\n<li>使用链表可以描述多个表，并且不会降低空间利用率。公式化描述较为复杂。</li>\n</ol>\n<p>双向链表：</p>\n<ul>\n<li>每个节点有两个指针，一个指向左边的节点，一个指向右边的节点。</li>\n<li>也可以添加头节点及变成循环链表，来提高其性能。</li>\n</ul>\n<p>快慢指针的应用：</p>\n<ul>\n<li>求链表的中间节点</li>\n<li>求链表的倒数第 $k$ 个节点。</li>\n</ul>\n<h3 id=\"间接寻址\"><a href=\"#间接寻址\" class=\"headerlink\" title=\"间接寻址\"></a>间接寻址</h3><p>间接寻址是公式化描述和链表描述的组合。</p>\n<ul>\n<li>元素地址则被收集在一张表中。</li>\n<li>保留公式化描述的优点：根据索引在 $\\varTheta(1)$ 的时间内访问每个元素</li>\n<li>保留链表描述方法的重要特色，在类似插入，删除等操作是不必对元素进行实际的移动。</li>\n</ul>\n<p>概念：</p>\n<ul>\n<li>地址表与元素表</li>\n<li>存储元素地址的表：第 $i$ 项指向元素表中的第 $i$ 个元素。</li>\n</ul>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"箱子排序\"><a href=\"#箱子排序\" class=\"headerlink\" title=\"箱子排序\"></a>箱子排序</h4><p>箱子的实现：每个箱子都描述成一个链表</p>\n<p>对于箱子排序，需要能够：<br>1）从欲排序链表的首部开始，逐个删除每个节点，放入适当的箱子中。<br>2）收集并链接每个箱子中的节点，产生一个排序链表。</p>\n<h4 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h4><ul>\n<li><p>对于箱子排序，如果用 $range = n^c$ ，复杂性将变成 $\\varTheta(n+range)=\\varTheta(n^c)$ 。</p>\n</li>\n<li><p>采用一些基数 $r$ 分解这些数</p>\n</li>\n</ul>\n<p>基数排序：把数按照某种基数分解为数字，然后对数字进行排序。</p>\n<p>基数排序时对箱子排序方法的扩充，可使其在 $\\varTheta(n)$ 时间内对范围在 $0\\sim n^c-1$ 之间的 $n$ 个整数进行排序，其中 $c$ 是一个常量。</p>\n<ul>\n<li>当使用基数 $r=n$ ，对 $n$ 个介于 $0\\sim n^c-1$ 范围内的整数进行排序时，每个数可分解出 $c$ 个数字。可采用 $c$ 次箱子排序。每次排序时取 $range = n$ 。整个排序所需要的时间为 $\\varTheta(cn)=\\varTheta(n)$ 。（ $c$ 是一个常量）。</li>\n<li>基数排序的局限性，关键字的特殊性。</li>\n</ul>\n<h2 id=\"数组和矩阵\"><a href=\"#数组和矩阵\" class=\"headerlink\" title=\"数组和矩阵\"></a>数组和矩阵</h2><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组：数组是数据结构中最基本的类型，是一种循序的结构，是存储同一类数据的数据结构。</p>\n<p>二维数组：以行为主与以列为主，判断内存位置</p>\n<h3 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h3><p>矩阵：一个 $m\\times n$ 的矩阵是一个 $m$ 行， $n$ 列的表，其中 $m$ 和 $n$ 是矩阵的维数。</p>\n<p>矩阵转置，矩阵加，矩阵乘</p>\n<h3 id=\"特殊矩阵\"><a href=\"#特殊矩阵\" class=\"headerlink\" title=\"特殊矩阵\"></a>特殊矩阵</h3><ul>\n<li>对角矩阵</li>\n<li>三对角矩阵</li>\n<li>下三角矩阵</li>\n<li>上三角矩阵</li>\n<li>对称矩阵</li>\n</ul>\n<h3 id=\"稀疏矩阵\"><a href=\"#稀疏矩阵\" class=\"headerlink\" title=\"稀疏矩阵\"></a>稀疏矩阵</h3><p>稀疏矩阵：如果一个 $m\\times n$ 的矩阵有许多元素为0，则称该矩阵为稀疏矩阵，反之为稠密矩阵。</p>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><h3 id=\"抽象数据类型\"><a href=\"#抽象数据类型\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h3><p>栈：栈是一个线性表，其插入和删除操作都在表的同一端进行，其中一端被称为栈顶，另一端被称为栈底。</p>\n<p>栈是一个后进先出表。</p>\n<h3 id=\"公式化描述-1\"><a href=\"#公式化描述-1\" class=\"headerlink\" title=\"公式化描述\"></a>公式化描述</h3><p>令栈顶元素存储在 element[length-1] 中，栈底元素存储在 element[0] 中。</p>\n<h3 id=\"链表描述-1\"><a href=\"#链表描述-1\" class=\"headerlink\" title=\"链表描述\"></a>链表描述</h3><p>一个数组中可以描述多个堆栈。</p>\n<ul>\n<li>使 Add 操作在最坏情况下的时间复杂性从 $\\varTheta(1)\\rightarrow O(ArraySize)$ 。</li>\n<li>Delete 操作复杂度仍为 $\\varTheta(1)$ 。</li>\n</ul>\n<p>特殊：同时使用两个栈的共享。</p>\n<h3 id=\"应用-1\"><a href=\"#应用-1\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"括号匹配\"><a href=\"#括号匹配\" class=\"headerlink\" title=\"括号匹配\"></a>括号匹配</h4><p>从左到右扫描一个字符串，把所遇到的左括号入栈，每个右括号与最近的未匹配的左括号相匹配（栈顶的左括号），同时从栈顶删除该左括号。当括号不匹配或者扫描后栈不为空时，字符串括号就不是匹配的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tstack&lt;<span class=\"hljs-keyword\">char</span>&gt; op;<br>\t<span class=\"hljs-keyword\">char</span> s;<br>\t<span class=\"hljs-keyword\">while</span> ((s = <span class=\"hljs-built_in\">getchar</span>()) != <span class=\"hljs-string\">&#x27;\\n&#x27;</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (s == <span class=\"hljs-string\">&#x27;(&#x27;</span> || s == <span class=\"hljs-string\">&#x27;[&#x27;</span> || s == <span class=\"hljs-string\">&#x27;&#123;&#x27;</span>) &#123;<br>\t\t\top.<span class=\"hljs-built_in\">push</span>(s);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(s == <span class=\"hljs-string\">&#x27;)&#x27;</span>)&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">empty</span>())&#123;<br>\t\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">top</span>() == <span class=\"hljs-string\">&#x27;(&#x27;</span>) &#123;<br>\t\t\t\t\top.<span class=\"hljs-built_in\">pop</span>();<br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br><br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (s == <span class=\"hljs-string\">&#x27;]&#x27;</span>) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>\t\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">top</span>() == <span class=\"hljs-string\">&#x27;[&#x27;</span>) &#123;<br>\t\t\t\t\top.<span class=\"hljs-built_in\">pop</span>();<br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (s == <span class=\"hljs-string\">&#x27;&#125;&#x27;</span>) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>\t\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">top</span>() == <span class=\"hljs-string\">&#x27;&#123;&#x27;</span>) &#123;<br>\t\t\t\t\top.<span class=\"hljs-built_in\">pop</span>();<br>\t\t\t\t&#125;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (op.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;True&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;False&quot;</span> &lt;&lt; endl;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"汉诺塔\"><a href=\"#汉诺塔\" class=\"headerlink\" title=\"汉诺塔\"></a>汉诺塔</h4><p>用栈组织三座塔。</p>\n<h4 id=\"数值转换\"><a href=\"#数值转换\" class=\"headerlink\" title=\"数值转换\"></a>数值转换</h4><h4 id=\"计算器\"><a href=\"#计算器\" class=\"headerlink\" title=\"计算器\"></a>计算器</h4><h4 id=\"火车车厢重排\"><a href=\"#火车车厢重排\" class=\"headerlink\" title=\"火车车厢重排\"></a>火车车厢重排</h4><p>缓冲铁轨</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><h3 id=\"抽象数据类型-1\"><a href=\"#抽象数据类型-1\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h3><p>队列：队列是一个线性表，其插入和删除操作分别在表的不同端进行。添加新元素的一端被称为队尾（rear），而删除元素的一端被称为队首（front）。</p>\n<h3 id=\"公式化描述-2\"><a href=\"#公式化描述-2\" class=\"headerlink\" title=\"公式化描述\"></a>公式化描述</h3><p>公式化描述：用公式location(i)=i-1来描述一个队列。</p>\n<p>location(i)=location(1)+i-1</p>\n<p>location(i)=(location(1)+i-1)%MaxSize</p>\n<h3 id=\"链表描述-2\"><a href=\"#链表描述-2\" class=\"headerlink\" title=\"链表描述\"></a>链表描述</h3><p>通过两个变量front和rear来分别跟踪队列的两端</p>\n<h3 id=\"应用-2\"><a href=\"#应用-2\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"火车车厢重排-1\"><a href=\"#火车车厢重排-1\" class=\"headerlink\" title=\"火车车厢重排\"></a>火车车厢重排</h4><p>车厢进入缓冲铁轨的原则</p>\n<ul>\n<li>该缓冲铁轨中现有各车厢编号小于该车厢</li>\n<li>优先选择一个左端车厢编号最大的缓冲铁轨</li>\n<li>否则选择一个空的缓冲铁轨</li>\n</ul>\n<h2 id=\"跳表和散列\"><a href=\"#跳表和散列\" class=\"headerlink\" title=\"跳表和散列\"></a>跳表和散列</h2><h3 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h3><p>查找的概念：</p>\n<ul>\n<li>查找表是记录的集合，每个记录至少包含一个关键字。</li>\n<li>查找：关键字值-&gt;一个记录</li>\n<li>主关键字：唯一对应一个记录的关键字值。</li>\n<li>查找的结果：<ul>\n<li>成功查找</li>\n<li>不成功查找</li>\n</ul>\n</li>\n</ul>\n<p>常用的查找方法：</p>\n<ul>\n<li>顺序表查找（顺序查找，折半查找，索引顺序表查找）</li>\n<li>数表查找（二叉搜索树，AVL树，B-树）</li>\n<li>跳表和哈希表</li>\n</ul>\n<p>平均查找长度：$ASL=\\sum_{i=1}^np_ic_i$<br>$p_i$:查找第i个记录的概率<br>$c_i$：查找第i个记录的比较次数</p>\n<h3 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h3><p>字典是一些形如$(k,v)$的数对的计划，是检索功能和存储结构的统一。<br>随机访问或逐个访问</p>\n<h3 id=\"线性表描述\"><a href=\"#线性表描述\" class=\"headerlink\" title=\"线性表描述\"></a>线性表描述</h3><h3 id=\"跳表描述\"><a href=\"#跳表描述\" class=\"headerlink\" title=\"跳表描述\"></a>跳表描述</h3><p>给链表增加一些指针，当链表有序时，可以通过比较待查元素与指针的大小来缩小元素查找范围。</p>\n<h3 id=\"散列表（哈希表）描述\"><a href=\"#散列表（哈希表）描述\" class=\"headerlink\" title=\"散列表（哈希表）描述\"></a>散列表（哈希表）描述</h3><p>理想散列</p>\n<h3 id=\"文本压缩\"><a href=\"#文本压缩\" class=\"headerlink\" title=\"文本压缩\"></a>文本压缩</h3><h2 id=\"二叉树和其他树\"><a href=\"#二叉树和其他树\" class=\"headerlink\" title=\"二叉树和其他树\"></a>二叉树和其他树</h2><h3 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h3><p>树：一种层次化的数据，祖先-后代、上级-下属、整体-部分以及其他类似的关系。</p>\n<p>树：一个非空的有限元素的集合，其中一个元素为根，余下的元素（如果有的话）组成t的子树。</p>\n<p>树根是数中唯一一个没有父节点的元素。</p>\n<p>级：树根的级为1，其孩子级为2，以此类推。</p>\n<p>元素的度：孩子的个数，叶节点的度为零。</p>\n<p>树的度：所有元素度的最大值。</p>\n<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><h3 id=\"二叉树的特性\"><a href=\"#二叉树的特性\" class=\"headerlink\" title=\"二叉树的特性\"></a>二叉树的特性</h3><h3 id=\"二叉树的描述\"><a href=\"#二叉树的描述\" class=\"headerlink\" title=\"二叉树的描述\"></a>二叉树的描述</h3><h3 id=\"二叉树的常用操作\"><a href=\"#二叉树的常用操作\" class=\"headerlink\" title=\"二叉树的常用操作\"></a>二叉树的常用操作</h3><h3 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h3><h3 id=\"抽象数据类型-2\"><a href=\"#抽象数据类型-2\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h3><h3 id=\"二叉树类\"><a href=\"#二叉树类\" class=\"headerlink\" title=\"二叉树类\"></a>二叉树类</h3><h3 id=\"应用-3\"><a href=\"#应用-3\" class=\"headerlink\" title=\"应用\"></a>应用</h3>","categories":[{"name":"计算机","path":"api/categories/计算机.json"},{"name":"数据结构","path":"api/categories/数据结构.json"}],"tags":[{"name":"数据结构","path":"api/tags/数据结构.json"}]}