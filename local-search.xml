<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数值分析</title>
    <link href="/archives/830bd2a5.html"/>
    <url>/archives/830bd2a5.html</url>
    
    <content type="html"><![CDATA[<h1 id="数值分析"><a href="#数值分析" class="headerlink" title="数值分析"></a>数值分析</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="误差"><a href="#误差" class="headerlink" title="误差"></a>误差</h3><p>误差分类：模型误差，观测误差，截断误差，舍入误差。</p><ol><li>模型误差：数学模型的解与实际问题的解之间的误差。</li><li>观测误差：数学模型中包含的某些参数（如时间、长度、电压、温度等）往往通过观测而获得，由观测得到的数据与实际的数据之间的误差称为观测误差。</li><li>截断误差：当数学模型不能得到精确解时，通常要用数值方法求它的近似解，近似解与精确解之间的误差称为截断误差，或叫方法误差。</li><li>舍入误差：由于计算机的字长有限，参加运算的数据以及运算结果在计算机中保存时会产生误差，称为舍入误差或计算误差。</li></ol><p>误差：设 $x$ 为准确值， $x^{\ast }$ 为 $x$ 的一个近似值，称 $e^{\ast }=x^{\ast}-x$ 为近似值的绝对误差，简称误差。</p><p>相对误差：我们把近似值的误差 $e^{\ast }$ 与准确值 $x$ 的比值</p><p>$$<br>\dfrac{e^{\ast}}{x}=\dfrac{x^{\ast}-x}{x}<br>$$</p><p>称为近似值 $x^{\ast }$ 的相对误差，记作 $e_r^{\ast}$ 。当 $e^{\ast}/x^{\ast}$ 很小时，可以取 $e_r^{\ast }=\dfrac{x^{\ast}-x}{x^{\ast}}$ 。</p><p>相对误差可正可负，其绝对值上界叫做相对误差限，记作 $\varepsilon_r^{\ast}$ ，即 $\varepsilon_r^{\ast}=\dfrac{\varepsilon^{\ast}}{|x^{\ast}|}$ 。</p><h2 id="插值法"><a href="#插值法" class="headerlink" title="插值法"></a>插值法</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>定义：设函数 $y=f(x)$ 在区间 $[a,b]$ 上有定义，且已知在点 $a\leq x_0&lt;x_1&lt;\cdots&lt;x_n\leq b$ 上的值 $y_0,y_1,\cdots,y_n$ ，若存在一个简单函数 $p(x)$ ，使 $p(x_i)=y_i(i=0,\cdots,n)$ 成立，则称 $p(x)$ 为 $f(x)$ 的插值函数，点 $x_0,x_1,\cdots,x_n$ 称为插值节点，区间 $[a,b]$ 称为插值区间，求插值函数 $p(x)$ 的方法称为插值方法。</p><p>若 $p(x)$ 是次数不超过 $n$ 的代数多项式，即</p><p>$$<br>p(x)=a_0+a_1x+\cdots+a_nx^n<br>$$</p><p>其中 $a_i$ 为实数，则 $p(x)$ 称为插值多项式，相应的插值法称为多项式插值（代数插值）。<br>若 $p(x)$ 是分段的多项式，则为分段插值。<br>若 $p(x)$ 是三角多项式，则称为三角插值。</p><h3 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a>拉格朗日插值</h3><p>定理：设给定 $n+1$ 个互异的点 $x_{0},x_{1}, \cdots ,x_{n}$ 和 $n+1$ 个函数值 $ y_{0},y_{1}, \cdots ,y_{n} $ ,则在次数不高于 $n$ 的代数多项式集合中，唯一的存在一个多项式 $p(x)=a_0+a_1x+\cdots+a_nx^n$ ,它满足条件 $p(x_i)=y_i(i=0,\cdots,n)$。（可以使用范德蒙德行列式的性质证明）</p><p>当 $n=1$ 时，有 $L_1(x)=y_{k}l_{k}(x)+y_{k+1}l_{k+1}(x)$ ，其中 $l_k(x)=\dfrac{x-x_{k+1}}{x_{k}-x_{k+1}}$ ， $l_{k+1}(x)=\dfrac{x-x_k}{x_{k+1}-x_k}$ ， $l_k(x),l_{k+1}(x)$ 称为线性插值基函数。</p><p>当 $n=2$ 时，三个插值基函数为</p><p>$$<br>l_{k-1}(x)=\dfrac{(x-x_{k})(x-x_{k+1})}{(x_{k-1}-x_k)(x_{k-1}-x_{k+1})} \\ l_{k}(x)=\dfrac{(x-x_{k-1})(x-x_{k+1})}{(x_{k}-x_k-1)(x_{k}-x_{k+1})} \\ l_{k+1}(x)=\dfrac{(x-x_{k-1})(x-x_{k})}{(x_{k+1}-x_{k-1})(x_{k+1}-x_{k})}<br>$$</p><p>二次插值函数为：</p><p>$$<br>L_2(x)=y_{k-1}l_{k-1}(x)+y_{k}l_{k}(x)+y_{k+1}l_{k+1}(x)<br>$$</p><p>插值基函数：若 $n$ 次多项式 $l_j(x)(j=0,\cdots ,n)$ 在 $n+1$ 个节点 $x_0&lt;\cdots &lt;x_n$ 上满足条件：</p><p>$$<br>l_j(x_k)=\begin{cases} 1 \quad k=j(j,k=0,1,\cdots ,n)\\<br>0\quad k\neq j<br>\end{cases}<br>$$</p><p>则称这 $n+1$ 个 $n$ 次多项式 $l_0(x),\cdots ,l_n(x)$ 为节点 $x_0,\cdots ,x_n$ 上的 $n$ 次插值基函数。</p><p>可以得到</p><p>$$<br>l_k(x)=\dfrac{(x-x_0)\cdots (x-x_{k-1})(x-x_{k+1})\cdots (x-x_n)}{(x_k-x_0)\cdots (x_k-x_{k-1})(x_k-x_{k+1})\cdots (x_k-x_n)}<br>$$</p><p>则有</p><p>$$<br>L_n(x)=\sum_{k=0}^ny_kl_k(x)<br>$$</p><p>得到的 $L_n(x)$ 即为插值函数， $L_n(x)$ 为拉格朗日插值多项式。</p><p>引入记号 $\omega_{n+1}=(x-x_0)\cdots (x-x_{n})$ ，求其导数</p><p>$$<br>\omega_{n+1}^{\prime}(x)=(x-x_1)\cdots(x-x_n)+(x-x_0)(x-x_2)\cdots (x-x_n)+\cdots +(x-x_0)\cdots (x-x_{n-1})<br>$$</p><p>代入 $x_k$ ，得到</p><p>$$<br>\omega_{n+1}^{\prime}(x_k)=(x_k-x_0)\cdots (x_k-x_{k-1})(x_k-x_{k+1})\cdots (x_k-x_n)<br>$$</p><p>则有</p><p>$$<br>L_n(x)=\sum_{k=0}^ny_k\dfrac{\omega_{n+1}(x)}{(x-x_k)\omega_{n+1}^{\prime}(x_k)}<br>$$</p><p>插值余项：若在 $[a,b]$ 上用 $L_n(x)$ 近似 $f(x)$ ，则其截断误差为 $R_n(x)=f(x)-L_n(x)$ ，称为插值多项式的余项。</p><p>定理：设 $f^{(n)}(x)$ 在 $[a,b]$ 上连续， $f^{(n+1)}(x)$ 在 $(a,b)$ 内存在，节点 $a\leq x_0&lt;\cdots &lt;x_n\leq b$ 。 $L_n(x)$ 是满足条件 $L_n(x_j)=y_j(j=0,1,\cdots ,n)$ 的插值多项式，则对任何 $x\in [a,b]$ ，插值余项</p><p>$$<br>R_n(x)=f(x)-L_n(x)=\dfrac{f^{(n+1)}(\xi)}{(n+1)!}\omega_{n+1}(x)<br>$$</p><p>这里， $\xi \in (a,b)$ 且依赖于 $x$ 。</p><p>证明：根据题目， $x_0,x_1,\cdots ,x_n$ 是 $R_n(x)$ 的零点，则</p><p>$$<br>R_n(x)=K(x)(x-x_0)\cdots (x-x_n)=K(x)\omega_{n+1}(x)<br>$$</p><p>$K(x)$ 是与 $x$ 有关的待定函数。</p><p>现在构造一个函数：</p><p>$$<br>\Phi(t)=f(t)-L_n(t)-K(x)(t-x_0)(t-x_1)\cdots (t-x_n)<br>$$</p><p>将 $t$ 作为函数的自变量， $x$ 认为是常量，是 $[a,b]$ 上一个固定点。</p><p>由插值条件知，对插值节点 $x_{0},x_{1}, \cdots ,x_{n}$ ，有</p><p>$$<br>f(x_i)=L_n(x_i)(i=0,1,\cdots ,n)<br>$$</p><p>$\Phi(t)$ 后面的项 $K(x)(t-x_0)(t-x_1)\cdots (t-x_n)$ ，在上述节点的值也是零，可知，对于 $t = x_{0},x_{1}, \cdots ,x_{n}$ 有 $\Phi(t)=0$ 。</p><p>而对于点 $x$ ，有</p><p>$$<br>\Phi(x)=f(x)-L_n(x)-K(x)(x-x_0)(x-x_1)\cdots (x-x_n)<br>$$</p><p>由余项定义， $\Phi(x)=0$ 。<br>因此，对函数 $\Phi(t)$ ，它在 $[a,b]$ 上有 $n+2$ 个零点 $(x_0,\cdots,x_n,x)$ 。<br>根据罗尔定理， $\Phi^{\prime}(t)$ 在 $\Phi(t)$ 的两个零点之间至少有一个零点，故 $\Phi^{\prime}(t)$ 在区间 $[a,b]$ 上至少有 $n+1$ 个零点， $\Phi^{\prime\prime}(t)$ 在区间 $[a,b]$ 上至少有 $n$ 个零点，依此类推， $\Phi^{(n+1)}(t)$ 在区间 $[a,b]$ 上至少有 $1$ 个零点，设 $\xi \in(a,b)$ ，使 $\Phi^{(n+1)}(\xi)=0$ ，则有</p><p>$$<br>\Phi^{(n+1)}(t)=f^{(n+1)}(x)-K(x)(n+1)!<br>$$</p><p>$$<br>\Phi^{(n+1)}(\xi)=f^{(n+1)}(\xi)-K(x)(n+1)!=0<br>$$</p><p>$$<br>K(x)=f^{(n+1)}(\xi)/(n+1)! \quad \xi \in (a,b)\text{且依赖于}x<br>$$</p><p>则有</p><p>$$<br>R_{n}(x)=K(x)(x-x_0)(x-x_1)\cdots (x-x_n)=f^{(n+1)}(\xi)/(n+1)!\omega_{n+1}(x)<br>$$</p><p>若设 $\max_{a&lt;x&lt;b}\vert f^{(n+1)}(x)\vert = M_{n+1}$ ，则有插值多项式 $L_n(x)$ 逼近 $f(x)$ 的截断误差限是 $\vert R_n(x) \vert \leq \dfrac{M_{n+1}}{(n+1)!}\vert \omega_{n+1}(x)\vert$ 。</p><p>余项分析</p><h3 id="逐次线性插值法"><a href="#逐次线性插值法" class="headerlink" title="逐次线性插值法"></a>逐次线性插值法</h3><p>设插值节点为 $x_{i1},x_{i2},\cdots ,x_{in}$ ，对应这些节点的插值多项式为： $n-1$ 次 $I_{i1\cdots in}$ 。<br>记 $I_{ik}(x)=f(x_{ik})$ ，则 $I_{ik}(x)$ 是常数值，即零次多项式。构造：</p><p>$$<br>I_{01\cdots kl}(x)=I_{01\cdots k}(x)+\dfrac{I_{01\cdots k-1l}(x)-I_{01\cdots k}(x)}{x_l-x_k}(x-x_k)<br>$$</p><p>当 $i=0,\cdots,k-1$ 时，有：</p><p>$$<br>I_{01\cdots kl}(x_i)=I_{01\cdots k}(x_i)+\dfrac{I_{01\cdots k-1l}(x_i)-I_{01\cdots k}(x_i)}{x_l-x_k}(x_i-x_k)<br>$$</p><p>$I_{01\cdots k-1l}(x)$ 是关于节点 $x_0,\cdots,x_{k-1},x_l$ 的插值多项式，在这些节点上</p><p>$$<br>I_{01\cdots k-1l}(x_i)=f(x_i) i=0,1,\cdots ,k-1<br>$$</p><p>同理， $I_{01\cdots k}(x)$ 是关于节点 $x_0,\cdots,x_{k}$ 的插值多项式，同样有</p><p>$$<br>I_{01\cdots k}(x_i)=f(x_i) i=0,1,\cdots ,k-1<br>$$</p><p>所以有：</p><p>$$<br>I_{01\cdots kl}(x_i)=I_{01\cdots k}(x_i)=f(x_i) \quad i=0,1,\cdots,k-1<br>$$</p><p>则有</p><p>$$<br>I_{01\cdots kl}(x)=I_{01\cdots k}(x)+\dfrac{I_{01\cdots k-1l}(x)-I_{01\cdots k}(x)}{x_l-x_k}(x-x_k)<br>$$</p><p>这个式子称为埃特金逐次线性插值公式。</p><p>计算过程：</p><p><img src="830bd2a5/%E5%9F%83%E7%89%B9%E9%87%91%E6%8F%92%E5%80%BC%E8%A1%A8%E6%A0%BC.jpg" alt="埃特金插值表格"></p><p>埃特金插值公式可以改写， $l=k+1$ ，将节点顺序倒排，有 $k,\cdots,0,k+1$ ，则</p><p>$$<br>I_{01\cdots kk+1}(x)=I_{01\cdots k}(x)+\dfrac{I_{01\cdots k+1}(x)-I_{01\cdots k}(x)}{x_{k+1}-x_0}(x-x_0)<br>$$</p><p>该公式称为列维尔算法。</p><p>计算过程：</p><p><img src="830bd2a5/%E5%88%97%E7%BB%B4%E5%B0%94%E7%AE%97%E6%B3%95%E8%A1%A8%E6%A0%BC.jpg" alt="列维尔算法表格"></p><h3 id="均差和牛顿插值公式"><a href="#均差和牛顿插值公式" class="headerlink" title="均差和牛顿插值公式"></a>均差和牛顿插值公式</h3><p>均差：称 $f[x_0,x_k]=\dfrac{f(x_k)-f(x_0)}{x_k-x_0}$ 为函数 $f(x)$ 关于点 $x_0,x_k$ 的一阶均差， $f[x_0,x_1,x_k]=\dfrac{f[x_0,x_k]-f[x_0,x_1]}{x_k-x_1}$ 称为函数 $f(x)$ 的二阶均差。一般的，称</p><p>$$<br>f[x_0,\cdots ,x_k]=\dfrac{f[x_0,\cdots,x_{k-2} ,x_k]-f[x_0,\cdots ,x_{k-1}]}{x_k-x_{k-1}}<br>$$</p><p>为 $f(x)$ 的 $k$ 阶均差。</p><!--### 差分与等距节点插值### 埃尔米特插值### 分段低次插值### 三次样条插值## 函数逼近与曲线拟合### 函数逼近的基本概念### 正交多项式### 最佳一致逼近多项式### 最佳平方逼近### 曲线拟合的最小二乘法### 最佳平方三角逼近与快速傅里叶变换### 有理逼近## 数值积分与数值微分### 引言### 牛顿·柯特斯公式### 复化求积公式### 龙贝格求积公式### 高斯求积公式### 数值微分## 解线性方程组的直接方法### 引言和预备知识### 高斯消去法### 高斯主元素消去法### 矩阵三角分解法### 向量和矩阵的范数### 误差分析### 矩阵的正交三角化及应用## 解线性方程组的迭代法### 引言### 基本迭代法### 迭代法的收敛性### 分块迭代法## 非线性方程求根### 方程求根与二分法### 迭代法及其收敛性### 迭代收敛的加速方法### 牛顿法### 弦截法与抛物线法### 解非线性方程组的牛顿迭代法## 矩阵特征值问题计算### 引言### 幂法及反幂法### 豪斯霍尔德方法### $QR$ 方法## 常微分方程初值问题数值解法### 引言### 简单的数值方法和基本概念### 龙格·库塔方法### 单步法的收敛性与稳定性### 线性多步法### 方程组和高阶方程 -->]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>应用数学</category>
      
      <category>数值分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学语文</title>
    <link href="/archives/8a987d25.html"/>
    <url>/archives/8a987d25.html</url>
    
    <content type="html"><![CDATA[<h1 id="大学语文"><a href="#大学语文" class="headerlink" title="大学语文"></a>大学语文</h1><h2 id="背诵篇目"><a href="#背诵篇目" class="headerlink" title="背诵篇目"></a>背诵篇目</h2><h3 id="清华大学王观堂先生纪念碑铭（节选）"><a href="#清华大学王观堂先生纪念碑铭（节选）" class="headerlink" title="清华大学王观堂先生纪念碑铭（节选）"></a>清华大学王观堂先生纪念碑铭（节选）</h3><p>士之读书治学，盖将以脱心志于俗谛之桎梏，真理因得以发扬。思想而不自由，毋宁死耳。斯古今仁圣所同殉之精义，夫岂庸鄙之敢望。先生以一死见其独立自由之意志，非所论于一人之恩怨，一姓之兴亡。呜呼！树兹石于讲舍，系哀思而不忘。表哲人之奇节，诉真宰之茫茫。来世不可知者也，先生之著述，或有时而不章，先生之学说，或有时而可商。惟此独立之精神，自由之思想，历千万祀，与天壤而同久，共三光而永光。</p><h3 id="兰亭集序"><a href="#兰亭集序" class="headerlink" title="兰亭集序"></a>兰亭集序</h3><p>永和九年，岁在癸丑。暮春之初，会于会稽山阴之兰亭，修禊事也。群贤毕至，少长咸集。此地有崇山峻岭，茂林修竹，又有清流激湍，映带左右，引以为流觞曲水，列坐其次。虽无丝竹管弦之盛，一觞一咏，亦足以畅叙幽情。是日也，天朗气清，惠风和畅，仰观宇宙之大，俯察品类之盛，所以游目骋怀，足以极视听之娱，信可乐也。夫人之相与，俯仰一世。或取诸怀抱，晤言一室之内，或因寄所托，放浪形骸之外。虽趣舍万殊，静躁不同，当其欣于所遇，暂得于己，快然自足，不知老之将至；及其所之既倦，情随事迁，感慨系之矣！向之所欣，俛仰之间，已为陈迹，犹不能不以之兴怀。况修短随化，终期于尽。古人云，“死生亦大矣！”岂不痛哉！每览昔人兴感之由，若合一契，未尝不临文嗟悼，不能喻之于怀。固知一死生为虚诞，齐彭殇为妄作，后之视今，亦犹今之视昔。悲夫！故列叙时人，录其所述。虽世殊事异，所以兴怀，其致一也。后之览者，亦将有感于斯文。</p><h3 id="与元九书（节选）"><a href="#与元九书（节选）" class="headerlink" title="与元九书（节选）"></a>与元九书（节选）</h3><p>夫文尚矣！三才各有文，天之文，三光首之；地之文，五材首之；人之文，六经首之。就六经而言，《诗》又首之。何者？圣人感人心而天下和平。感人心者，莫先乎情，莫始乎言，莫切乎声，莫深乎义。诗者，根情，苗言，华声，实义。上自圣贤，下至愚騃，微及豚鱼，幽及鬼神；群分而气同，形异而情一；未有声入而不应，情交而不感者。</p><p>圣人知其然，因其言，经之以六义；缘其声，纬之以五音。音有韵，义有类。韵协则言顺，言顺则声易入。类举则情见，情见则感易交。于是乎孕大含深，贯微洞密，上下通而一气泰，忧乐合而百志熙。五帝三皇所以直道而行，垂拱而理者，揭此以为大柄，决此以为大窦也。</p><h3 id="楚辞·渔父"><a href="#楚辞·渔父" class="headerlink" title="楚辞·渔父"></a>楚辞·渔父</h3><p>屈原既放，游于江潭，行吟泽畔，颜色憔悴，形容枯槁。渔父见而问之曰：“子非三闾大夫与？何故至于斯？”屈原曰：“举世皆浊我独清，众人皆醉我独醒，是以见放。”渔父曰：“圣人不凝滞于物，而能与世推移。世人皆浊，何不淈其泥而扬其波？众人皆醉，何不餔其糟而歠其醨？何故深思高举，自令放为？”屈原曰：“吾闻之，新沐者必弹冠，新浴者必振衣。安能以身之察察，受物之汶汶乎？宁赴湘流，葬于江鱼之腹中，安能以皓皓之白，而蒙世俗之尘埃乎？”渔父莞尔而笑，鼓枻而去。歌曰：“沧浪之水清兮，可以濯吾缨；沧浪之水浊兮，可以濯吾足。”遂去，不复与言。</p><h3 id="别赋（节选）"><a href="#别赋（节选）" class="headerlink" title="别赋（节选）"></a>别赋（节选）</h3><p>黯然销魂者，唯别而已矣！况秦吴兮绝国，复燕宋兮千里。或春苔兮始生，乍秋风兮蹔起。是以行子肠断，百感凄恻。风萧萧而异响，云漫漫而奇色。舟凝滞于水滨，车逶迟于山侧。棹容与而讵前，马寒鸣而不息。掩金觞而谁御，横玉柱而霑轼。居人愁卧，恍若有亡。日下壁而沉彩，月上轩而飞光；见红兰之受露，望青楸之罹霜。巡层楹而空掩，抚锦幕而虚凉。知离梦之踟躅，意别魂之飞扬。</p><p>乃有剑客惭恩，少年报士。韩国赵厕，吴宫燕市；割慈忍爱，离邦去里；沥泣共诀，抆血相视。驱征马而不顾，见行尘之时起。方衔感与一剑，非买价于泉里。金石震而色变，骨肉悲而心死。</p><h3 id="长恨歌（节选）"><a href="#长恨歌（节选）" class="headerlink" title="长恨歌（节选）"></a>长恨歌（节选）</h3><p>汉皇重色思倾国，御宇多年求不得。<br>杨家有女初长成，养在深闺人未识。<br>天生丽质难自弃，一朝选在君王侧。<br>回眸一笑百媚生，六宫粉黛无颜色。<br>春寒赐浴华清池，温泉水滑洗凝脂。<br>侍儿扶起娇无力，始是新承恩泽时。<br>云鬓花颜金步摇，芙蓉帐暖度春宵。<br>春宵苦短日高起，从此君王不早朝。<br>承欢侍宴无闲暇，春从春游夜专夜。<br>后宫佳丽三千人，三千宠爱在一身。<br>金屋妆成娇侍夜，玉楼宴罢醉和春。<br>姊妹弟兄皆列土，可怜光彩生门户。<br>遂令天下父母心，不重生男重生女。<br>骊宫高处入青云，仙乐飘飘处处闻。<br>缓歌慢舞凝丝竹，尽日君王看不足。<br>渔阳鼙鼓动地来，惊破《霓裳羽衣曲》。</p><h3 id="古诗十九首（西北有高楼）"><a href="#古诗十九首（西北有高楼）" class="headerlink" title="古诗十九首（西北有高楼）"></a>古诗十九首（西北有高楼）</h3><p>西北有高楼，上与浮云齐。<br>交疏结绮窗，阿阁三重阶。<br>上有弦歌声，音响一何悲！<br>谁能为此曲？无乃杞梁妻。<br>清商随风发，中曲正徘徊。<br>一弹再三叹，慷慨有馀哀。<br>不惜歌者苦，但伤知音稀。<br>愿为双鸿鹄，奋翅起高飞。</p><h3 id="临江仙·夜归临皋"><a href="#临江仙·夜归临皋" class="headerlink" title="临江仙·夜归临皋"></a>临江仙·夜归临皋</h3><p>夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣，敲门都不应，倚杖听江声。<br>长恨此身非我有，何时忘却营营！夜阑风静縠纹平，小舟从此逝，江海寄馀生。</p><hr><p>$$<br>\mathscr{THE} \quad \mathscr{END}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>文学</category>
      
      <category>语文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数理统计</title>
    <link href="/archives/df0b519f.html"/>
    <url>/archives/df0b519f.html</url>
    
    <content type="html"><![CDATA[<h1 id="数理统计"><a href="#数理统计" class="headerlink" title="数理统计"></a>数理统计</h1><h2 id="样本及抽样分布"><a href="#样本及抽样分布" class="headerlink" title="样本及抽样分布"></a>样本及抽样分布</h2><h3 id="随机样本"><a href="#随机样本" class="headerlink" title="随机样本"></a>随机样本</h3><p>随机样本：设 $X$ 是具有分布函数 $F$ 的随机变量，若 $X_1,\cdots,X_n$ 是具有分布函数 $F$ 的，相互独立的随机变量，则称 $X_1,X_2,\cdots,X_n$ 为从分布函数 $F$ （或总体 $F$ ，或总体 $X$ ）得到的容量为 $n$ 的简单随机样本，简称样本，它们的观察值 $x_1,\cdots,x_n$ 称为样本值，又称为 $X$ 的 $n$ 个独立的观察值。</p><h3 id="直方图和箱线图"><a href="#直方图和箱线图" class="headerlink" title="直方图和箱线图"></a>直方图和箱线图</h3><h3 id="抽样分布"><a href="#抽样分布" class="headerlink" title="抽样分布"></a>抽样分布</h3><p>常用统计量：设 $X_1,\cdots,X_n$ 是来自总体 $X$ 的一个样本， $x_1,\cdots,x_n$ 是这一组样本的观察值，定义</p><p>样本平均值：<br>$$<br>\overline{X}=\dfrac{1}{n}\sum_{i=1}^nX_i<br>$$<br>样本方差：<br>$$<br>S^2=\dfrac{1}{n-1}\sum_{i=1}^n(X-X_i)^2=\dfrac{1}{n-1}(\sum_{i=1}^nX_i^2-n\overline{X}^2)<br>$$<br>样本标准差：<br>$$<br>S=\sqrt{S^2}=\sqrt{\dfrac{1}{n-1}\sum_{i=1}^n(X-X_i)^2}<br>$$<br>样本 $k$ 阶原点矩：<br>$$<br>A_k=\dfrac{1}{n}\sum_{i=1}^nX_i^k,k=1,2,\cdots<br>$$<br>样本 $k$ 阶中心矩：<br>$$<br>B_k=\dfrac{1}{n}\sum_{i=1}^n(X_i-\overline{X})^k,k=2,3,\cdots<br>$$<br>它们的观察值分别为：<br>$$<br>\overline{x}=\dfrac{1}{n}\sum_{i=1}^nx_i<br>$$<br>$$<br>s^2=\dfrac{1}{n-1}\sum_{i=1}^n(x-x_i)^2=\dfrac{1}{n-1}(\sum_{i=1}^nx_i^2-n\overline{x}^2)<br>$$<br>$$<br>s=\sqrt{s^2}=\sqrt{\dfrac{1}{n-1}\sum_{i=1}^n(x-x_i)^2}<br>$$<br>$$<br>a_k=\dfrac{1}{n}\sum_{i=1}^nx_i^k,k=1,2,\cdots<br>$$<br>$$<br>b_k=\dfrac{1}{n}\sum_{i=1}^n(x_i-\overline{x})^k,k=2,3,\cdots<br>$$<br>经验分布函数：设 $X_1,\cdots ,X_n$ 是总体 $F$ 的一个样本，用 $S(x),-\infty&lt;x&lt;\infty$ 表示 $X_1,\cdots ,X_n$ 中不大于 $x$ 的随机变量的个数。定义经验分布函数 $F_n(x)$ 为<br>$$<br>F_n(x)=\dfrac{1}{n}S(x),-\infty&lt;x&lt;\infty<br>$$<br>来自正态总体的几个常用统计量的分布：</p><h4 id="chi-2-分布"><a href="#chi-2-分布" class="headerlink" title="$\chi ^2$ 分布"></a>$\chi ^2$ 分布</h4><p> $\chi^2$ 分布：设 $X_1,\cdots ,X_n$ 是来自总体 $N(0,1)$ 的样本，则称统计量<br>$$<br>\chi^2=X_1^2+\cdots +X_n^2<br>$$<br>为服从自由度为 $n$ 的 $\chi^2$ 分布，记为 $\chi^2\sim \chi^2(n)$ 。</p><p> $\chi^2$ 分布的概率密度为<br>$$<br>f(y)=\begin{cases}  \dfrac{1}{2^{n/2}\Gamma(n/2)}y^{n/2-1}\mathrm{e}^{-y/2},y&gt;0 \\  0,\text{其他} \end{cases}<br>$$<br> $\chi^2$ 分布的可加性：设 $\chi_1^2\sim \chi_1^2(n_1)$ ， $\chi_2^2\sim \chi_2^2(n_2)$ 并且 $\chi_1^2,\chi_2^2$ 相互独立，则有<br>$$<br>\chi_1^2+\chi_2^2\sim \chi_1^2(n_1+n_2)<br>$$<br> $\chi^2$ 分布的数学期望与方差：若 $\chi^2\sim \chi^2(n)$ ，则有<br>$$<br>E(\chi^2)=n,D(\chi^2)=2n<br>$$<br> $\chi^2$ 分布的上分位点：对于给定正数 $\alpha,\alpha&lt;1$ ，满足条件<br>$$<br>P\{ \chi^2&gt;\chi_{\alpha}^2(n) \}=\int_{\chi_{\alpha}^2(n)}^{\infty}f(y)\mathrm{d}y=\alpha<br>$$<br>的点 $\chi_{\alpha}^2(n)$ 就是 $\chi^2(n)$ 分布的上 $\alpha$ 分位点。当 $\alpha$ 充分大时，近似的有<br>$$<br>\chi_{\alpha}^2(n)\approx \dfrac{1}{2}(z_{\alpha}+\sqrt{2n-1})^2<br>$$<br>其中 $z_{\alpha}$ 是标准正态分布的上 $\alpha$ 分位点。</p><h4 id="t-分布"><a href="#t-分布" class="headerlink" title="$t$ 分布"></a>$t$ 分布</h4><p>$t$ 分布：设 $X\sim N(0,1),Y\sim \chi^2(n)$ ，且 $X,Y$ 相互独立，则称随机变量<br>$$<br>t=\frac{X}{\sqrt{Y/n}}<br>$$<br>服从自由度为 $n$ 的 $t$ 分布，记为 $t\sim t(n)$ 。</p><p>$t$ 分布又称学生氏分布， $t(n)$ 分布的概率密度函数为<br>$$<br>h(t)=\dfrac{\Gamma[(n+1)/2]}{\sqrt{\pi n}\Gamma(n/2)}(1+\dfrac{t^2}{n})^{-(n+1)/2},-\infty&lt;t&lt;\infty<br>$$<br> $t$ 分布的上分位点：对于给定的 $\alpha,0&lt;\alpha&lt;1$ ，满足条件<br>$$<br>P\{t&gt;t_\alpha(n)\}=\int_{t_\alpha(n)}^\infty h(t)\mathrm{d}t = \alpha<br>$$<br>的点 $t_{\alpha}(n)$ 就是 $t(n)$ 分布上 $\alpha$ 分位点。</p><p>有 $t_{1-\alpha}(n)=-t_{\alpha}(n)$ 。<br>当 $t_{\alpha}(n)$ 时， $t_{\alpha}(n)\approx z_{\alpha}$ 。</p><h4 id="F-分布"><a href="#F-分布" class="headerlink" title="$F$ 分布"></a>$F$ 分布</h4><p>$F$ 分布:设 $U\sim \chi^2(n_1),V\sim \chi^2(n_2)$ ，且 $U,V$ 相互独立，则称随机变量<br>$$<br>F=\dfrac{U/n_1}{V/n_2}<br>$$<br>服从自由度为 $(n_1,n_2)$ 的 $F$ 分布，记为 $F\sim F(n_1,n_2)$ 。</p><p> $F$ 分布的概率密度为<br>$$<br>\varphi(y)=\begin{cases}<br>\dfrac{\Gamma[(n_1+n_2)/2]{(n_1/n_2)}^{n_1/2}y^{(n_1/2)-1}}{\Gamma(n_1/2)\Gamma(n_2/2)[1+(n_1y/n_2)]^{(n_1+n_2)/2}},y&gt;0<br>  \\<br>0,\text{其他}<br>\end{cases}<br>$$<br>由定义知，若 $F\sim F(n_1,n_2)$ ，则 $\dfrac{1}{F}\sim F(n_2,n_1)$ 。</p><p> $F$ 分布的上分位点：对于给定的 $\alpha,0&lt;\alpha&lt;1$ ，满足条件<br>$$<br>P\{ F&gt;F_{\alpha}(n_1,n_2) \}=\int_{F_{\alpha}(n_1,n_2)}^{\infty}\varphi (y)\mathrm{d}y = \alpha<br>$$<br>的点 $F_{\alpha}(n_1,n_2)$ 就是 $F(n_1,n_2)$ 分布的上 $\alpha$ 分位点。</p><p>$$<br>F_{1-\alpha}(n_1,n_2)=\dfrac{1}{F_{\alpha}(n_2,n_1)}<br>$$</p><h4 id="正态分布的样本均值与样本方差的分布"><a href="#正态分布的样本均值与样本方差的分布" class="headerlink" title="正态分布的样本均值与样本方差的分布"></a>正态分布的样本均值与样本方差的分布</h4><p>定理：设 $X_1,\cdots,X_n$ 是来自正态总体 $N(\mu,\sigma^2)$ 的样本， $\overline{X}$ 是样本均值，则有 $\overline{X}\sim N(\mu,\sigma^2/n)$ 。</p><p>定理：设 $X_1,\cdots,X_n$ 是来自总体 $N(\mu,\sigma^2)$ 的样本， $\overline{X},S^2$ 分别是样本均值和样本方差，则有</p><ol><li> $\dfrac{(n-1)S^2}{\sigma^2}\sim \chi^2(n-1)$ 。</li><li> $\overline{X}$与$S^2$相互独立 。</li></ol><p>定理：设 $X_1,\cdots,X_n$ 是来自总体 $N(\mu,\sigma^2)$ 的样本， $\overline{X},S^2$ 分别是样本均值和样本方差，则有 $\dfrac{\overline{X}-\mu}{S/\sqrt{n}}\sim t(n-1)$ 。</p><p>定理：设 $X_1,\cdots,X_{n_1}$ 与 $Y_1,\cdots,Y_{n_2}$ 分别是来自正态总体 $N(\mu_1,\sigma_1^2)$ 和 $N(\mu_2,\sigma_2^2)$ 的样本，且这两个样本相互独立。设 $\overline{X}$ ， $\overline{Y}$ 分别是这两个样本的样本均值， $S_1^2$ ， $S_2^2$ 分别是这两个样本的样本方差，则有</p><ol><li> $\dfrac{S_1^2/S_2^2}{\sigma_1^2/\sigma_2^2}\sim F(n_1-1,n_2-1)$ 。</li><li>当 $\sigma_1^2=\sigma_2^2=\sigma^2$ 时，<br>$$<br>\dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S_{\omega}\sqrt{\dfrac{1}{n_1}+\dfrac{1}{n_2}}}<br>$$<br>其中<br>$$<br>S_{\omega}^2=\dfrac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2},S_{\omega} = \sqrt{S_{\omega}^2}<br>$$</li></ol><h2 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h2><h3 id="点估计"><a href="#点估计" class="headerlink" title="点估计"></a>点估计</h3><p>估计：设总体 $X$ 的分布函数 $F(X;\theta)$ 的形式为已知， $\theta$ 为待估参数， $X_1,\cdots,X_n$ 是 $X$ 的一个样本， $x_1,\cdots,x_n$ 是相应的一个样本值。点估计问题就是要构造一个适当的统计量 $\hat{\theta}(X_1,\cdots,X_n)$ ，用它的观察值 $\hat{\theta}(x_1,\cdots,x_n)$ 作为未知参数 $\theta$ 的近似值，我们称 $\hat{\theta}(X_1,\cdots,X_n)$ 为 $\theta$ 的估计量，称 $\hat{\theta}(x_1,\cdots,x_n)$ 为 $\theta$ 的估计值。都称为估计。</p><h4 id="矩估计法"><a href="#矩估计法" class="headerlink" title="矩估计法"></a>矩估计法</h4><p>矩估计：设 $X$ 为连续型随机变量，其概率密度为 $f(x;\theta_1,\cdots,\theta_k)$ ，或 $X$ 为离散型随机变量，其分布律为 $P\{ X=x \}=p(x;\theta_1,\cdots,\theta_k)$ ，其中 $\theta_1,\cdots,\theta_k$ 为待估计参数， $X_1,\cdots,X_n$ 是来自 $X$ 的样本，假设总体 $X$ 的前 $k$ 阶矩<br>$$<br>\mu_l = E(X^l)=\int_{-\infty}^{\infty}x^lf(x;\theta_1,\cdots,\theta_k)\mathrm{d}x,l=1,2,\cdots,k<br>$$<br>或<br>$$<br>\mu_l = E(X^l)=\sum_{x\in R_{X}}x^lp(x;\theta_1,\cdots,\theta_k),l=1,2,\cdots,k<br>$$<br>其中 $R_{X}$ 是 $X$ 可能取值的范围。样本矩为<br>$$<br>A_l=\dfrac{1}{n}\sum_{i=1}^nX_i^l<br>$$<br>用 $A_i$ 代替 $\mu_i$ ，得到<br>$$<br>\hat{\theta}_i = \theta_i(A_1,\cdots,A_k),i=1,2,\cdots,k<br>$$<br>分别作为 $\theta_i,i=1,2,\cdots,k$ 的估计量，这种估计量称为矩估计量，矩估计量的观察值称为矩估计值。</p><h4 id="最大似然估计法"><a href="#最大似然估计法" class="headerlink" title="最大似然估计法"></a>最大似然估计法</h4><p>似然函数：当 $X$ 为离散型随机变量，设 $X_1,\cdots,X_n$ 是来自 $X$ 的样本， $x_1,\cdots,x_n$ 为观察值，则其概率为<br>$$<br>L(\theta)=L(x_1,\cdots,x_n;\theta)=\prod_{i=1}^np(x_i;\theta),\theta \in \varTheta<br>$$<br>当 $X$ 为连续型随机变量，设 $X_1,\cdots,X_n$ 是来自 $X$ 的样本， $x_1,\cdots,x_n$ 为其观察值，则其概率为<br>$$<br>L(\theta)=L(x_1,\cdots,x_n;\theta)=\prod_{i=1}^nf(x_i;\theta),\theta \in \varTheta<br>$$<br>称 $L(\theta)$ 为样本的似然函数。</p><p>最大似然估计：若<br>$$<br>L(x_1,\cdots,x_n;\hat{\theta})=\mathrm{max}_{\theta\in \varTheta}L(x_1,\cdots,x_n;\theta)<br>$$<br>则称 $\hat{\theta}(x_1,\cdots,x_n)$ 为 $\theta$ 的最大似然估计值，称 $\hat{\theta}(X_1,\cdots,X_n)$ 为 $\theta$ 的最大似然估计量。</p><p>对数似然方程：<br>$$<br>\dfrac{\mathrm{d}}{\mathrm{d}\theta}\mathrm{ln}L(\theta)=0<br>$$</p><p>若有多个参数，则可以列出对数似然方程组求解。</p><h3 id="估计量的评选标准"><a href="#估计量的评选标准" class="headerlink" title="估计量的评选标准"></a>估计量的评选标准</h3><h4 id="无偏性"><a href="#无偏性" class="headerlink" title="无偏性"></a>无偏性</h4><p>无偏性：若估计量 $\hat{\theta}=\hat{\theta}(X_1,\cdots,X_n)$ 的数学期望 $E(\hat{\theta})$ 存在，且对于任意的 $\theta\in \varTheta$ 有 $E(\hat{\theta})=\theta$ ，则称 $\hat{\theta}$ 是 $\theta$ 的无偏估计量。</p><h4 id="有效性"><a href="#有效性" class="headerlink" title="有效性"></a>有效性</h4><p>有效性：设 $\hat{\theta}_1 = \hat{\theta}_1(X_1,\cdots,X_n)$ 与 $\hat{\theta}_2 = \hat{\theta}_2(X_1,\cdots,X_n)$ 都是 $\theta$ 的无偏估计量，若对于任意 $\theta\in\varTheta$ ，有 $D(\hat{\theta}_1)\leq D(\hat{\theta}_2)$ 。且至少对于某一个 $\theta\in\varTheta$ 上式中的不等号成立，则称 $\theta_1$ 较 $\theta_2$ 有效。</p><h4 id="相合性"><a href="#相合性" class="headerlink" title="相合性"></a>相合性</h4><p>相合性：设 $\hat{\theta}(X_1,\cdots,X_n)$ 为参数 $\theta$ 的估计量，若对于任意 $\theta\in \varTheta$ ，当 $n\rightarrow \infty$ 时 $\hat{\theta}(X_1,\cdots,X_n)$ 依概率收敛于 $\theta$ ，则称 $\hat{\theta}$ 为 $\theta$ 的相合估计量。<br>即，对于任意 $\theta \in \varTheta$ 都满足：对于任意 $\varepsilon &gt;0$ ，有<br>$$<br>\lim_{n\to \infty}P\{ |\hat{\theta}-\theta|&lt;\varepsilon \}=1<br>$$<br>则称 $\hat{\theta}$ 是 $\theta$ 的相合估计量。</p><h3 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h3><p>置信区间：设总体 $X$ 的分布函数 $F(x;\theta)$ 含有一个未知参数 $\theta,\theta\in\varTheta$ （ $\varTheta$ 是 $\theta$ 可能的取值范围），对于给定值 $\alpha(0&lt;\alpha&lt;1)$ ，若由来自 $X$ 的样本 $X_1,\cdots,X_n$ 确定的两个统计量 $\underline{\theta}=\underline{\theta}(X_1,\cdots,X_n)$ 和 $\overline{\theta}=\overline{\theta}(X_1,\cdots,X_n)(\underline{\theta}&lt;\theta&lt;\overline{\theta})$ ，对于任意 $\theta\in\varTheta$ 满足<br>$$<br>P\{ \underline{\theta}(X_1,\cdots,X_n)&lt;\theta&lt;\overline{\theta}(X_1,\cdots,X_n) \}\geq 1-\alpha<br>$$<br>则称随机区间 $(\underline{\theta},\overline{\theta})$ 是 $\theta$ 的置信水平为 $1-\alpha$ 的置信区间， $\underline{\theta}$ 和 $\overline{\theta}$ 分别称为置信水平为 $1-\alpha$ 的双侧置信区间的置信下限和置信上限， $1-\alpha$ 称为置信水平。</p><p>单侧置信区间：对于给定值 $\alpha(0&lt;\alpha&lt;1)$ ，若由样本 $X_1,X_2,\cdots,X_n$ 确定的统计量 $\underline{\theta}=\underline{\theta}(X_1,\cdots,X_n)$ ，对于任意 $\theta\in\varTheta$ 满足 $P\{ \theta&gt;\underline{\theta} \}\geq 1-\alpha$ ，称随机区间 $(\underline{\theta},\infty)$ 是 $\theta$ 的置信水平为 $1-\alpha$ 的单侧置信区间， $\underline{\theta}$ 称为 $\theta$ 的置信水平为 $1-\alpha$ 的单侧置信下限。又若统计量 $\overline{\theta}=\overline{\theta}(X_1,\cdots,X_n)$ ，对于任意 $\theta\in\varTheta$ 满足 $P\{ \theta&lt;\overline{\theta} \}\geq 1-\alpha$ ，称随机区间 $(-\infty,\overline{\theta})$ 是 $\theta$ 的置信水平为 $1-\alpha$ 的单侧置信区间， $\overline{\theta}$ 称为 $\theta$ 的置信水平为 $1-\alpha$ 的单侧置信上限。</p><table><thead><tr><th></th><th>待估参数</th><th>其他参数</th><th>枢轴量的分布</th><th>置信区间</th><th>单侧置信限</th></tr></thead><tbody><tr><td>一个正态总体</td><td>$\mu$</td><td>$\sigma^2$ 已知</td><td>$Z=\dfrac{\overline{X}-\mu}{\sigma/\sqrt{n}}\sim N(0,1)$</td><td>$(\overline{X}\pm\dfrac{\sigma}{\sqrt{n}}z_{\alpha/2})$</td><td>$\overline{\mu}=\overline{X}+\dfrac{\sigma}{\sqrt{n}}z_{\alpha},\underline{\mu}=\overline{X}-\dfrac{\sigma}{\sqrt{n}}z_{\alpha}$</td></tr><tr><td>一个正态总体</td><td>$\mu$</td><td>$\sigma^2$ 未知</td><td>$t=\dfrac{\overline{X}-\mu}{S/\sqrt{n}}\sim t(n-1)$</td><td>$(\overline{X}\pm\dfrac{S}{\sqrt{n}}t_{\alpha_2}(n-1))$</td><td>$\overline{\mu}=\overline{X}+\dfrac{S}{\sqrt{n}}t_{\alpha}(n-1),\underline{\mu}=\overline{X}-\dfrac{S}{\sqrt{n}}t_{\alpha}(n-1)$</td></tr><tr><td>一个正态总体</td><td>$\sigma^2$</td><td>$\mu$ 未知</td><td>$\chi^2=\dfrac{(n-1)S^2}{\sigma^2}\sim \chi^2(n-1)$</td><td>$(\dfrac{(n-1)S^2}{\chi_{\alpha/2}^2(n-1)},\dfrac{(n-1)S^2}{\chi_{1-\alpha/2}^2(n-1)})$</td><td>$\overline{\sigma^2}=\dfrac{(n-1)S^2}{\chi_{1-\alpha}^2(n-1)},\underline{\sigma^2}=\dfrac{(n-1)S^2}{\chi_{\alpha}^2(n-1)}$</td></tr><tr><td>两个正态总体</td><td>$\mu_1-\mu_2$</td><td>$\sigma_1^2,\sigma_2^2$ 已知</td><td>$Z=\dfrac{\overline{X}-\overline{Y}-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}\sim N(0,1)$</td><td>$(\overline{X}-\overline{Y}\pm z_{\alpha/2}\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}})$</td><td>$\overline{\mu_1-\mu_2}=\overline{X}-\overline{Y}+ z_{\alpha}\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}},\underline{\mu_1-\mu_2}=\overline{X}-\overline{Y} - z_{\alpha}\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}$</td></tr><tr><td>两个正态总体</td><td>$\mu_1-\mu_2$</td><td>$\sigma_1^2=\sigma_2^2=\sigma^2$ 未知</td><td>$t=\dfrac{(\overline{X}-\overline{Y})-(\mu_1-\mu_2)}{S_{\omega}\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}\sim t(n_1+n_2-2),S_{\omega}^2=\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}$</td><td>$(\overline{X}-\overline{Y}\pm t_{\alpha/2}(n_1+n_2-2)S_{\omega}\sqrt{\frac{1}{n_1}+\frac{1}{n_2}})$</td><td>$\overline{\mu_1-\mu_2}=\overline{X}-\overline{Y}+ t_{\alpha}(n_1+n_2-2)S_{\omega}\sqrt{\frac{1}{n_1}+\frac{1}{n_2}},\underline{\mu_1-\mu_2}=\overline{X}-\overline{Y}- t_{\alpha}(n_1+n_2-2)S_{\omega}\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}$</td></tr><tr><td>两个正态总体</td><td>$\dfrac{\sigma_1^2}{\sigma_2^2}$</td><td>$\mu_1,\mu_2$ 未知</td><td>$F=\dfrac{S_1^2/S_2^2}{\sigma_1^2/\sigma_2^2}\sim F(n_1-1,n_2-1)$</td><td>$(\dfrac{S_1^2}{S_2^2}\dfrac{1}{F_{\alpha/2}(n_1-1,n_2-1)},\dfrac{S_1^2}{S_2^2}\dfrac{1}{F_{1-\alpha/2}(n_1-1,n_2-1)})$</td><td>$\overline{\dfrac{\sigma_1^2}{\sigma_2^2}}=\dfrac{S_1^2}{S_2^2}\dfrac{1}{F_{1-\alpha}(n_1-1,n_2-1)},\underline{\dfrac{\sigma_1^2}{\sigma_2^2}}=\dfrac{S_1^2}{S_2^2}\dfrac{1}{F_{\alpha}(n_1-1,n_2-1)}$</td></tr></tbody></table><h2 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h2><h3 id="假设检验-1"><a href="#假设检验-1" class="headerlink" title="假设检验"></a>假设检验</h3><h3 id="正态总体均值，方差的假设检验"><a href="#正态总体均值，方差的假设检验" class="headerlink" title="正态总体均值，方差的假设检验"></a>正态总体均值，方差的假设检验</h3><table><thead><tr><th></th><th>原假设 $H_0$</th><th>检验统计量</th><th>备择假设 $H_1$</th><th>拒绝域</th></tr></thead><tbody><tr><td>1</td><td>$\mu\leq \mu_0 \\ \mu \geq \mu_0 \\ \mu = \mu_0 \\ \sigma^2 \text{已知}$</td><td>$Z=\dfrac{\overline{X}-\mu}{\sigma/\sqrt{n}}$</td><td>$\mu&gt; \mu_0 \\ \mu &lt; \mu_0 \\ \mu \neq \mu_0 $</td><td>$z\geq z_{\alpha} \\ z\leq -z_{\alpha} \\ \vert z\vert \geq z_{\alpha /2}$</td></tr><tr><td>2</td><td>$\mu\leq \mu_0 \\ \mu \geq \mu_0 \\ \mu = \mu_0 \\ \sigma^2 \text{未知}$</td><td>$t=\dfrac{\overline{X}-\mu_0}{S/\sqrt{n}}$</td><td>$\mu&gt; \mu_0 \\ \mu &lt; \mu_0 \\ \mu \neq \mu_0 $</td><td>$t\geq t_{\alpha}(n-1) \\ t\leq -t_{\alpha}(n-1) \\ \vert t\vert \geq t_{\alpha /2}(n-1)$</td></tr><tr><td>3</td><td>$\mu_1-\mu_2\leq \delta \\ \mu_1-\mu_2\geq \delta \\ \mu_1-\mu_2= \delta \\ (\sigma_1^2,\sigma_2^2\text{已知})$</td><td>$Z=\dfrac{\overline{X}-\overline{Y}-\delta}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}$</td><td>$\mu_1-\mu_2&gt; \delta \\ \mu_1-\mu_2&lt; \delta \\ \mu_1-\mu_2\neq \delta$</td><td>$z\geq z_{\alpha} \\ z\leq -z_{\alpha} \\ \vert z \vert \geq z_{\alpha/2}$</td></tr><tr><td>4</td><td>$\mu_1-\mu_2\leq \delta \\ \mu_1-\mu_2\geq \delta \\ \mu_1-\mu_2= \delta \\ (\sigma_1^2=\sigma_2^2=\sigma^2 \text{未知})$</td><td>$t=\dfrac{\overline{X}-\overline{Y}-\delta}{S_{\omega}\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}},S_{\omega}^2=\dfrac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}$</td><td>$\mu_1-\mu_2&gt; \delta \\ \mu_1-\mu_2&lt; \delta \\ \mu_1-\mu_2\neq \delta$</td><td>$t\geq t_{\alpha}(n_1+n_2-2) \\ t\leq -t_{\alpha}(n_1+n_2-2) \\ \vert t \vert \geq t_{\alpha/2}(n_1+n_2-2)$</td></tr><tr><td>5</td><td>$\sigma^2\leq \sigma_0^2 \\ \sigma^2\geq \sigma_0^2 \\ \sigma^2= \sigma_0^2 \\ (\mu \text{未知})$</td><td>$\chi^2=\dfrac{(n-1)S^2}{\sigma_0^2}$</td><td>$\sigma^2&gt; \sigma_0^2 \\ \sigma^2&lt; \sigma_0^2 \\ \sigma^2\neq \sigma_0^2$</td><td>$\chi^2\geq \chi_{\alpha}^2(n-1) \\ \chi^2\leq \chi_{1-\alpha}^2(n-1) \\ \chi^2\geq \chi_{\alpha/2}^2(n-1) \text{或} \chi^2\leq \chi_{1-\alpha/2}^2(n-1) $</td></tr><tr><td>6</td><td>$\sigma^2\leq \sigma_0^2 \\ \sigma^2\geq \sigma_0^2 \\ \sigma^2= \sigma_0^2 \\ (\mu_1,\mu_2 \text{未知})$</td><td>$F=\dfrac{S_1^2}{S_2^2}$</td><td>$\sigma^2&gt; \sigma_0^2 \\ \sigma^2&lt; \sigma_0^2 \\ \sigma^2\neq \sigma_0^2$</td><td>$F\geq F_{\alpha}(n_1-1,n_2-1) \\ F\leq F_{1-\alpha}(n_1-1,n_2-1) \\ F\geq F_{\alpha/2}(n_1-1,n_2-1) \text{或} F\leq F_{1-\alpha/2}(n_1-1,n_2-1) $</td></tr><tr><td>7</td><td>$\mu_D \leq 0 \\ \mu_D  \geq 0 \\ \mu_D  = 0 \\ \text{成对数据}$</td><td>$t=\dfrac{\overline{D}-0}{S_D/\sqrt{n}}$</td><td>$\mu_D&gt; 0 \\ \mu_D &lt; 0 \\ \mu_D \neq 0 $</td><td>$t\geq t_{\alpha}(n-1) \\ t\leq -t_{\alpha}(n-1) \\ \vert t\vert \geq t_{\alpha /2}(n-1)$</td></tr></tbody></table><hr><p>$$<br>\mathscr{THE} \quad \mathscr{END}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>应用数学</category>
      
      <category>概率统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式问题</title>
    <link href="/archives/d63dd81.html"/>
    <url>/archives/d63dd81.html</url>
    
    <content type="html"><![CDATA[<p>LaTex与Markdown语法存在不兼容的情况，这里提供了例子与解决办法。</p><span id="more"></span><h1 id="格式问题"><a href="#格式问题" class="headerlink" title="格式问题"></a>格式问题</h1><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><p>代码；</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">$\&#123; hello,world \&#125;$<br></code></pre></div></td></tr></table></figure><p>显示：$\{ hello,world \}$</p><p>解决方法：</p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">$\&#123; hello,world \&#125;$<br></code></pre></div></td></tr></table></figure><p>显示：$\{ hello,world \}$</p><h2 id="行间公式换行"><a href="#行间公式换行" class="headerlink" title="行间公式换行"></a>行间公式换行</h2><p>代码；</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">$$<br>\begin&#123;cases&#125; hello \\ world \end&#123;cases&#125;<br>$$<br></code></pre></div></td></tr></table></figure><p>显示：</p><p>$$<br>\begin{cases} hello \\ world \end{cases}<br>$$</p><p>解决方法：</p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">$$<br>\begin&#123;cases&#125; hello \\ world \end&#123;cases&#125;<br>$$<br></code></pre></div></td></tr></table></figure><p>显示：</p><p>$$<br>\begin{cases} hello \\ world \end{cases}<br>$$</p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>代码；</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">数乘：若 $\lambda$ 是一个数， $A=(a_&#123;ij&#125;)_&#123;m\times n&#125;$ 是矩阵，则同型矩阵 $(\lambda a_&#123;ij&#125;)_&#123;m\times n&#125;$ 称为数 $\lambda$ 与矩阵 $A$ 的乘积，记为 $\lambda A$ 或 $A\lambda$ ，即 $\lambda A=(\lambda a_&#123;ij&#125;)_&#123;m\times n&#125;$ 。<br></code></pre></div></td></tr></table></figure><p>显示：<br>数乘：若 $\lambda$ 是一个数， $A=(a_{ij})_{m\times n}$ 是矩阵，则同型矩阵 $(\lambda a_{ij})_{m\times n}$ 称为数 $\lambda$ 与矩阵 $A$ 的乘积，记为 $\lambda A$ 或 $A\lambda$ ，即 $\lambda A=(\lambda a_{ij})_{m\times n}$ 。</p><p>解决方法：</p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">数乘：若 $\lambda$ 是一个数， $A=(a_&#123;ij&#125;)_&#123;m\times n&#125;$ 是矩阵，则同型矩阵 $(\lambda a_&#123;ij&#125;)_&#123;m\times n&#125;$ 称为数 $\lambda$ 与矩阵 $A$ 的乘积，记为 $\lambda A$ 或 $A\lambda$ ，即 $\lambda A=(\lambda a_&#123;ij&#125;)_&#123;m\times n&#125;$ 。<br></code></pre></div></td></tr></table></figure><p>显示：</p><p>数乘：若 $\lambda$ 是一个数， $A=(a_{ij})_{m\times n}$ 是矩阵，则同型矩阵 $(\lambda a_{ij})_{m\times n}$ 称为数 $\lambda$ 与矩阵 $A$ 的乘积，记为 $\lambda A$ 或 $A\lambda$ ，即 $\lambda A=(\lambda a_{ij})_{m\times n}$ 。</p><h2 id="变成链接"><a href="#变成链接" class="headerlink" title="!+[]+()变成链接"></a>!+[]+()变成链接</h2><p>代码；</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">$$<br>\begin&#123;aligned&#125; N_m(x)=&amp;\frac&#123;2&#125;&#123;\pi&#125;J_m(x)\ln\frac&#123;x&#125;&#123;2&#125;-\frac&#123;1&#125;&#123;\pi&#125;\sum_&#123;k=0&#125;^&#123;m-1&#125;\frac&#123;(m-k-1)&#125;&#123;k!&#125;(\frac&#123;x&#125;&#123;2&#125;)^&#123;2k-m&#125; \\ &amp;-\frac&#123;1&#125;&#123;\pi&#125;\sum_&#123;k=0&#125;^&#123;\infty&#125;(-1)^k\frac&#123;1&#125;&#123;k!(m+k)!&#125;[\Phi(m+k+1)+\Phi(k+1)](\frac&#123;x&#125;&#123;2&#125;)^&#123;2k+m&#125; \end&#123;aligned&#125;<br>$$<br></code></pre></div></td></tr></table></figure><p>显示：</p><p>$$<br>\begin{aligned}<br>N_m(x)=&amp;\frac{2}{\pi}J_m(x)\ln\frac{x}{2}-\frac{1}{\pi}\sum_{k=0}^{m-1}\frac{(m-k-1)}{k!}(\frac{x}{2})^{2k-m} \\ &amp;-\frac{1}{\pi}\sum_{k=0}^{\infty}(-1)^k\frac{1}{k!(m+k)!}<a href="%5Cfrac%7Bx%7D%7B2%7D">\Phi(m+k+1)+\Phi(k+1)</a>^{2k+m}<br>\end{aligned}<br>$$</p><p>解决方法：</p><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">\begin&#123;aligned&#125; N_m(x)=&amp;\frac&#123;2&#125;&#123;\pi&#125;J_m(x)\ln\frac&#123;x&#125;&#123;2&#125;-\frac&#123;1&#125;&#123;\pi&#125;\sum_&#123;k=0&#125;^&#123;m-1&#125;\frac&#123;(m-k-1)&#125;&#123;k!&#125;(\frac&#123;x&#125;&#123;2&#125;)^&#123;2k-m&#125; \\ &amp;-\frac&#123;1&#125;&#123;\pi&#125;\sum_&#123;k=0&#125;^&#123;\infty&#125;(-1)^k\frac&#123;1&#125;&#123;k!(m+k)!&#125;\[\Phi(m+k+1)+\Phi(k+1)\](\frac&#123;x&#125;&#123;2&#125;)^&#123;2k+m&#125; \end&#123;aligned&#125;<br></code></pre></div></td></tr></table></figure><p>显示：</p><p>$$<br>\begin{aligned} N_m(x)=&amp;\frac{2}{\pi}J_m(x)\ln\frac{x}{2}-\frac{1}{\pi}\sum_{k=0}^{m-1}\frac{(m-k-1)}{k!}(\frac{x}{2})^{2k-m} \\ &amp;-\frac{1}{\pi}\sum_{k=0}^{\infty}(-1)^k\frac{1}{k!(m+k)!}[\Phi(m+k+1)+\Phi(k+1)](\frac{x}{2})^{2k+m} \end{aligned}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等代数</title>
    <link href="/archives/37c0ce2.html"/>
    <url>/archives/37c0ce2.html</url>
    
    <content type="html"><![CDATA[<p>题目是高等代数，其实就是线性代数，线性代数大一已经考过了，这里整理一下备用，更新可能很慢。</p><span id="more"></span><h1 id="高等代数"><a href="#高等代数" class="headerlink" title="高等代数"></a>高等代数</h1><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="数域"><a href="#数域" class="headerlink" title="数域"></a>数域</h3><p>数域：设 $P$ 是由一些复数组成的集合，其中包括 0 与 1 。如果 $P$ 中任意两个数的和，差，积，商（除数不为0）仍然是 $P$ 中的数（封闭），那么 $P$ 就称为一个数域。</p><p>性质：所有的数域都包含有理数域作为它的一部分。</p><h3 id="一元多项式"><a href="#一元多项式" class="headerlink" title="一元多项式"></a>一元多项式</h3><p>一元多项式：设 $n$ 是一个非负整数，形式表达式<br>$$<br>a_nx^n+a_{n-1}x^{n-1}+\cdots +a_0<br>$$<br>其中 $a_0,\cdots,a_n$ 全属于数域 $P$ ，称为系数在数域 $P$ 中的一个一元多项式，或者简称为数域 $P$ 上的一元多项式。</p><p>相等：如果在多项式 $f(x)$ 与 $g(x)$ 中，除去系数为零的项外，同次项的系数全相等，那么 $f(x)$ 与 $g(x)$ 就称为相等，记为 $f(x)=g(x)$ 。<br>零多项式：系数全为零的多项式称为零多项式，记为0。</p><p>在多项式 $a_nx^n+a_{n-1}x^{n-1}+\cdots +a_0$ 中，如果 $a_n\neq 0$ ，那么 $a_nx^n$ 称为多项式的首项， $a_n$ 称为首项系数， $n$ 称为多项式的次数。零多项式是唯一不定义次数的多项式。多项式 $f(x)$ 的次数记为 $\partial(f(x))$ 。</p><p>设<br>$$<br>f(x)=\sum_{i=0}^na_ix^i \\ g(x)=\sum_{j=0}^mb_jx^j<br>$$</p><p>为数域 $P$ 上的两个多项式 $(n\geq m)$，则<br>$$<br>f(x)+g(x)=\sum_{i=0}^{n}(a_i+b_i)x^i \\ f(x)g(x)=\sum_{s=0}^{m+n}(\sum_{i+j=s}a_ib_j)x^s<br>$$<br>显然，数域 $P$ 上的两个多项式经过加，减，乘等运算后，所得结果仍然是数域 $P$ 上的多项式。</p><p>对于多项式的加法，有<br>$$<br>\partial(f(x)+g(x))\leq \max\{ \partial(f(x)),\partial(g(x)) \}<br>$$<br>对于多项式的乘法，如果 $f(x)\neq ,g(x)\neq 00$ ，那么 $f(x)g(x)\neq 0$ ，并且<br>$$<br>\partial(f(x)g(x))=\partial(f(x))+\partial(g(x))<br>$$<br>多项式乘积的首项系数就等于因子首项系数的乘积。</p><p>和代数运算一样，多项式的运算也满足加法交换律，加法结合律，乘法交换律，乘法结合律，乘法对加法的分配律，乘法消去律。</p><p>一元多项式环：所有系数在数域 $P$ 中的一元多项式的全体，称为数域 $P$ 上的一元多项式环，记为 $P[x]$ ， $P$ 称为 $P[x]$ 的系数域。</p><h3 id="整除的概念"><a href="#整除的概念" class="headerlink" title="整除的概念"></a>整除的概念</h3><p>带余除法：对于 $P[x]$ 中任意两个多项式 $f(x)$ 与 $g(x)$ ，其中 $g(x)\neq 0$ ，一定有 $P[x]$ 中的多项式 $q(x),r(x)$ 存在，使<br>$$<br>f(x)=q(x)g(x)+r(x)<br>$$<br>成立，其中 $\partial(r(x))&lt;\partial(g(x))$ 或者 $r(x)=0$ ，并且这样的 $q(x),r(x)$ 是唯一决定的。</p><p>带余除法中所得的 $q(x)$ 通常称为 $g(x)$ 除 $f(x)$ 的商式。 $r(x)$ 称为 $g(x)$ 除 $f(x)$ 的余式，简称商及余。</p><p>整除：数域 $P$ 上的多项式 $g(x)$ 称为整除 $f(x)$ ，如果有数域 $P$ 上的多项式 $h(x)$ 使等式<br>$$<br>f(x)=g(x)h(x)<br>$$<br>成立。我们用 $g(x)|f(x)$ 表示 $g(x)$ 整除 $f(x)$ ，用 $g(x)\not | f(x)$ 表示 $g(x)$ 不能整除 $f(x)$ 。<br>当 $g(x)|f(x)$ 时， $g(x)$ 就称为 $f(x)$ 的因式， $f(x)$ 称为 $g(x)$ 的倍式。</p><p>当 $g(x)\neq 0$ 时，带余除法给出了整除性的一个判别法。</p><p>定理：对于数域 $P$ 上的任意两个多项式 $f(x),g(x),g(x)\neq 0$ ， $g(x)|f(x)$ 的充分必要条件是 $g(x)$ 除 $f(x)$ 的余式为零。</p><p>整除的几个性质：</p><ol><li>如果 $f(x)|g(x),g(x)|f(x)$ ，那么 $f(x)=cg(x)$ ，其中 $c$ 为非零常数。</li><li>如果 $f(x)|g(x),g(x)|h(x)$ ，那么 $f(x)|h(x)$ 。</li><li>如果 $f(x)|g_i(x),i=1,2,\cdots,r$ ，那么 $f(x)|u_1(x)g_1(x)+\cdots+u_r(x)g_r(x)$ ，其中 $u_i(x)$ 是数域 $P$ 上的任意多项式。</li></ol><p>通常称 $u_1(x)g_1(x)+\cdots+u_r(x)g_r(x)$ 为多项式 $g_1(x)+\cdots+g_r(x)$ 的一个组合。</p><h3 id="最大公因式"><a href="#最大公因式" class="headerlink" title="最大公因式"></a>最大公因式</h3><p>最大公因式：设 $f(x),g(x)$ 是 $P[x]$ 中两个多项式。 $P[x]$ 中多项式 $d(x)$ 称为 $f(x),g(x)$ 的一个最大公因式，如果它满足下面两个条件：</p><ol><li> $d(x)$ 是 $f(x)$ 的公因式。</li><li> $f(x),g(x)$ 的公因式全是 $d(x)$ 的因式</li></ol><p>引理：如果有等式<br>$$<br>f(x)=q(x)g(x)+r(x)<br>$$<br>成立，那么 $f(x),g(x)$ 和 $g(x),r(x)$ 有相同的公因式。</p><p>定理：对于 $P[x]$ 中任意两个多项式 $f(x),g(x)$ ，在 $P[x]$ 中存在一个最大公因式 $d(x)$ ，且 $d(x)$ 可以表成 $f(x),g(x)$ 的一个组合，即有 $P[x]$ 中多项式 $u(x),v(x)$ 使<br>$$<br>d(x)=u(x)f(x)+v(x)g(x)<br>$$<br>互素： $P[x]$ 中两个多项式 $f(x),g(x)$  称为互素的，如果 $(f(x),g(x))=1$ 。</p><p>定理： $P[x]$ 中两个多项式 $f(x),g(x)$ 互素的充分必要条件是有 $P[x]$ 中的多项式 $u(x),v(x)$ 使<br>$$<br>u(x)f(x)+v(x)g(x)=1<br>$$<br>定理：如果 $(f(x),g(x))=1$ ，且 $f(x)|g(x)h(x)$ ，那么 $f(x)|h(x)$ 。</p><p>推论：如果 $f_1(x)|g(x),f_2(x)|g(x)$ ，且 $(f_1(x),f_2(x))=1$ ，那么 $f_1(x)f_2(x)|g(x)$ 。</p><h3 id="因式分解定理"><a href="#因式分解定理" class="headerlink" title="因式分解定理"></a>因式分解定理</h3><p>不可约多项式：数域 $P$ 上次数 $\geq 1$ 的多项式 $p(x)$ 称为域 $P$ 上的不可约多项式，如果它不能表成数域 $P$ 上的两个次数比 $p(x)$ 的次数低的多项式的乘积。</p><p>定理：如果 $p(x)$ 是一个不可约多项式，那么对于任意的两个多项式 $f(x),g(x)$ ，由 $p(x)|f(x)g(x)$ 一定推出 $p(x)|f(x)$ 或者 $p(x)|g(x)$ 。</p><p>因式分解及唯一性定理：数域 $P$ 上每一个次数 $\geq 1$ 的多项式 $f(x)$ 都可以唯一的分解成数域 $P$ 上一些不可约多项式的乘积，所谓唯一性是说，如果有两个分解式<br>$$<br>f(x)=p_1(x)p_2(x)\cdots p_s(x)=q_1(x)q_2(x)\cdots q_t(x)<br>$$<br>那么必有 $s=t$ ，并且适当排列后次序有<br>$$<br>p_i(x)=c_iq_i(x),i=1,2,\cdots,s<br>$$<br>其中 $c_i(i=1,2,\cdots,s)$ 是一些非零常数。</p><p>在多项式 $f(x)$ 的分解式中，可以把每一个不可约因式的首项系数提出来，使他们成为首项系数为1的多项式，再把相同的不可约因式合并，于是 $f(x)$ 的分解式成为<br>$$<br>f(x)=cp_1^{r_1}(x)p_2^{r_2}(x)\cdots p_s^{r_s}(x)<br>$$<br>其中 $c$ 是 $f(x)$ 的首项系数， $p_1(x),p_2(x),\cdots, p_s(x)$ 是不同的首项系数为1的不可约多项式，而 $r_1,r_2,\cdots,r_s$ 是正整数，这种分解式称为标准分解式。</p><h3 id="重因式"><a href="#重因式" class="headerlink" title="重因式"></a>重因式</h3><p>重因式：不可约多项式 $p(x)$ 称为多项式 $f(x)$ 的 $k$ 重因式，如果 $p^k(x)|f(x)$ ，而 $p^{k+1}(x)\not |f(x)$ 。</p><p>如果 $k=0$ ，那么 $p(x)$ 根本不是 $f(x)$ 的因式，如果 $k=1$ ，那么 $p(x)$ 称为 $f(x)$ 的单因式，如果 $k&gt;1$ ，那么 $p(x)$ 称为 $f(x)$ 的重因式。</p><p>定理：如果不可约多项式 $p(x)$ 是 $f(x)$ 的 $k$ 重因式 $k\geq 1$ ，那么它是微商 $f^{\prime}(x)$ 的 $k-1$ 重因式。</p><p>推论：如果不可约多项式 $p(x)$ 是 $f(x)$ 的 $k$ 重因式 $k\geq 1$ ，那么 $p(x)$ 是 $f(x),f^{\prime}(x),\cdots,f^{(k-1)}(x)$ 的因式，但不是 $f^{(k)}(x)$ 的因式。</p><p>推论：不可约多项式 $p(x)$ 是 $f(x)$ 的重因式的充分必要条件为 $p(x)$ 是 $f(x)$ 与 $f^{\prime}(x)$ 的公因式。</p><p>推论：多项式 $f(x)$ 没有重因式的充分必要条件是 $f(x)$ 与 $f^{\prime}(x)$ 互素。</p><h3 id="多项式函数"><a href="#多项式函数" class="headerlink" title="多项式函数"></a>多项式函数</h3><p>设<br>$$<br>f(x)=a_nx^n+\cdots+a_1x+a_0<br>$$<br>是 $P[x]$ 中的多项式， $\alpha$ 是 $P$ 中的数，代入有<br>$$<br>a_n\alpha^n+\cdots+a_1\alpha+a_0<br>$$<br>称为 $f(x)$ 当 $x=\alpha$ 时的值，记为 $f(\alpha)$ 。称这个函数为数域 $P$ 上的多项式函数。</p><p>余数定理：用一次多项式 $x-\alpha$ 去除多项式 $f(x)$ ，所得的余式是一个常数，这个常数等于函数值 $f(\alpha)$ 。</p><p>如果 $f(x)$ 在 $x=\alpha$ 时函数值 $f(\alpha)=0$ ，那么 $\alpha$ 就称为 $f(x)$ 的一个根或零点。</p><p>推论： $\alpha$ 是 $f(x)$ 的根的充分必要条件是 $(x-\alpha)|f(x)$ 。<br>由这个关系，我们可以定义重根的概念， $\alpha$ 称为 $f(x)$ 的 $k$ 重根，如果 $x-\alpha$ 是 $f(x)$ 的 $k$ 重因式。当 $k=1$ 时， $\alpha$ 称为单根，当 $k&gt;1$ 时， $\alpha$ 称为重根。</p><p>定理： $P[x]$ 中 $n$ 次多项式 $n\geq 0$ 在数域 $P$ 中的根不可能多于 $n$ 个，重根按重数计算。</p><p>定理：如果多项式 $f(x),g(x)$ 的次数都不超过 $n$ ，而它们对 $n+1$ 个不同的数 $\alpha_1,\cdots ,\alpha_{n+1}$ 有相同的值，即<br>$$<br>f(\alpha_i)=g(\alpha_i),i=1,1,\cdots,n+1,<br>$$<br>那么 $f(x)=g(x)$ 。</p><h3 id="复系数与实系数多项式的因式分解"><a href="#复系数与实系数多项式的因式分解" class="headerlink" title="复系数与实系数多项式的因式分解"></a>复系数与实系数多项式的因式分解</h3><p>代数基本定理：每个次数 $\geq 1$ 的复系数多项式在复数域中有一根。</p><p>复系数多项式因式分解定理：每个次数 $\geq 1$ 的复系数多项式在复数域上都可以唯一地分解成一次因式的乘积。<br>因此，复系数多项式具有标准分解式<br>$$<br>f(x)=a_n(x-\alpha_1)^{l_1}\cdots (x-\alpha_s)^{l_s}<br>$$<br>其中 $\alpha_1,\cdots,\alpha_s$ 是不同的复数， $l_1,\cdots l_s$ 是正整数。这说明每个 $n$ 次复系数多项式恰有 $n$ 个复根（重根按重数计算）。</p><p>对于实系数多项式，以下的事实是基本的，即，如果 $\alpha$ 是实系数多项式 $f(x)$ 的复根，那么 $\alpha$ 的共轭数 $\overline{\alpha}$ 也是 $f(x)$ 的根。因为设<br>$$<br>f(x)=a_nx^n+\cdots+a_0<br>$$<br>其中 $a_0,\cdots,a_n$ 是实数。由假设<br>$$<br>f(\alpha)=a_n\alpha^n+\cdots+a_0=0<br>$$<br>两边取共轭数，有<br>$$<br>0=\overline{f(\alpha)}=a_n\overline{\alpha}^n+\cdots +a_0=f(\overline{\alpha})<br>$$<br>这就是说 $f(\overline{\alpha})=0$ ， $\overline{\alpha}$ 也是 $f(x)$ 的根。</p><p>实系数多项式因式分解定理：每个次数 $\geq 1$ 的实系数多项式在实数域上都可以唯一地分解成一次因式与二次不可约因式的乘积。</p><h3 id="有理系数多项式"><a href="#有理系数多项式" class="headerlink" title="有理系数多项式"></a>有理系数多项式</h3><p>本原多项式：如果一个非零的整系数多项式 $g(x)=b_nx^n+\cdots+b_0$ 的系数 $b_n,\cdots,b_0$ 没有异于 $\pm 1$ 的公因子，也就是说，它们是互素的，它就称为一个本原多项式。</p><p>高斯引理：两个本原多项式的乘积还是本原多项式。</p><p>定理：如果一非零的整系数多项式能够分解成两个次数较低的有理系数多项式的乘积，那么它一定能分解成两个次数较低的整系数多项式的乘积。</p><p>推论：设 $f(x),g(x)$ 是整系数多项式，且 $g(x)$ 是本原的，如果 $f(x)=g(x)h(x)$ ，其中 $h(x)$ 是有理系数多项式，那么 $h(x)$ 一定是整系数的。</p><p>定理：设 $f(x)=a_nx^n+\cdots +a_0$ 是一个整系数多项式，而 $\frac{r}{s}$ 是它的一个有理根，其中 $r,s$ 互素，那么必有 $s|a_n,r|a_0$ 。特别的，如果 $f(x)$ 的首项系数 $a_n=1$ ，那么 $f(x)$ 的有理根都是整根，而且是 $a_0$ 的因子。</p><p>艾森斯坦判别法：设 $f(x)=a_nx^n+\cdots +a_0$ 是一个整系数多项式。如果有一个素数 $p$ ，使得</p><p>$$<br>\begin{equation*}<br>p\not |a_n;\quad<br>p|a_{n-1},a_{n-2},\cdots ,a_0; \quad<br>p^2\not |a_0<br>\end{equation*}<br>$$</p><p>那么 $f(x)$ 在有理数域上是不可约的。</p><h3 id="多元多项式"><a href="#多元多项式" class="headerlink" title="多元多项式"></a>多元多项式</h3><h3 id="对称多项式"><a href="#对称多项式" class="headerlink" title="对称多项式"></a>对称多项式</h3><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>求解线性方程组：<br>对于二元线性方程组<br>$$<br>\begin{cases} a_{11}x_1+a_{12}x_2=b_1 \\ a_{21}x_1+a_{22}x_2=b_2\end{cases}<br>$$</p><p>当 $a_{11}a_{22}-a_{12}a_{21}\neq 0$ 时，此方程有唯一解，即<br>$$<br>x_1=\dfrac{b_1a_{22}-a_{12}b_2}{a_{11}a_{22}-a_{12}a_{21}} ,<br>x_2=\dfrac{a_{11}b_2-a_{21}b_1}{a_{11}a_{22}-a_{12}a_{21}}<br>$$<br>我们称 $a_{11}a_{22}-a_{12}a_{21}$ 为二阶行列式，用符号表示为<br>$$<br>a_{11}a_{22}-a_{12}a_{21}=\begin{vmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{vmatrix}<br>$$<br>于是，当 $\begin{vmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{vmatrix}\neq 0$ 时，该方程有唯一解，解为<br>$$<br>x_1=\dfrac{\begin{vmatrix}b_1&amp;a_{12}\\b_2&amp;a_{22}\end{vmatrix}}{\begin{vmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{vmatrix}} ,<br>x_2=\dfrac{\begin{vmatrix}a_{11}&amp;b_1\\a_{21}&amp;b_2\end{vmatrix}}{\begin{vmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{vmatrix}}<br>$$<br>同理，可以定义三阶行列式。</p><h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><p>排列：由 $1,2,3,\cdots,n$ 组成的一个有序数组称为一个 $n$ 级排列。</p><p>逆序数：在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么他们就称为一个逆序，一个排列中逆序的总数就称为这个排列的逆序数。排列 $j_1j_1\cdots j_n$ 的逆序数记为 $\tau(j_1j_1\cdots j_n)$ 。</p><p>偶排列与奇排列：逆序数为偶数的排列称为偶排列，逆序数为奇数的排列称为奇排列。</p><p>对换：把一个排列中某两个数的位置互换，其余数不动，这样一个变换称为对换。</p><p>定理：对换改变排列的奇偶性。</p><p>推论：在全部的 $n$ 级排列中，奇偶排列的个数相等，各有 $\frac{n!}{2}$ 个。</p><p>定理：任意一个 $n$ 级排列与排列 $12\cdots n$ 都可以经过一系列对换互变，并且所做对换的个数与这个排列有相同的奇偶性。</p><h3 id="n-阶行列式的定义"><a href="#n-阶行列式的定义" class="headerlink" title="$n$ 阶行列式的定义"></a>$n$ 阶行列式的定义</h3><p> $n$ 阶行列式：由 $n^2$ 个数 $a_{ij}$ （称为行列式的元）排成一个 $n$ 行 $n$ 列的表，并在两边各画一条竖线的记号<br>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\ a_{21}&amp;a_{22}&amp;\cdots &amp;a_{2n} \\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots \\ a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$<br>称为 $n$ 阶行列式。</p><p> $n$ 阶行列式表示的代数和的所有项，即<br>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;a_{13} \\ a_{21}&amp;a_{22}&amp;a_{23} \\ a_{31}&amp;a_{32}&amp;a_{33}\end{vmatrix}<br>$$<br>其中 $\sum_{j_1,j_2}$ 表示对 $$ 的一切排列取和。用符号 $$ 或 $$ 表示以 $$ 为元的 $n$ 阶行列式。</p><p>上三角行列式：当 $i&gt;j$ 时， $a_{ij}=0$ 。<br>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\ 0&amp;a_{22}&amp;\cdots &amp;a_{2n} \\ \vdots &amp;\vdots &amp;\ddots&amp;\vdots  \\  0&amp;0&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$<br>上三角行列式的值等于其主对角线上各元之积。</p><h3 id="n-阶行列式的性质"><a href="#n-阶行列式的性质" class="headerlink" title="$n$ 阶行列式的性质"></a>$n$ 阶行列式的性质</h3><p>性质1：行列式的行和列顺次互换，其值不变，即</p><p>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\ a_{21}&amp;a_{22}&amp;\cdots &amp;a_{2n} \\ \vdots &amp;\vdots &amp;\ddots&amp;\vdots  \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}=\begin{vmatrix}a_{11}&amp;a_{21}&amp;\cdots &amp;a_{n1} \\ a_{12}&amp;a_{22}&amp;\cdots &amp;a_{n2} \\ \vdots &amp;\vdots &amp;\ddots&amp;\vdots  \\  a_{1n}&amp;a_{2n}&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$</p><p>上述两个行列式互称转置行列式。</p><p>说明行列式中行与列的地位是对称的，平等的，因此行列式对行成立的性质，对列也同样成立。</p><p>性质2：互换行列式的两行（或两列），行列式变号。</p><p>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{t1}&amp;a_{t2}&amp;\cdots &amp;a_{tn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ a_{s1}&amp;a_{s2}&amp;\cdots &amp;a_{sn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}=-\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{s1}&amp;a_{s2}&amp;\cdots &amp;a_{sn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ a_{t1}&amp;a_{t2}&amp;\cdots &amp;a_{tn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$<br>推论：行列式中两行（列）完全相同，则行列式为0。</p><p>性质3：行列式中某行（列）的元有因子 $K$ ，则 $K$ 可提到行列式符号外边。<br>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ Ka_{t1}&amp;Ka_{t2}&amp;\cdots &amp;Ka_{tn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}=K\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{t1}&amp;a_{t2}&amp;\cdots &amp;a_{tn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$<br>若用 $K$ 乘某行列式的某行（列），则等于用 $K$ 乘该行列式。</p><p>性质4：若行列式中某行（列）的元均可表示为两项之和，例如第 $i$ 行<br>$$<br>a_{ij}=b_{ij}+c_{ij},(j=1,2,\cdots ,n)<br>$$<br>则此行列式等于两个行列式之和，这两个行列式除第 $i$ 行的元分别为 $b_{ij}$ 与 $c_{ij}$ 外，其余各行都与原行列式一样，即<br>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ b_{i1}+c_{i1}&amp;b_{i2}+c_{i2}&amp;\cdots &amp;b_{in}+c_{in} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}=\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ b_{i1}&amp;b_{i2}&amp;\cdots &amp;b_{in} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}+\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ c_{i1}&amp;c_{i2}&amp;\cdots &amp;c_{in} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$</p><p>性质5：</p><ol><li>行列式某行（列）的元全为零。</li><li>行列式的两行（列）完全相同。</li><li>行列式的两行（列）的元成比例。<br>若上述条件之一成立，该行列式的值为零。</li></ol><p>性质6：若把行列式的某行（列） $\lambda$ 倍后加到另一行（列）上，则行列式的值不变。</p><p>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{i1}+\lambda a_{j1}&amp;a_{i2}+\lambda a_{j2}&amp;\cdots &amp;a_{in}+\lambda a_{jn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ a_{j1}&amp;a_{j2}&amp;\cdots &amp;a_{jn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}=\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{i1}&amp;a_{i2}&amp;\cdots &amp;a_{in} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ a_{j1}&amp;a_{j2}&amp;\cdots &amp;a_{jn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$</p><h3 id="行列式按行（列）展开"><a href="#行列式按行（列）展开" class="headerlink" title="行列式按行（列）展开"></a>行列式按行（列）展开</h3><p>代数余子式： $M_{ij}$ 是把行列式 $|A|$ 中元 $a_{ij}$ 所在的第 $i$ 行，第 $j$ 列划掉后所得到的 $n-1$ 阶行列式， $M_{ij}$ 称为元 $a_{ij}$ 在 $|A|$ 中的余子式，记 $A_{ij}=(-1)^{i+j}M_{ij}$ ， $A_{ij}$ 称为元 $a_{ij}$ 在 $|A|$ 中的代数余子式。<br>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\ a_{21}&amp;a_{22}&amp;\cdots &amp;a_{2n} \\ \vdots &amp;\vdots &amp;\ddots&amp;\vdots \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$<br>定理： $n$ 阶 $n\geq 2$ 行列式等于它的任一行的各元与其代数余子式乘积之和，即<br>$$<br>|A|=\sum_{k=1}^na_{ik}A_{ik}(i=1,2,\cdots ,n)<br>$$<br>定理： $n$ 阶行列式等于它的任何一列的各元与其代数余子式乘积之和，即<br>$$<br>|A|=\sum_{k=1}^na_{kj}A_{kj}(j=1,2,\cdots ,n)<br>$$<br>定理： $n$ 阶行列式的任一行的各元与另一行对应元代数余子式乘积之和为零，即<br>$$<br>\sum_{k=1}^{n}a_{jk}A_{ik}=0(i\neq j)<br>$$<br>定理： $n$ 阶行列式的任一列的各元与另一列对应元代数余子式乘积之和为零，即<br>$$<br>\sum_{k=1}^{n}a_{kj}A_{ki}=0(i\neq j)<br>$$<br>于是有</p><p>$$<br>\sum_{k=1}^na_{jk}A_{ik}=\begin{cases} |A|,j = i \\ 0,j\neq i \end{cases},(i,j=1,2,\cdots ,n)<br>$$</p><p>范德蒙德行列式：</p><p>$$<br>V(x_1,x_2,\cdots,x_n)=\begin{vmatrix}1&amp;1&amp;1&amp;1 \\ x_{1}&amp;x_{2}&amp;\cdots &amp;x_{n}\\x_{1}^{2}&amp;x_{2}^{2}&amp;\cdots &amp;x_{n}^{2}\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\x_{1}^{n-1}&amp;x_{2}^{n-1}&amp;\cdots &amp;x_{n}^{n-1}\end{vmatrix}=\prod_{1\leq j &lt; i\leq n}(x_i-x_j)<br>$$</p><p>互为余子式：在 $n$ 阶行列式在，任意指定 $r$ 个行与 $r$ 个列 $(1\leq r&lt;n)$ ，位于这些行列交点处的 $r^2$ 个元构成的 $r$ 阶行列式 $M$ 称为原行列式的一个 $r$ 阶子式。在 $n$ 阶行列式中，划去某个 $r$ 阶子式 $M$ 所在的行和列后，剩下的 $n-r$ 个行和 $n-r$ 个列上的元也构成一个 $n-r$ 阶子式 $N$ ，我们称这一对子式 $M$ 与 $N$ 互为余子式。</p><p>拉普拉斯定理：在 $n$ 阶行列式中任意选定 $k$ 个行（列） $1\leq k&lt;n$ ，则 $n$ 阶行列式等于位于这 $k$ 个行（列）中的一切 $k$ 阶子式 $M_i(i=1,2,\cdots,C_{n}^{k})$ 与其对应的代数余子式 $A_i$ 乘积之和，即<br>$$<br>|A|=\sum_{i=1}^{C_n^k}M_iA_i<br>$$</p><h2 id="矩阵代数"><a href="#矩阵代数" class="headerlink" title="矩阵代数"></a>矩阵代数</h2><h3 id="矩阵的概念"><a href="#矩阵的概念" class="headerlink" title="矩阵的概念"></a>矩阵的概念</h3><p>矩阵：由 $m\times n$ 个数 $$a_{ij}(i=1,\cdots,m;j=1,\cdots,n)$$ 排成的 $m$ 行 $n$ 列的数表<br>$$<br>\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\ a_{21}&amp;a_{22}&amp;\cdots &amp;a_{2n} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{m1}&amp;a_{m2}&amp;\cdots &amp;a_{mn}\end{pmatrix}<br>$$<br>称为 $m$ 行 $n$ 列矩阵（或 $m\times n$ 矩阵）。数 $a_{ij}$ 称为矩阵的元。</p><p>常用大写字母 $A,B,\cdots$ 表示矩阵，矩阵也可以表示为 $A=(a_{ij})$ ， $A_{m\times n}$ ， $(a_{ij})_{m\times n}$ 等。</p><p>特别的，当矩阵的行数和列数相等的时候称为方阵。 $n$ 行 $n$ 列的矩阵也被称为 $n$ 阶方阵。</p><p>实矩阵与复矩阵：如果矩阵 $A$ 的每个元 $a_{ij}$ 都是实数，矩阵 $A$ 称为实矩阵；如果 $A$ 的元是复数， $A$ 称为复矩阵。</p><p>同型矩阵：如果矩阵 $A$ 和 $B$ 有相同的行数与相同的列数，则 $A$ 与 $B$ 称为同型矩阵。</p><p>系数矩阵：考虑线性方程组<br>$$<br>\begin{cases} a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1, \\ a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2,\\ \cdots \\ a_{m1}x_1+a_{m2}x_2+\cdots+a_{mn}x_n=b_m \end{cases}<br>$$<br>由未知量的系数 $a_{ij}$ 所构成的 $m\times n$ 矩阵<br>$$<br>A=\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\ a_{21}&amp;a_{22}&amp;\cdots &amp;a_{2n} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{m1}&amp;a_{m2}&amp;\cdots &amp;a_{mn}\end{pmatrix}<br>$$<br>称为方程组的系数矩阵。</p><p>常数列矩阵：由方程组右端常数项 $b_i$ 构成的 $m\times 1$ 矩阵<br>$$<br>b=\begin{pmatrix}b_1 \\ b_2 \\ \vdots \\ b_m \end{pmatrix}<br>$$<br>称为方程组的常数列矩阵。</p><p>增广矩阵：由系数 $a_{ij}$ 和常数项 $b_i$ 组成的矩阵<br>$$<br>B=\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n}&amp;b_1 \\ a_{21}&amp;a_{22}&amp;\cdots &amp;a_{2n}&amp;b_2 \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots &amp;\vdots  \\ a_{m1}&amp;a_{m2}&amp;\cdots &amp;a_{mn}&amp;b_m\end{pmatrix}=(A,b)<br>$$<br>称为方程组的增广矩阵。</p><p>行向量与列向量：常把 $1\times n$ 矩阵称为 $n$ 维行向量， $n\times 1$ 矩阵称为 $n$ 维列向量。矩阵也可以写成行向量按列排列和列向量按行排列的形式。</p><h3 id="矩阵的代数运算"><a href="#矩阵的代数运算" class="headerlink" title="矩阵的代数运算"></a>矩阵的代数运算</h3><h4 id="矩阵的加法和数乘"><a href="#矩阵的加法和数乘" class="headerlink" title="矩阵的加法和数乘"></a>矩阵的加法和数乘</h4><p>相等：如果同型矩阵 $A=(a_{ij}),B=(b_{ij})$ 的对应元都相等，即 $a_{ij}=b_{ij}$ ，则称 $A$ 与 $B$ 相等，记为 $A=B$ 。</p><p>和：两个同型矩阵 $A={(a_{ij})}_{m\times n}$ 和 $B=(b_{ij})_{m\times n}$ 的对应元相加所得的同型矩阵 $C=(a_{ij}+b_{ij})_{m\times n}$ 称为矩阵 $A$ 与 $B$ 之和，记为 $C=A+B$ 。</p><p>零矩阵：每个元都等于零的 $m\times n$ 矩阵称为零矩阵，记为 $0_{m\times n}$ 或者 $0$ 。显然对一切 $A=A_{m\times n}$ 恒有 $0_{m\times n}+A_{m\times n}=A_{m\times n}$ 或 $0+A=A$ 。</p><p>负矩阵：若与 $A$ 同型的矩阵 $B$ 的每个元是矩阵 $A$ 的对应元的相反数，则称矩阵 $B$ 为 $A$ 的负矩阵。 $A$ 的负矩阵记为 $-A$ ，显然 $A+(-A)=0$ 。</p><p>差：若矩阵 $A,B$ 是同型矩阵，则称矩阵 $A+(-B)$ 为 $A$ 与 $B$ 的差，并记为 $A-B$ ，即 $A-B=A+(-B)$ 。</p><p>显然， $A=B$ 的充要条件是 $A-B=0$ 。</p><p>数乘：若 $\lambda$ 是一个数， $A=(a_{ij})_{m\times n}$ 是矩阵，则同型矩阵 $(\lambda a_{ij})_{m\times n}$ 称为数 $\lambda$ 与矩阵 $A$ 的乘积，记为 $\lambda A$ 或 $A\lambda$ ，即 $\lambda A=(\lambda a_{ij})_{m\times n}$ 。</p><p>矩阵的加（减）法和数与矩阵的数乘统称为矩阵的线性运算。</p><p>性质：</p><ol><li>加法交换律 $A+B=B+A$ </li><li>加法结合律 $(A+B)+C=A+(B+C)$ </li><li>数乘的分配律 $$\lambda (A+B)=\lambda A+\lambda B$$ $$(\lambda+\mu)A=\lambda A+\mu A$$</li><li>数乘的结合律 $\lambda(\mu A)=(\lambda \mu)A$ </li><li>$1A=A$<br>其中 $A,B,C$ 是使上述矩阵线性运算有意义的矩阵， $\lambda,\mu $ 为数。</li></ol><p>线性组合：设给定了若干个同型矩阵 $A_1,\cdots,A_m$ ，经过线性运算<br>$$<br>\lambda_1A_1+\lambda_2A_2+\cdots+\lambda_mA_m=\sum_{j=1}^{m}\lambda_jA_j=B<br>$$<br>（其中 $\lambda_j$ 是常数， $j=1,2,\cdots,m$ ）得到的矩阵 $B$ 称为矩阵 $A_1,\cdots,A_m$ 的线性组合。或者称 $B$ 可经 $A_1,\cdots,A_m$ 线性表出。</p><h4 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h4><p>矩阵与列向量的乘积：设 $A=(a_{ij})_{m\times n},C=(c_j)_{n\times 1}$ ，则规定 $m\times n$ 矩阵 $A$ 与 $n$ 维列向量 $C$ 相乘的乘积 $AC$ 是以 $d_i=\sum_{j=1}^n{a_{ij}c_j}$ $(i=1,\cdots ,n)$ 为分量的 $m$ 维列向量，即</p><p>$$<br>AC=\begin{pmatrix}a_{11}c_1+a_{12}c_2+\cdots +a_{1n}c_n\\a_{21}c_1+a_{22}c_2+\cdots +a_{2n}c_n\\ \vdots\\a_{m1}c_1+a_{m2}c_2+\cdots +a_{mn}c_n\end{pmatrix}<br>$$</p><p>矩阵与矩阵的乘积：设 $A=(a_{ij})_{m\times n}$ ， $B=(b_{ij})_{n\times s}$ ， $A$ 与 $B$ 相乘的乘积 $AB$ 定义如下</p><p>$$<br>AB=\begin{pmatrix}\sum_{k=1}^na_{1k}b_{k1}&amp;\sum_{k=1}^na_{1k}b_{k2}&amp;\cdots &amp;\sum_{k=1}^na_{1k}b_{ks} \\ \sum_{k=1}^na_{2k}b_{k1}&amp;\sum_{k=1}^na_{2k}b_{k2}&amp;\cdots &amp;\sum_{k=1}^na_{2k}b_{ks} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ \sum_{k=1}^na_{mk}b_{k1}&amp;\sum_{k=1}^na_{mk}b_{k2}&amp;\cdots &amp;\sum_{k=1}^na_{mk}b_{ks}\end{pmatrix}=D<br>$$</p><p>即， $A$ 与 $B$ 相乘所得的矩阵 $D$ 是 $m\times s$ 矩阵。它的元 $d_{ij}=\sum_{k=1}^na_{ik}b_{kj}$ $(i=1,2,\cdots,m)$,$j=1,2,\cdots,s$ 由 $A$ 的第 $i$ 个行向量与 $B$ 的第 $j$ 个列向量的对应分量乘积之和。</p><p>矩阵乘法不符合交换律。</p><p>若 $AB$ 有意义，称 $A$ 右乘 $B$ ，或者 $B$ 左乘 $A$ 。</p><p>矩阵乘法不满足消去律，当 $A$ 和 $B$ 都是非零矩阵时，可能有 $AB=0$ 。</p><p>矩阵乘法的性质：</p><ol><li>结合律 $$(AB)C=A(BC)$$ </li><li>分配律 $$A(B+C)=AB+AC$$ $$(A+B)C=AC+BC$$ </li><li>$\lambda (AB)=(\lambda A)B=A(\lambda B)$<br>其中 $A,B,C$ 是使上述矩阵乘法有意义的矩阵， $\lambda$ 是数。</li></ol><p>单位矩阵： $n$ 阶方阵<br>$$<br>E_n=\begin{pmatrix}1&amp;0&amp;\cdots &amp;0 \\ 0&amp;1&amp;\cdots &amp;0 \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ 0&amp;0&amp;\cdots &amp;1\end{pmatrix}=\begin{pmatrix}1&amp;&amp;&amp; \\ &amp;1&amp;&amp; \\  &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;1\end{pmatrix}<br>$$<br>称为 $n$ 阶单位矩阵，也记为 $E$ 。容易验证对任意的 $n$ 阶矩阵 $A$ 有<br>$$AE=EA=A$$<br>设 $A$ 是 $n$ 阶矩阵，则乘积 ${A\cdots A}(\text{有限个})$ 有意义。 $k$ 个 $A$ 相乘称为 $A$ 的 $k$ 次幂，记为</p><p>$$<br>A^k=AA\cdots A(k\text{个})<br>$$</p><p>并约定 $A^0=E$ 。<br>不难验证</p><p>$$<br>A^kA^l=A^{k+l},(A^k)^l=A^{kl},(k,l\in \mathbb{Z^+})<br>$$<br>成立。由于矩阵乘法不满足交换律，一般的 $(AB)^k\neq A^kB^k$ （ $A,B$ 皆为方阵， $k\geq 2$ ）。</p><p>当 $A$ 为方阵时，称矩阵<br>$$<br>f(A)=a_0A^m+a_1A^{m-1}+\cdots+a_{m-1}A+a_mE<br>$$<br>为矩阵 $A$ 的多项式，也称 $f(A)$ 是普通多项式<br>$$<br>f(\lambda)=a_0\lambda^m+a_1\lambda^{m-1}+\cdots+a_{m-1}\lambda+a_m<br>$$<br>当 $\lambda =A$ 的值，设 $\varphi(\lambda),\psi(\lambda)$ 是两个多项式，令<br>$$<br>f(\lambda)=\varphi(\lambda)+\psi(\lambda),g(\lambda)=\varphi(\lambda)\psi(\lambda)<br>$$<br>由矩阵的运算法则有<br>$$<br>f(A)=\varphi(A)+\psi(A),g(A)=\varphi(A)\psi(A)<br>$$<br>特别是由 $\varphi(\lambda)\psi(\lambda)=\psi(\lambda)\varphi(\lambda)$ 推出 $\varphi(A)\psi(A)=\psi(A)\varphi(A)$ 。</p><p>定理：若 $A$ 与 $B$ 为 $n$ 阶矩阵，则 $|AB|=|A||B|$ 。</p><p>由该定理可知 $|AB|=|BA|$ 。</p><h3 id="逆矩阵与矩阵的初等变换"><a href="#逆矩阵与矩阵的初等变换" class="headerlink" title="逆矩阵与矩阵的初等变换"></a>逆矩阵与矩阵的初等变换</h3><h4 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h4><p>逆矩阵：设 $A$ 是一个 $n$ 阶矩阵。若存在 $n$ 阶矩阵 $B$ 使得<br>$$<br>AB=BA=E<br>$$<br>成立，则称 $A$ 是可逆矩阵， $B$ 是 $A$ 的逆矩阵。</p><p>定理：若 $A$ 是可逆矩阵，则它的逆矩阵是唯一的。</p><p>定理：矩阵 $A=(a_{ij})_{n\times n}$ 可逆的充分必要条件是 $|A|\neq 0$ 。</p><p>伴随矩阵：用 $A$ 中各元 $a_{ij}$ 的代数余子式为元构成矩阵<br>$$<br>A^{\star}=\begin{pmatrix}A_{11}&amp;A_{21}&amp;\cdots &amp;A_{n1} \\ A_{12}&amp;A_{22}&amp;\cdots &amp;A_{n2} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ A_{1n}&amp;A_{2n}&amp;\cdots &amp;A_{nn} \end{pmatrix}<br>$$</p><p>$A^{\star}$ 称为 $n$ 阶矩阵 $A$ 的伴随矩阵。</p><p>有 $A^{-1}=\frac{1}{|A|}A^{\star}$ 。<br> $n$ 阶矩阵 $A$ 可逆的充要条件是 $|A|\neq 0$ ，且当 $A$ 可逆时 $A$ 的逆矩阵<br>$$<br>A^{-1}=\frac{1}{|A|}A^{\star}=|A|^{-1}A^{\star}<br>$$<br>可逆矩阵又称非奇异矩阵，非退化矩阵或满秩矩阵。</p><p>推论：设 $A,B$ 为 $n$ 阶矩阵，若 $AB=E$ （或 $BA=E$ ）成立，则 $B=A^{-1}$ 。</p><p>定理：若 $A$ 与 $B$ 为 $n$ 阶可逆矩阵在，则 $AB$ 也为 $n$ 阶可逆矩阵，而且 $(AB)^{-1}=B^{-1}A^{-1}$ 。</p><p>推论：若 $A_1,A_2,\cdots ,A_m$ 皆为 $n$ 阶可逆矩阵，则乘积 $A_1A_2\cdots A_m$ 也是一个 $n$ 阶可逆矩阵且</p><p>定理：设 $A$ 是 $n$ 阶可逆矩阵，那么对任意的 $B=B_{n\times m}$ （或 $B=B_{m\times n}$ ），矩阵方程<br>$$<br>AX=B(\text{或}XA=B)<br>$$<br>有唯一解 $X$ 。</p><p>克拉默法则： $n$ 元线性方程组<br>$$<br>\begin{cases} a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1, \\ a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2,\\ \cdots \\ a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n=b_n \end{cases}<br>$$<br>当其系数矩阵 $A$ 的行列式 $D=|A|=\mathrm{det}(a_{ij})\neq 0$ 时，存在唯一解<br>$$<br>x_j=\dfrac{D_j}{D}(j=1,2,\cdots,n)<br>$$<br>其中 $D_j$ 表示把系数矩阵 $A$ 的第 $j$ 列换成常数项列后的矩阵的行列式。</p><h4 id="矩阵的初等变换"><a href="#矩阵的初等变换" class="headerlink" title="矩阵的初等变换"></a>矩阵的初等变换</h4><p>初等变换：对矩阵的行（列）施行下列三种变换都称为矩阵的初等行（列）变换，这三种变换是</p><ol><li>互换矩阵两行（列）的位置</li><li>用非零常数 $\lambda $ 乘矩阵的某行（列）</li><li>将矩阵某行（列）的 $\gamma$ 倍加到矩阵的另一行（列）上。</li></ol><p>矩阵的初等行变换和初等列变换统称为矩阵的初等变换。</p><p>初等矩阵：对 $n$ 阶单位矩阵 $E$ 分别施行一次上述三种初等变换之一后所得的矩阵称为初等矩阵。</p><ol><li>互换 $E$ 的 $i,j$ 两行（两列）所得的初等矩阵 $E_{ij}$</li><li>用 $\lambda(\lambda\neq 0)$ 乘 $E$ 的第 $i$ 行（列）所得的初等矩阵 $E_{ii}(\lambda)$</li><li>将 $E$ 的 $j$ 行（ $i$ 列）的 $\gamma$ 倍加到 $i$ 行（ $j$ 列）上去 $(i\neq j)$ 所得的初等矩阵 $E_{ij}(\gamma)$</li></ol><p>显然，三种初等矩阵都是可逆矩阵。</p><p>引理：对矩阵 $A=(a_{ij})_{m\times n}$ 施行某一初等行（列）变换，其结果等于对 $A$ 左（右）乘一个相应的 $n$ 阶（ $m$ 阶）初等矩阵。</p><p>初等矩阵的逆矩阵分别为<br>$$<br>(E_{ij})^{-1}=E_{ij}<br>$$<br>$$<br>(E_{ii}(\lambda))^{-1}=E_{ii}(\dfrac{1}{\lambda})(\lambda\neq 0)<br>$$<br>$$<br>(E_{ij}(\gamma))^{-1}=E_{ij}(-\gamma)<br>$$</p><p>定理：可逆矩阵必可表示为若干个初等矩阵的乘积。</p><p>初等行变换求矩阵的逆：<br>$$<br>(A,E)\rightarrow (E,A^{-1})<br>$$</p><p>初等列变换求矩阵的逆：<br>$$<br>\begin{pmatrix}A \\ E\end{pmatrix}\rightarrow \begin{pmatrix}E \\ A^{-1} \end{pmatrix}<br>$$</p><h3 id="转置矩阵与一些重要的方阵"><a href="#转置矩阵与一些重要的方阵" class="headerlink" title="转置矩阵与一些重要的方阵"></a>转置矩阵与一些重要的方阵</h3><h4 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h4><p>转置矩阵：设 $A$ 是一个 $m\times n$ 矩阵，若将 $A$ 的行顺次改成列，所得到的 $n\times m$ 矩阵称为 $A$ 的转置矩阵，记作 $A^T$ 。</p><p>转置矩阵满足下面的运算规律：</p><ol><li>$(A^T)^T=A$ 。</li><li>$(A\pm B)^T=A^T\pm B^T$ 。</li><li>$(\lambda A)^T=\lambda A^T(\lambda \text{为数})$ 。</li><li>$(AB)^T=B^TA^T$ 。</li><li>若 $A$ 是可逆矩阵，则 $(A^T)^{-1}=(A^{-1})^T$ 。</li></ol><h4 id="几个重要方阵"><a href="#几个重要方阵" class="headerlink" title="几个重要方阵"></a>几个重要方阵</h4><p>对称矩阵：若实矩阵 $A$ 满足条件 $A^T=A$ ，则 $A$ 称为对称矩阵。<br>一个 $n$ 阶矩阵 $A=(a_{ij})$ 是对称矩阵的充要条件是<br>$$<br>(a_{ij})=(a_{ji})(i,j=1,2,\cdots ,n)<br>$$<br>反称矩阵：若矩阵 $A$ 满足条件 $A^T=-A$ ，则 $A$ 称为反称矩阵。</p><p>一个 $n$ 阶矩阵是反称矩阵的充要条件是它的元满足条件<br>$$<br>a_{ij}=\begin{cases} -a_{ji},i\neq j \\ 0,i=j \end{cases}<br>$$<br>即主对角线上的元全为零，主对角线两侧对称的元反号。</p><p>奇数阶反称矩阵的行列式必为零。</p><p>对角矩阵：形为<br>$$<br>A=\begin{pmatrix}d_1&amp;&amp;&amp; \\ &amp;d_2&amp;&amp; \\ &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;d_{n}\end{pmatrix}<br>$$<br>的 $n$ 阶矩阵（主对角线以外的元全为零）称为对角矩阵。</p><p>对角矩阵有以下性质：</p><ol><li><p>若 $A$ 与 $B$ 均为 $n$ 阶对角矩阵，则 $A+B$ ， $\lambda A$ （ $\lambda$ 为实数）， $AB$ 皆为对角矩阵，且<br>$$<br>AB=\begin{pmatrix}a_1&amp;&amp;&amp; \\ &amp;a_2&amp;&amp; \\ &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;a_{n}\end{pmatrix}\begin{pmatrix}b_1&amp;&amp;&amp; \\ &amp;b_2&amp;&amp; \\ &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;b_{n}\end{pmatrix}=BA<br>$$<br>即两个对角矩阵相乘是可交换的。</p></li><li><p>对角矩阵可逆的充要条件是它的主对角线上的元全不为零，且逆矩阵 $A^{-1}$ 也是对角矩阵。 $A^{-1}$ 的主对角线的元恰为 $A$ 中对应元的倒数，即<br>$$<br>A^{-1}=\begin{pmatrix}a_1&amp;&amp;&amp; \\ &amp;a_2&amp;&amp; \\ &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;a_{n}\end{pmatrix}^{-1}=\begin{pmatrix}a_1^{-1}&amp;&amp;&amp; \\ &amp;a_2^{-1}&amp;&amp; \\ &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;a_{n}^{-1}\end{pmatrix}<br>$$<br>正交矩阵：若 $n$ 阶实矩阵 $A$ 满足 $A^TA=E$ ，则 $A$ 称为正交矩阵。</p></li><li><p> $n$ 阶矩阵 $A$ 为正交矩阵的充分必要条件为 $A^T=A^{-1}$ 。</p></li><li><p> $n$ 阶矩阵 $A$ 是正交矩阵的充分必要条件是下列两组等式</p></li></ol><p>$$<br>\sum_{k=1}^n{a_{ik}a_{jk}}=\begin{cases} 1,i=j \\ 0,i\neq j \end{cases},(i,j=1,2,\cdots,n)<br>$$</p><p>$$<br>\sum_{k=1}^n{a_{ki}a_{kj}}=\begin{cases} 1,i=j \\ 0,i\neq j \end{cases},(i,j=1,2,\cdots,n)<br>$$<br>中至少有一组成立。也就是说，正交矩阵每一行（列）  个元的平方和为1，两个不同行（列）对应元乘积之和等于零。</p><ol><li> $A$ 为正交矩阵，则 $A^T=A^{-1}$ 也是正交矩阵。</li><li> $A$ 为正交矩阵，则 $A$ 的行列式必为+1或-1，即 $|A|=\pm 1$ 。</li><li>若 $A$ 与 $B$ 均为 $n$ 阶正交矩阵，则乘积 $AB(BA)$ 也是正交矩阵。</li></ol><p>共轭矩阵：设 $n$ 阶矩阵 $A=(a_{ij})$ 的元 $a_{ij}$ 都是复数，则矩阵 $\overline{A}=(\overline{a}_{ij})$ 称为 $A$ 的共轭矩阵。</p><p>埃尔米特矩阵：若矩阵 $A$ 满足 $A^T=\overline{A}$ ，则 $A$ 称为埃尔米特矩阵。</p><p>酉矩阵：若 $n$ 阶矩阵 $A$ 满足条件 $A=\overline{A^{-1}}$ ，则 $A$ 称为酉矩阵。</p><h3 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h3><h4 id="分块矩阵-1"><a href="#分块矩阵-1" class="headerlink" title="分块矩阵"></a>分块矩阵</h4><p>分块矩阵：一般的，对于任意一个 $m\times n$ 矩阵 $A$ ，可以用若干条水平直线和竖直线按某种需要把 $A$ 划分成若干个行数与列数较少的矩阵，这种矩阵称为 $A$ 的子阵或子块，被划分了的矩阵 $A$ 称为分块矩阵。</p><h4 id="分块矩阵的运算"><a href="#分块矩阵的运算" class="headerlink" title="分块矩阵的运算"></a>分块矩阵的运算</h4><p>分块矩阵的加法：设 $A$ 与 $B$ 是两个同型矩阵，按照相同方式分块后相加，得到和矩阵。</p><p>分块矩阵的数乘：数乘分块矩阵等于数乘分块矩阵的每个子块所得矩阵。</p><p>分块矩阵的转置：每个子块行列交换后再将每个子块转置。</p><p>分块矩阵的乘法</p><p>准对角矩阵：形为<br>$$<br>\begin{pmatrix}A_1&amp;&amp;&amp; \\ &amp;A_2&amp;&amp; \\ &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;A_s\end{pmatrix}<br>$$<br>的 $n$ 阶矩阵 $A$ 称为准对角矩阵。</p><p>性质：</p><ol><li>两个同型的准对角矩阵的乘积还是准对角矩阵。</li><li>准对角矩阵 $A$ 可逆的充分必要条件是 $A_1,\cdots,A_s$ 均可逆矩阵，且为同一型的准对角矩阵。</li></ol><h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><h3 id="向量组和矩阵的秩"><a href="#向量组和矩阵的秩" class="headerlink" title="向量组和矩阵的秩"></a>向量组和矩阵的秩</h3><h4 id="向量组的秩"><a href="#向量组的秩" class="headerlink" title="向量组的秩"></a>向量组的秩</h4><p>线性相关：设 $\alpha_1,\cdots,\alpha_s$ 是一组向量，若其中至少有一个向量可经组中其余 $s-1$ 个向量线性表出，则称 $\alpha_1,\cdots,\alpha_s$ 是线性相关的向量组。这时也称这 $s$ 个向量线性相关，否则就称该向量组是线性无关的向量组。这时也说这 $s$ 个向量线性无关。</p><p>定理：向量组 $\alpha_1,\cdots,\alpha_n$ 线性相关的充要条件是，至少存在一组不全为零的 $s$ 个数 $\lambda_1,\cdots \lambda_s$ ，使得等式<br>$$<br>\sum_{j=1}^s\lambda_j\alpha_j=\lambda_1\alpha_1+\cdots +\lambda_s\alpha_s<br>$$<br>成立。<br>推论：向量组 $\alpha_1,\cdots,\alpha_s$ 线性无关的充要条件是，仅当所有的 $\lambda_1,\cdots \lambda_s$ 都等于零时，该式成立。</p><p>定理： $n$ 阶行列式<br>$$<br>|A|=\mathrm{det}(a_{ij})=0<br>$$<br>的充分必要条件是，它的 $n$ 个行（列）向量线性相关。</p><p>推论： $n$ 阶行列式 $|A|\neq 0$ 的充要条件是， $|A|$ 的 $n$ 个行（列）向量线性无关。</p><p>推论：任何 $n+1$ 个 $n$ 维向量必线性相关。</p><p>极大线性无关组：若向量组的一个子组线性无关，但将向量组中任何一个向量添到这个线性无关子组中去，得到的都是线性相关的子组，则称该线性无关子组为向量组的极大线性无关组。</p><p>定理：对于一个给定的向量组，它的一切极大线性无关组所含向量的个数相同。</p><p>秩：一个向量组的极大线性无关组所含向量的个数称为该向量组的秩。</p><p>推论：秩为 $r$ 的向量组中，任何 $r+1$ 个向量必线性相关。</p><h4 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h4><p>子式：在矩阵 $A$ 中，位于 $k$ 个不同行与不同列相交处的元（按他们在 $A$ 中的排列顺序）构成的 $k$ 阶行列式<br>$$<br>\begin{vmatrix}<br>a_{i_{1}j_{1}}&amp;a_{i_{1}j_{2}}&amp;\cdots &amp;a_{i_{1}j_{k}}\\<br>a_{i_{2}j_{1}}&amp;a_{i_{2}j_{2}}&amp;\cdots &amp;a_{i_{1}j_{1}}\\<br>\vdots &amp;\vdots &amp;\ddots &amp;\vdots \\<br>a_{i_{k}j_{1}}&amp;a_{i_{k}j_{2}}&amp;\cdots &amp;a_{i_{k}j_{k}}<br>\end{vmatrix}<br>$$<br>$$<br>\begin{pmatrix}1\leq i_1&lt;i_2&lt;\cdots &lt;i_k\leq m\\1\leq j_1&lt;j_2&lt;\cdots &lt;j_k\leq n\end{pmatrix}<br>$$<br>称为矩阵 $A$ 的一个 $k$ 阶子式。</p><p>定理：矩阵 $A$ 的行秩等于 $A$ 中一切非零子式的最高阶数。</p><p>定理：矩阵的行秩等于列秩，它们都等于矩阵中非零子式的最高阶数。</p><p>定理： $r_{AB}\leq \mathrm{min}(r_{A},r_{B})$ 。<br>即矩阵乘积的秩不超过每个因子的秩。</p><p>推论：设 $A$ 为 $n$ 阶可逆矩阵， $P=P_{m\times n}$ ， $Q=Q_{n\times p}$ ，则 $r_{AQ}=r_{Q}$ ， $r_{PA}=r_{P}$ 。即任何矩阵乘可逆矩阵后，其秩不变。</p><p>推论：初等变换不改变矩阵的秩。</p><p>定义：满足下面两个条件的矩阵称为行阶梯形矩阵，简称阶梯形矩阵。</p><p>定理：设 $A=(a_{ij})$ 且 $r_A=r&gt;0$ 的充分必要条件是，存在可逆矩阵 $P=P_{m\times n}$ 和 $Q=Q_{n\times p}$ 使得<br>$$<br>A=P\begin{pmatrix}E_r&amp;0\\0&amp;0\end{pmatrix}Q<br>$$</p><h3 id="线性方程组的解法"><a href="#线性方程组的解法" class="headerlink" title="线性方程组的解法"></a>线性方程组的解法</h3><h4 id="非齐次线性方程组的解"><a href="#非齐次线性方程组的解" class="headerlink" title="非齐次线性方程组的解"></a>非齐次线性方程组的解</h4><p>线性方程组的一般形状是<br>$$<br>\begin{cases}<br>a_{11}x_1+a_{12}x_{2}+\cdot+a_{1n}x_n=b_1 \\ a_{21}x_1+a_{22}x_{2}+\cdot+a_{2n}x_n=b_2 \\<br>\cdots \\ a_{m1}x_1+a_{m2}x_{2}+\cdot+a_{mn}x_n=b_m<br>\end{cases}<br>$$</p><p>当等号右端 $m$ 个常数不全为零时它为非齐次线性方程组，当等号右端常数全为零时，称它为齐次次线性方程组。</p><p>定理：非齐次线性方程组有解的充要条件是系数矩阵的秩和增广矩阵的秩相等，即 $r_A=r_B$ 。</p><p>定理：当 $r_A=r_b=n$ 时，非齐次线性方程组只有唯一解，当 $r_A=r_B=r&lt;n$ 时，它有无穷多解。</p><p>矩阵消元法：</p><ol><li>写出方程组的增广矩阵，并用初等行变换把它化为阶梯型矩阵 $B_1$ ，即<br>$$<br>B=(A,b)\rightarrow B_1<br>$$<br>比较 $B_1$ 和 $B_1$ 中前 $n$ 列所成之矩阵的非零行个数立刻可知 $r_A=r_B$ 是否成立。<br>若 $r_A&lt;r_B$ （即 $r_B=r_A+1$ ），方程组无界。</li><li>若 $r_A=r_B=n$ ，则解以 $B_1$ 为增广矩阵的阶梯形方程组。为了便于求解，可以继续用初等行变换把 $B_1$ 化成行最简形；每行非零首元都等于1，而且非零首元所在的列，除非零首元本身外其余元全为零的阶梯型矩阵。<br>$$<br>B_1\rightarrow<br>\begin{pmatrix}<br>1&amp;0&amp;\cdots &amp;0&amp;a_{1,r+1}^{\prime}&amp;\cdots &amp;a_{1,n}^{\prime}&amp;b_1^{\prime}\\<br>0&amp;1&amp;\cdots&amp;0&amp;a_{2,r+1}^{\prime}&amp;\cdots &amp;a_{2,n}^{\prime}&amp;b_2^{\prime}\\<br>\vdots&amp;\vdots &amp;&amp;\vdots&amp;\vdots &amp;&amp;\vdots &amp;\vdots \\<br>0&amp;0&amp;\cdots &amp;1&amp;a_{r,r+1}^{\prime}&amp;\cdots &amp;a_{r,n}^{\prime}&amp;b_r^{\prime}\\<br>0&amp;0&amp;\cdots &amp;0&amp;0&amp;\cdots &amp;0&amp;0\\<br>\vdots &amp;\vdots &amp;&amp;\vdots &amp;\vdots &amp;&amp;\vdots&amp;\vdots \\<br>0&amp;0&amp;\cdots &amp;0&amp;0&amp;\cdots &amp;0&amp;0<br>\end{pmatrix}<br>$$<br>于是方程组的通解为<br>$$<br>\begin{cases}<br>x_1 = b_{1}^{\prime}-a_{1,r+1}^{\prime}\tilde{x}_{r+1}-\cdots -a_{1,n}\tilde{x}_n\\<br>x_2 =  b_{2}^{\prime}-a_{2,r+1}^{\prime}\tilde{x}_{r+1}-\cdots -a_{2,n}\tilde{x}_n\\<br>\cdots \\<br>x_r = b_{r}^{\prime}-a_{r,r+1}^{\prime}\tilde{x}_{r+1}-\cdots -a_{r,n}\tilde{x}_n\\<br>x_{r+1} = \tilde{x}_{r+1}\\<br>\cdots \\<br>x_n = \tilde{x}_n<br>\end{cases}<br>$$<br>其中 $\tilde{x}_{r+1},\cdots ,\tilde{x}_{n}$ 为任意常数。通解也可以写成向量形式<br>$$<br>\begin{pmatrix} x_1 \\ x_2 \\ \vdots \\ x_{r} \\ x_{r+1} \\ x_{r+2} \\ \vdots \\ x_{n}\end{pmatrix}=\begin{pmatrix}b_1^{\prime} \\ b_2^{\prime} \\ \vdots \\ b_{r}^{\prime} \\ 0 \\ 0 \\ \vdots \\ 0 \end{pmatrix}+\tilde{x}_{r+1}\begin{pmatrix} -a_{1,r+1}^{\prime} \\ -a_{2,r+1}^{\prime} \\ \vdots \\ -a_{r,r+1}^{\prime} \\ 1 \\ 0 \\ \vdots \\ 0\end{pmatrix}+\tilde{x}_{r+2}\begin{pmatrix} -a_{1,r+2}^{\prime} \\ -a_{2,r+2}^{\prime} \\ \vdots \\ -a_{r,r+2}^{\prime} \\ 0 \\ 1 \\ \vdots \\ 0\end{pmatrix}+\cdots +\tilde{x}_{n}\begin{pmatrix} -a_{1,n}^{\prime} \\ -a_{2,n}^{\prime} \\ \vdots \\ -a_{r,n}^{\prime} \\ 0 \\ 0 \\ \vdots \\ 1 \end{pmatrix}<br>$$<br>特别当 $\tilde{x}_{r+1}=\cdots = \tilde{x}_{n}=0$ 时，得到方程组的一个特解 $(b_1^{\prime},b_2^{\prime},\cdots,b_r^{\prime},0,0,\cdots,0)$ 。</li></ol><h4 id="齐次线性方程组的解法"><a href="#齐次线性方程组的解法" class="headerlink" title="齐次线性方程组的解法"></a>齐次线性方程组的解法</h4><p>齐次线性方程组<br>$$<br>\begin{cases}<br>a_{11}x_1+a_{12}x_{2}+\cdot+a_{1n}x_n=0 \\ a_{21}x_1+a_{22}x_{2}+\cdot+a_{2n}x_n=0 \\<br>\cdots \\ a_{m1}x_1+a_{m2}x_{2}+\cdot+a_{mn}x_n=0<br>\end{cases}<br>$$<br>它的矩阵形式是 $AX=0$ 。它的向量形式是 $A_1x_1+\cdots+A_nx_n=0$ 。<br>增广矩阵 $B=(A,0)$ 。由于 $r_B=r_A$ 。故齐次线性方程组必定有解。 $(0,\cdots,0)$ 称为零解（平凡解）。当 $r_A=n$ 时，它只有唯一解，即零解。当 $r_A&lt;n$ 时，还有非零解。特别对 $n$ 个未知量 $n$ 个方程的齐次线性方程组，有非零解的充要条件是，系数行列式 $|A|=0$ 。</p><h3 id="线性方程组的解的结构"><a href="#线性方程组的解的结构" class="headerlink" title="线性方程组的解的结构"></a>线性方程组的解的结构</h3><h4 id="齐次线性方程组的基础解系"><a href="#齐次线性方程组的基础解系" class="headerlink" title="齐次线性方程组的基础解系"></a>齐次线性方程组的基础解系</h4><p>基础解系：齐次线性方程组解集合的一个极大线性无关子组，称为该齐次线性方程组的一个基础解系。</p><p>定理：当 $r_A=r&lt;n$ 时，齐次线性方程组的基础解系有 $n-r$ 个向量。</p><h4 id="非齐次线性方程组解的结构"><a href="#非齐次线性方程组解的结构" class="headerlink" title="非齐次线性方程组解的结构"></a>非齐次线性方程组解的结构</h4><p>定理：把非齐次线性方程组的一个特解  加到它的导出组的每个解向量上，就得到非齐次线性方程组的全部解向量，它的全部解向量可表为<br>$$<br>X=X_0+k_1X_1+\cdots+k_{n-r}X_{n-r}<br>$$<br>其中 $k_1,\cdots,k_{n-r}$ 为任意的常数。</p><h2 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h2><h3 id="线性空间的概念"><a href="#线性空间的概念" class="headerlink" title="线性空间的概念"></a>线性空间的概念</h3><h4 id="线性空间的定义与例子"><a href="#线性空间的定义与例子" class="headerlink" title="线性空间的定义与例子"></a>线性空间的定义与例子</h4><p>重述向量集合基本运算规律：</p><ol><li>$\alpha+\beta = \beta + \alpha$</li><li>$(\alpha +\beta)+\gamma = \alpha + (\beta+\gamma)$</li><li>存在零向量 0 ，使 $0+\alpha=\alpha$ 对任意向量 $\alpha$ 成立。</li><li>对于每个向量 $\alpha$ 都有负向量 $(-\alpha)$ 存在，使得 $\alpha+(-\alpha)=0$ 。</li><li>$1\alpha = \alpha$</li><li>$\lambda(\alpha+\beta)=\lambda\alpha+\lambda\beta$</li><li>$(\lambda+\mu)\alpha = \lambda\alpha+\mu\alpha$</li><li>$\lambda(\mu\alpha)=(\lambda\mu)\alpha$</li></ol><p>其中 $\alpha,\beta,\gamma$ 表示向量， $\lambda,\mu$ 是实数。另外 $\lambda,\mu$ 也可能是某个数域中的数。</p><p>线性空间：设 $V$ 是一个非空集合。它的元以字母 $\alpha,\beta,\gamma,\cdots$ 表示。又 $F$ 是一个数域，其中的数用 $\lambda,\mu$ 表示。如果集合 $V$ 具备下列条件：<br>第一，在集合 $V$ 中定义了一个规则（称作加法运算），使得对于 $V$ 中任意二元 $\alpha$ 与 $\beta$ ，由这规则确定了 $V$ 中唯一的一元 $\gamma$ 。这个 $\gamma$ 叫做 $\alpha$ 与 $\beta$ 的和，且记为 $\gamma=\alpha+\beta$ 。这个加法运算满足基本运算规律 1-4 。<br>第二，在数域 $F$ 中的数与 $V$ 中的元之间也定义了一个规则（称为数乘运算），使得对于任意给定的数 $\lambda\in F$ 及元 $\alpha\in V$ ，由这一规则确定了 $V$ 中唯一的一个元；把这个元称为数 $\lambda$ 与元 $\alpha$ 的乘积，记为 $\lambda\alpha$ 。这个数乘运算满足前面的基本运算规律 5-8 。加法运算和数乘运算统称为线性运算。称集合 $V$ 按定义的线性运算构成数域 $F$ 上的线性空间，简称 $V$ 是 $F$ 上的线性空间。 $V$ 的元称为向量。</p><h4 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h4><p>子空间：设 $V$ 是 $F$ 上的线性空间， $L$ 是 $V$ 的一个非空子集，如果 $L$ 关于 $V$ 中的加法及数乘运算也构成 $F$ 上的一个线性空间，则 $L$ 称为 $V$ 的子空间。</p><h3 id="n-维线性空间"><a href="#n-维线性空间" class="headerlink" title="$n$ 维线性空间"></a>$n$ 维线性空间</h3><h4 id="n-维线性空间的定义"><a href="#n-维线性空间的定义" class="headerlink" title="$n$ 维线性空间的定义"></a>$n$ 维线性空间的定义</h4><p>$n$ 维线性空间：如果线性空间 $V$ 中存在由 $n$ 个向量构成的极大线性无关子组，则 $V$ 称为 $n$ 维线性空间。 $V$ 的极大线性无关子组称为 $V$ 的基或基底。基所含向量的个数称为空间 $V$ 的维数。</p><p>零空间（它没有基）的维数规定为零。<br>既非零空间又非 $n$ 维空间的线性空间称为无穷维空间。</p><p>定理：设 $[\alpha_1,\alpha_2,\cdots,\alpha_n]$ 是 $n$ 维线性空间 $V$ 的一个基，则 $V$ 中任何向量 $\alpha$ 均可由基的向量线性表出，即<br>$$<br>\alpha = a_1\alpha_1+\cdots +a_n\alpha_n<br>$$<br>且表出的形式是唯一的。</p><p>定理：设在基 $[\alpha_1,\alpha_2,\cdots,\alpha_n]$ 下， $n$ 维线性空间 $V$ 中的向量 $\alpha ,\beta$ 的坐标分别是<br>$$<br>X=(a_1,\cdots,a_n)<br>$$<br>$$<br>Y=(b_1,\cdots,b_n)<br>$$<br>则向量 $\alpha+\beta$ 与 $\lambda\alpha$ （ $\lambda$ 是数）的坐标分别为<br>$$<br>X+Y=(a_1+b_1,\cdots,a_n+b_n)<br>$$<br>$$<br>\lambda X = (\lambda a_1,\cdots,\lambda a_n)<br>$$</p><h4 id="基变换与坐标变换"><a href="#基变换与坐标变换" class="headerlink" title="基变换与坐标变换"></a>基变换与坐标变换</h4><p>定理：设 $[\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n]$ 和 $[\eta_1,\eta_2,\cdots,\eta_n]$ 是 $n$ 维线性空间 $V$ 的两个基。向量 $\alpha$ 在这两个基下的坐标分别为 $X$ 和 $Y$ ，若基变换为<br>$$<br>[\eta_1,\eta_2,\cdots,\eta_n]=[\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n]M<br>$$<br>其中 $M$ 为基 $[\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n]$ 到基 $[\eta_1,\eta_2,\cdots,\eta_n]$ 的过渡矩阵，则坐标变换公式为<br>$$<br>X=MY \text{或} Y=M^{-1}X<br>$$</p><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><h3 id="线性变换的定义"><a href="#线性变换的定义" class="headerlink" title="线性变换的定义"></a>线性变换的定义</h3><p>映射：设 $X,Y$ 是两个非空集合，如果有一个确定的法则 $f$ ，使得 $X$ 中每个元 $x$ 在 $f$ 之下有集合 $Y$ 中唯一确定的元 $y$ 与之对应，则称此法则 $f$ 是 $X$ 到 $Y$ 的一个映射，记为<br>$$<br>f:X \rightarrow Y<br>$$<br>若 $X$ 中的元 $x$ 通过映射 $f$ 得到 $Y$ 中的对应元 $y$ ，则记为<br>$$<br>f:x \rightarrow y<br>$$<br>称 $y$ 为映射 $f$ 下元 $x$ 的象，并记为 $y=f(x)$ 。而 $x$ 称为 $y$ 在映射 $f$ 下的原象。</p><p>变换：设 $V$ 是线性空间。 $V$ 到自身的映射 $T$ 称为 $V$ 的一个变换，即<br>$$<br>T:V \rightarrow V<br>$$<br>这时向量 $\alpha\in V$ 在变换 $T$ 之下的象 $\beta$ 记为 $\beta = T\alpha$ ，即</p><p>线性变换：设 $F$ 上线性空间 $V$ 有一个变换 $T$ ，它满足下列条件</p><ol><li>对任意 $\alpha,\beta\in V$ ，有 $T(\alpha+\beta)=T\alpha+T\beta$ 。</li><li>对任意 $\alpha\in V$ 和 $a\in F$ 有 $T(a\alpha)=aT\alpha$ 。</li></ol><p>则称 $T$ 是线性空间 $V$ 上的一个线性变换。</p><p>定理：线性空间 $V$ 上的变换 $T$ 是线性变换的充要条件是对任意数 $a,b$ 及 $V$ 中的向量 $\alpha,\beta$ 恒有 $T(a\alpha+b\beta)=aT\alpha+bT\beta$ 成立。</p><p>象子空间：设 $T$ 是线性空间 $V$ 的线性变换。令 $TV$ 是 $V$ 的全体向量的象集合，则 $TV$ 是 $V$ 的子空间。称 $TV$ 为在线性变换 $T$ 下 $V$ 的象子空间。</p><h3 id="n-维线性空间-V-中线性变换的矩阵"><a href="#n-维线性空间-V-中线性变换的矩阵" class="headerlink" title="$n$ 维线性空间 $V$ 中线性变换的矩阵"></a>$n$ 维线性空间 $V$ 中线性变换的矩阵</h3><h4 id="线性变换在一个基下的矩阵"><a href="#线性变换在一个基下的矩阵" class="headerlink" title="线性变换在一个基下的矩阵"></a>线性变换在一个基下的矩阵</h4><p>定理：设 $[\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n]$ 是线性空间 $V$ 的一个基， $T$ 是 $V$ 上的线性变换，则线性变换 $TV$ 被该基的象 $T\varepsilon_1,T\varepsilon_2,\cdots,T\varepsilon_n$ 所确定。</p><p>定理：对于每个 $n$ 阶矩阵 $A$ 。在 $n$ 维线性空间中必存在唯一的线性变换 $T$ ，使得 $T$ 在 $V$ 中给定的基下的矩阵恰为 $A$ 。</p><h4 id="线性变换在不同基下矩阵的关系"><a href="#线性变换在不同基下矩阵的关系" class="headerlink" title="线性变换在不同基下矩阵的关系"></a>线性变换在不同基下矩阵的关系</h4><p>设 $[\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n]$ 和 $[\eta_1,\eta_2,\cdots,\eta_n]$ 是线性空间 $V$ 中的两个基，且由基 $[\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n]$ 到基 $[\eta_1,\eta_2,\cdots,\eta_n]$ 的过渡矩阵为 $M$ ，即<br>$$<br>[\eta_1,\eta_2,\cdots,\eta_n]=[\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n]M<br>$$<br>又假定线性变换 $T$ 在这两个基下的矩阵分别为 $A$ 和 $B$ ，即<br>$$<br>T[\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n]=[\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n]A<br>$$<br>$$<br>T[\eta_1,\eta_2,\cdots,\eta_n]=[\eta_1,\eta_2,\cdots,\eta_n]B<br>$$<br>则有 $B=M^{-1}AM$ 。</p><p>相似：设 $A,B$ 是 $n$ 阶矩阵，若存在满秩矩阵 $M$ ，使 $B=M^{-1}AM$ 成立，则称矩阵 $A$ 与 $B$ 相似，记为 $A\sim B$ 。</p><p>矩阵相似有以下三条性质：</p><ol><li>自反性 $A\sim A$</li><li>对称性 $A\sim B$ ，则 $B\sim A$</li><li>传递性 $A\sim B,B\sim C$ ，则 $A\sim C$</li></ol><h3 id="矩阵的对角化"><a href="#矩阵的对角化" class="headerlink" title="矩阵的对角化"></a>矩阵的对角化</h3><h4 id="矩阵的特征值与特征向量"><a href="#矩阵的特征值与特征向量" class="headerlink" title="矩阵的特征值与特征向量"></a>矩阵的特征值与特征向量</h4><p>特征值：设 $A=(a_{ij})$ 是 $n$ 阶矩阵，若数 $\lambda$ 和 $n$ 维非零（列）向量 $X$ 使得等式 $AX=\lambda X$ 成立，则称 $\lambda$ 是矩阵 $A$ 的特征值（特征根）， $X$ 是 $A$ 对应与于 $\lambda$ 特征向量。</p><p>定理：设 $A=(a_{ij})$ 为 $n$ 阶矩阵，则 $\lambda$ 是 $A$ 的特征值的充要条件是行列式 $|\lambda E-A|=0$ 而 $A$ 的对应于特征值 $\lambda$ 的特征向量是齐次线性方程组 $(\lambda E-A)X=0$ 的非零解向量。</p><p>特征方程：设 $A=(a_{ij})$ 为 $n$ 阶矩阵，方程 $|\lambda E-A|$ 称为矩阵 $A$ 的特征方程。特征方程左端的多项式 $\varphi_A(\lambda)=|\lambda E-A|$ 称为矩阵 $A$ 的特征多项式。</p><p>定理：相似矩阵有完全相同的特征值。</p><p>定理：设 $A$ 为分块对角矩阵<br>$$<br>\begin{pmatrix}A_1&amp;&amp;&amp;\\&amp;A_2&amp;&amp;\\&amp;&amp;\ddots &amp;\\&amp;&amp;&amp;A_s\end{pmatrix}<br>$$<br>则 $A$ 的所有特征值就是 $A_1,A_2,\cdots,A_s$ 的全部特征值。</p><p>定理：设 $\lambda_1,\cdots,\lambda_r$ 是矩阵 $A$ 的 $r$ 个互不相同的特征值。又 $X_1,\cdots ,X_r$ 是 $A$ 的分别对应这 $r$ 个特征值的特征向量，则 $X_1,\cdots X_r$ 线性无关。</p><p>定理：设 $\lambda_1,\cdots ,\lambda_k$ 是 $n$ 阶矩阵 $A$ 的 $k$ 个互异的特征值。又 $X_{j1},X_{j2},\cdots ,X_{jr_{j}}$ 是 $A$ 对应于特征值 $\lambda_j(j=1,\cdots,k)$ 的 $r_j$ 个线性无关的特征向量，则向量组<br>$$<br>X_{11},\cdots,X_{1r_1},X_{21},\cdots ,X_{2r_2},\cdots, X_{k1},\cdots X_{kr_k}<br>$$<br>（共计 $r_1+\cdots +r_k$ 个向量）必线性无关。</p><p>定理：设 $\lambda_0$ 是 $n$ 阶矩阵 $A$ 的 $k$ 重特征值，则 $A$ 的对应于 $\lambda_0$ 的特征子空间的维数不超过 $k$ 。</p><h4 id="矩阵的对角化-1"><a href="#矩阵的对角化-1" class="headerlink" title="矩阵的对角化"></a>矩阵的对角化</h4><p>定理： $n$ 阶复矩阵 $A$ 与对角矩阵相似的充要条件是 $A$ 有 $n$ 个线性无关的特征向量。</p><p>定理： $n$ 阶复矩阵 $A$ 的特征值都是单根，则 $A$ 必相似于对角矩阵。</p><p>定理： $n$ 阶复矩阵 $A$ 相似于对角矩阵的充要条件是，对于每个 $k_i(1\leq k_i \leq n)$ 重特征值 $\lambda_i$ ，矩阵 $\lambda_i E-A$ 的秩等于 $n-k_i$ 。</p><h2 id="欧几里得空间"><a href="#欧几里得空间" class="headerlink" title="欧几里得空间"></a>欧几里得空间</h2><h3 id="欧几里得空间-1"><a href="#欧几里得空间-1" class="headerlink" title="欧几里得空间"></a>欧几里得空间</h3><h4 id="向量的标准内积"><a href="#向量的标准内积" class="headerlink" title="向量的标准内积"></a>向量的标准内积</h4><p>内积：设 $V$ 是实线性空间，如果对于 $V$ 内任意一对向量 $\alpha,\beta$ 按某一法则在 $R$ 中有唯一确定的实数，记为 $\langle \alpha,\beta\rangle $ ，与之对应，且满足条件：</p><ol><li>$$\langle \alpha,\beta\rangle =\langle \beta,\alpha\rangle $$</li><li>$$\langle \alpha+\beta,\gamma\rangle =\langle \alpha,\gamma\rangle +\langle \beta,\gamma\rangle  (\gamma\in V)$$</li><li>$$\langle a\alpha,\beta\rangle =a\langle \alpha,\beta\rangle (a\in R)$$</li><li>当 $\alpha\neq 0$ 时， $\langle \alpha,\alpha\rangle &gt; 0$ 。<br>则实数 $\langle \alpha,\beta \rangle$ 称为向量 $\alpha$ 与 $\beta$ 的标准内积，简称内积。定义了内积的实线性空间称为欧几里得空间，简称欧式空间。</li></ol><p>欧氏空间 $V$ 中的内积有下列基本性质：</p><p>性质1：对于任意 $\alpha\in V$ ，有 $\langle 0,\alpha \rangle=0$ ，特别 $\langle 0,0 \rangle=0$ 。<br>性质2：设 $\alpha$ 为 $V$ 中某一向量，若对于 $V$ 中任何向量 $\beta$ 都有 $\langle \alpha,\beta \rangle$ ，则 $\alpha=0$ 。<br>性质3：对于任意的 $\alpha_i,\beta_j\in V$ 及 $a_i,b_j\in R(i=1,\cdots,l;j=1,\cdots,t)$ 恒有<br>$$<br>\left\langle \sum_{i=1}^la_i\alpha_i,\sum_{j=1}^tb_j\beta_j\right\rangle=\sum_{i=1}^l\sum_{j=1}^ta_ib_j\langle \alpha_i,\beta_j\rangle<br>$$</p><p>模：设 $\alpha$ 是欧氏空间中的任一向量， $\langle \alpha,\alpha \rangle$ 的算术平方根 $\sqrt{\langle \alpha,\alpha \rangle}$ 称为向量 $\alpha$ 的模，记为 $\vert \alpha \vert$ ，即 $\vert \alpha \vert = \sqrt{\langle \alpha,\alpha \rangle}$ 。</p><p>模为 $1$ 的向量称为单位向量。零向量的模为零。</p><p>定理：对于欧氏空间中的任意两个向量 $\alpha,\beta$ 恒有<br>$$<br>{\langle \alpha,\beta \rangle }^2\leq \langle \alpha,\alpha \rangle \langle \beta,\beta \rangle<br>$$<br>其中等号成立的充要条件是 $\alpha$ 与 $\beta$ 线性相关。</p><p>夹角：设 $\alpha,\beta$ 是欧氏空间中任意两个非零向量。角度 $\theta = \arccos \dfrac{\langle \alpha , \beta \rangle}{\vert \alpha \vert \vert \beta \vert}(0\leq \theta \leq \pi)$ 称为向量 $\alpha$ 与 $\beta$ 的夹角，记为 $\theta =(\widehat{\alpha,\beta})$ 。</p><h4 id="标准正交基"><a href="#标准正交基" class="headerlink" title="标准正交基"></a>标准正交基</h4><p>标准正交组：欧氏空间 $V$ 中的一组两两正交的非零向量，称为 $V$ 的一个正交组。若这个正交组中的每个向量都是单位向量，则此正交组称为标准正交组。</p><p>定理：欧氏空间中的正交组必为线性无关组。</p><p>定理：设 $\alpha_1,\cdots,\alpha_m$ 是欧氏空间 $V$ 的一组线性无关的向量，则存在 $V$ 的一个正交组 $\beta_1,\cdots,\beta_m$ ，其中 $\beta_k$ 是向量 $\alpha_1,\cdots,\alpha_k$(k=1,\cdots,m) 的线性组合。</p><p>定理：任何 $n(n\geq 1)$ 维欧氏空间一定有正交基，从而也一定有标准正交基。</p><p>定理：设 $[\varepsilon_1,\cdots,\varepsilon_n]$ 是 $n$ 维欧氏空间  的一个标准正交基。向量 $\alpha,\beta$ 在该基下用坐标分别表示为<br>$$<br>\alpha=[\varepsilon_1,\cdots,\varepsilon_n]\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\end{pmatrix},\beta=[\varepsilon_1,\cdots,\varepsilon_n]\begin{pmatrix}y_1\\y_2\\\vdots\\y_n\end{pmatrix}<br>$$<br>则有<br>$$<br>\langle \alpha,\beta \rangle = x_1y_1+\cdots +x_ny_n<br>$$<br>$$<br>\vert \alpha \vert = \sqrt{\langle \alpha,\alpha\rangle}=\sqrt{x_1^2+\cdots +x_n^2}<br>$$</p><h3 id="正交变换"><a href="#正交变换" class="headerlink" title="正交变换"></a>正交变换</h3><p>正交变换：设 $T$ 是欧氏空间 $V$ 中的线性变换，如果对于任意的 $\alpha\in V$ 都有 $\vert T\alpha \vert =\vert \alpha \vert$ ，则 $T$ 称为正交变换。</p><p>定理：欧氏空间 $V$ 中的线性变换 $T$ 为正交变换的充要条件是，对任意的 $\alpha,\beta\in V$ 有 $\langle T\alpha,T\beta \rangle=\langle \alpha , \beta \rangle$ 。</p><p>定理：设 $[\varepsilon_1,\cdots,\varepsilon_n]$ 是 $n$ 维欧氏空间  的标准正交基， $V$ 中的线性变换 $T$ 为正交变换的充要条件是， $[T\varepsilon_1,\cdots,T\varepsilon_n]$ 也是 $V$ 中的标准正交基。</p><p>定理：设 $[\varepsilon_1,\cdots,\varepsilon_n]$ 是 $n$ 维欧氏空间  的一个标准正交基。 $V$ 中线性变换 $T$ 是正交变换的充要条件是， $T$ 在标准正交基 $[\varepsilon_1,\cdots,\varepsilon_n]$ 下的矩阵 $H$ 是正交矩阵。</p><h2 id="n-元实二次型"><a href="#n-元实二次型" class="headerlink" title="$n$ 元实二次型"></a>$n$ 元实二次型</h2><h3 id="n-元实二次型及其标准形"><a href="#n-元实二次型及其标准形" class="headerlink" title="$n$ 元实二次型及其标准形"></a>$n$ 元实二次型及其标准形</h3><h4 id="n-元实二次型的定义"><a href="#n-元实二次型的定义" class="headerlink" title="$n$ 元实二次型的定义"></a>$n$ 元实二次型的定义</h4><p>定义： $n$ 个实变元的实系数二次齐次函数<br>$$<br>\begin{align*}<br>f\left(x_{1}, x_{2}, \cdots, x_{n}\right)=a_{11}x_{1}^{2}+2 a_{12} x_{1} x_{2}+2 a_{13} x_{1} x_{3}+\cdots+2 a_{1 n} x_{1} x_{n} \\ +a_{22} x_{2}^{2}+2 a_{23} x_{2} x_{3}+\cdots+2 a_{2 n} x_{2} x_{n} \\ +a_{33} x_{3}^{2}+\cdots+2 a_{3 n} x_{3} x_{n} \\ + \cdots \\ +a_{nn}x_n^2<br>\end{align*}<br>$$<br>称为实数域上的 $n$ 元二次型，简称实二次型。<br>记<br>$$<br>A=\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n}\\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\\vdots &amp;\vdots &amp; &amp;\vdots \\a_{n1}&amp;a_{}&amp;a_{n2}&amp;a_{nn}\end{pmatrix},X=\begin{pmatrix}x_1\\x_2\\\vdots \\x_n\end{pmatrix}<br>$$</p><p>于是 $n$ 元实二次型可表示为<br>$$<br>f(x_1,x_2,\cdots ,x_n)=\sum_{i=1}^n\sum_{j=1}^na_{ij}x_ix_j = X^{T}AX<br>$$<br>其中 $A$ 是对称矩阵。</p><p>定理： $n$ 元实二次型 $X^{T}AX$ 可经坐标变换 $X=CY$ （ $C$ 为可逆实矩阵）化为二次型 $Y^{T}BY$ ，其中 $B=C^{T}AC$ 。</p><p>合同矩阵：设 $A,B$ 为数域 $F$ 上的 $n$ 阶矩阵。如果存在数域 $F$ 上的可逆矩阵 $C$ ，使得 $B=C^{T}AC$ 成立，则 $A$ 与 $B$ 是合同矩阵（或简称 $A$ 与 $B$ 合同）。<br>合同矩阵有下列性质：</p><ol><li>$A$ 与 $A$ 合同。</li><li>若 $A$ 与 $B$ 合同，则 $B$ 与 $A$ 合同。</li><li>若 $A$ 与 $B$ 合同， $B$ 与 $C$ 合同，则 $A$ 与 $C$ 合同。<br>若两个 $n$ 元实二次型 $X^{T}AX$ 与 $Y^{T}BY$ 可经坐标变换相互转化，则称这两个二次型是等价的。</li></ol><h4 id="n-元实二次型的标准形"><a href="#n-元实二次型的标准形" class="headerlink" title="$n$ 元实二次型的标准形"></a>$n$ 元实二次型的标准形</h4><p>标准形：只含变元平方项的二次型<br>$$<br>f=d_1x_1^2+\cdots +d_nx_n^2<br>$$<br>称为二次型的标准形。</p><p>定理：秩为 $r$ 的 $n$ 元实二次型 $f=X^{T}AX$ 必可经坐标变换 $X=CY$ 化为标准形<br>$$<br>d_1y_1^2+\cdots +d_ry_r^2(d_i\neq 0,i=1,2,\cdots ,r)<br>$$<br>可以将标准形进一步化成<br>$$<br>z_1^2+\cdots +z_t^2-z_{t+1}^2-\cdots -z_r^2<br>$$<br>为规范形。</p><p>惯性定理：在秩为 $r$ 的 $n$ 元实二次型的标准形中，正平方项的个数 $t$ 是唯一确定的，从而负平方项的个数 $r-t$ 也是唯一确定的。</p><p>将标准形中正平方项的个数称为正惯性指数，负平方项的个数为该二次型的负惯性指数。</p><p>定理：秩为 $r$ 的 $n$ 阶对称矩阵 $A$ 必合同与对角矩阵，即存在可逆矩阵 $C$ ，使<br>$$<br>C^{T}AC=\begin{pmatrix}d_1&amp;&amp;&amp;&amp;&amp;&amp;\\&amp;d_2&amp;&amp;&amp;&amp;&amp;\\&amp;&amp;\ddots&amp;&amp;&amp;&amp;\\&amp;&amp;&amp;d_r&amp;&amp;&amp;\\&amp;&amp;&amp;&amp;0&amp;&amp;\\&amp;&amp;&amp;&amp;&amp;\ddots&amp;\\&amp;&amp;&amp;&amp;&amp;&amp;0\end{pmatrix}<br>$$<br>其中 $d_1,d_2,\cdots ,d_r$ 均不为零。</p><p>合同变换</p><h3 id="正定二次型"><a href="#正定二次型" class="headerlink" title="正定二次型"></a>正定二次型</h3><p>正定二次型：若对任意 $X\neq 0$ ，恒有 $X^{T}AX&gt;0$ 则实二次型 $X^{T}AX$ 称为正定二次型。</p><p>正定二次型的矩阵 $A$ 称为正定矩阵。</p><p>负定二次型：若对任意 $X\neq 0$ ，恒有 $X^{T}AX&lt;0$ 则实二次型 $X^{T}AX$ 称为负定二次型。</p><p>定理： $n$ 元实二次型正定的充要条件是，它的正惯性指数等于 $n$ 。</p><p>推论： $n$ 元实二次型为负定的充要条件是，它的负惯性指数等于 $n$ 。</p><p>推论： $n$ 元实二次型 $X^{T}AX$ 为正定的必要条件是，行列式 $\vert A\vert &gt;0$ 。</p><p>定理： $n$ 元实二次型 $f=X^{T}AX$ 为正定的充要条件是，它的矩阵 $A$ 的左上角的各阶主子式（称为顺序主子式）都大于零。</p><p>推论： $n$ 元实二次型 $f=X^{T}AX$ 为负定的充要条件是，它的矩阵 $A$ 的一切奇数阶顺序主子式为负，一切偶数阶的顺序主子式为正。</p><h3 id="用正交变换化二次型为标准形"><a href="#用正交变换化二次型为标准形" class="headerlink" title="用正交变换化二次型为标准形"></a>用正交变换化二次型为标准形</h3><p>定理： $n$ 阶对称矩阵的特征根必为实数。</p><p>定理：设 $\lambda_0$ 是 $n$ 阶对称矩阵 $A$ 的 $k$ 重特征根，则 $A$ 对应于 $\lambda_0$ 的特征子空间的维数恰等于 $k$ ，即齐次线性方程组<br>$$<br>(\lambda_0E-A)X=0<br>$$<br>的基础解系恰有 $k$ 个解向量。</p><p>定理：设 $\lambda_1$ 与 $\lambda_2$ 是对称矩阵 $A$ 的互异特征根， $X_1,X_2$ 分别是 $A$ 属于它们的特征向量，则 $X_1$ 与 $X_2$ 正交（即 $X_1^TX_2=0$ ）。</p><p>定理：对 $n$ 阶对称矩阵 $A$ ，一定存在正交矩阵 $C$ 使得<br>$$<br>C^TAC=C^{-1}AC=\begin{pmatrix}\lambda_1&amp;&amp;&amp;\\&amp;\lambda_2&amp;&amp;\\&amp;&amp;\ddots &amp;\\&amp;&amp;&amp;\lambda_n\end{pmatrix}<br>$$<br>其中 $\lambda_1,\cdots,\lambda_n$ 是 $A$ 的全部特征根。</p><p>定理：任一个 $n$ 元实二次型<br>$$<br>f(x_1,\cdots,x_n)=X^TAX(A^T=A)<br>$$<br>必存在正交变换 $X=CY(C^T=C^{-1})$ ，把该二次型化为标准形<br>$$<br>f=X^TAX=\lambda_1y_1^2+\cdots +\lambda_ny_n^2<br>$$<br>其中 $\lambda_1,\cdots,\lambda_n$ 是对称矩阵 $A$ 的全部特征根。</p><hr><p>$$<br>\mathscr{THE} \quad \mathscr{END}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>纯数学</category>
      
      <category>代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复变函数与积分变换</title>
    <link href="/archives/e9faf39c.html"/>
    <url>/archives/e9faf39c.html</url>
    
    <content type="html"><![CDATA[<p>这门课虽然不在我的必修课里，但是许多课程，比如数字信号处理，都要用到里面的知识，这篇文章的更新速度也会偏慢。</p><span id="more"></span><h1 id="复变函数与积分变换"><a href="#复变函数与积分变换" class="headerlink" title="复变函数与积分变换"></a>复变函数与积分变换</h1><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><h3 id="复数的定义及其四则运算"><a href="#复数的定义及其四则运算" class="headerlink" title="复数的定义及其四则运算"></a>复数的定义及其四则运算</h3><p>复数：对实数 $x,y$ ，形如 $x+\mathrm{i} y$ 的数称为复数。两个复数 $x_1+\mathrm{i}y_1$ 和 $x_2+\mathrm{i}y_2$ 称为相等的，当且仅当 $x_1=x_2$ 且 $y_1=y_2$ 。由全体复数构成的集合记为 $\mathbb{C}$ 。</p><p>实部与虚部：对于复数 $x+\mathrm{i}y,(x,y\in \mathbb{R})$ ，称 $x$ 为 $z$ 的实部，记作 $\mathrm{Re} {z}$ ，称 $y$ 为 $z$ 的虚部，记作 $\mathrm{Im} {z}$ 。特别的，若 $x=0$ 且 $y\neq 0$ ，则将 $z$ 记为 $\mathrm{i}y$ ，称为纯虚数。</p><p>复数的四则运算：加减乘除</p><p>略</p><h3 id="复数的几何表示"><a href="#复数的几何表示" class="headerlink" title="复数的几何表示"></a>复数的几何表示</h3><p>模与幅角：复数 $z=x+\mathrm{i}y$ 的模规定为复数 $z$ 作为向量的欧氏长度 $|z|=\sqrt{x^2+y^2}$ ，非零复数 $z$ 的幅角规定为 $z$ 作为向量与 $x$ 轴正方向的夹角，记为 $\mathrm{Arg} z$ 。</p><p>若以 $r$ 和 $\theta$ 分别记一个非零复数的模和幅角，则 $(r,\theta)$ 为 $z$ 的极坐标，对一切非零复数 $z$ ，有</p><p>$$<br>z=r(\cos \theta+\mathrm{i}\sin \theta)<br>$$</p><p>这一表达式称为复数 $z$ 的三角形式。</p><p>显然幅角不唯一，如果 $\theta$ 是复数 $z$ 的幅角，则 $\theta +2\pi $ 也是 $z$ 的幅角，其中取值在 $(-\pi,\pi ]$ 上的幅角称为复数 $z$ 的幅角主值，记为 $\mathrm{arg}z$ 。</p><p>三角不等式： $|z_1| - |z_2| \leq |z_1+z_2| \leq |z_1|+|z_2|$ 。</p><p>棣莫弗公式：若 $z=r(\cos \theta+\mathrm{i}\sin \theta)$ 为非零复数 $z$ 的三角形式， $n$ 为整数，则 $z^n=r^n((\cos (n\theta)+\mathrm{i}\sin (n\theta))$ 。特别，对非零复数 $z$ 和整数 $n$ ，有</p><p>$$<br>|z^n|={|z|}^n,\mathrm{Arg}z^n=n \mathrm{arg}z +2k \pi,k\in \mathbb{Z}<br>$$</p><p>开方：任意一个非零复数 $z$ 恰有 $n$ 个互不相同的复 $n$ 次方根。若 $z=r(\cos \theta+\mathrm{i}\sin \theta)$ 为非零复数 $z$ 的三角形式，则 $z$ 的 $n$ 个互不相同的复 $n$ 次方根为</p><p>$$<br>\sqrt[n]{r}(\cos \dfrac{\theta+2k\pi }{n}+\mathrm{i}\sin \dfrac{\theta+2k\pi}{n})<br>$$</p><p>这里 $k=0,1,\cdots,n-1$ 。</p><p>复数的指数形式：欧拉记 $e^{\mathrm{i}\theta}=\cos \theta+\mathrm{\sin\theta}$ 。于是 $z=r(\cos \theta+\mathrm{i}\sin \theta)$ 可简记为 $z=re^{\mathrm{i}\theta}$ ，称为复数的指数形式。</p><p>利用欧拉公式可以得到： $1+e^{\mathrm{i}\pi}=0$ 。</p><p>共轭复数：对于复数 $z=x+\mathrm{i}y$ ，称 $\overline{z}=x-\mathrm{i}y$ 为 $z$ 的共轭复数。</p><p>球极投影：考虑三维欧式空间 $\mathbb{R}^3$ 以及其上的单位球面</p><p>$$<br>S^2=\{ (x_1,x_2,x_3)|x_1^2+x_2^2+x_3^2=1 \}<br>$$</p><p>并将赤道平面与复平面等同，其中 $x_1$ 轴取为实轴， $x_2$ 轴取为虚轴，记北极点 $(0,0,1)$ 为 $N$ ，任取复平面上一点 $A$ ，连接北极点 $N$ 与 $A$ 的直线，易见该直线与除去北极点的单位球面 $S^2-\{ N \}$ 交于唯一一点，记为 $P(A)$ ，于是</p><p>$$<br>P:C\rightarrow S^2-\{ N \}<br>$$</p><p>可看作复平面除去北极点的单位球面 $S^2-\{ N \}$ 上的一个映射，该映射就称为球极投影，此时的单位球面称为黎曼球面，显然，该映射是可逆的。</p><p>不难算出映射 $P$ 的表达式为</p><p>于是 $P$ 连续可微，且满足</p><p>$$<br>\lim_{|z|\to \infty}P(z)=N<br>$$</p><p>由此规定 $N=P(\infty)$ ， $\infty$ 称为无穷远点。并记 $\overline{C}=C\cup \{ \infty \}$ ，称为扩充复平面，从而 $P$ 是一个从扩充复平面到黎曼球面的双射，而且在无穷远点也是连续的。</p><h3 id="平面点集的复数表示"><a href="#平面点集的复数表示" class="headerlink" title="平面点集的复数表示"></a>平面点集的复数表示</h3><p>平面上的曲线是光滑的，如果该曲线可以写为参数方程</p><p>$$<br>\begin{cases}x=x\left( t\right) \\ y=y\left( t\right) \end{cases}<br>$$</p><p>这里 $\alpha \leq t\leq \beta$ ，且 $x^{\prime}(t)$ ， $y^{\prime}(t)$ 在 $[\alpha,\beta]$ 上连续。</p><p>曲线如果由有限段光滑曲线依次首尾连接而成的，这样的曲线称为逐段光滑曲线。</p><p>Jordan曲线定理：平面上的任何一条简单闭曲线 $C$ 必将平面分成两个不相交的区域，其中一个为有界，称为曲线 $C$ 的内部区域，另一个为无界的，称为曲线的外部区域，这两个区域均以 $C$ 为其边界。</p><p>设 $D$ 为一个区域，如果 $D$ 内任一条简单闭曲线的内部区域完全包含于 $D$ 内，则称 $D$ 是单连通的，否则称为多连通的。</p><h3 id="复变函数"><a href="#复变函数" class="headerlink" title="复变函数"></a>复变函数</h3><p>复变函数是定义在复数集的子集上，取值也在复数集上的函数。</p><p>复变函数的分量表示：给定复变函数 $w=f(z)$ ，记 $z=x+\mathrm{i}y$ ，再记 $u=\mathrm{Re}f(z),v=\mathrm{Im}f(z)$ ，显然 $u,v$ 由 $z$ 或者 $(x,y)$ 唯一确定，从而 $u,v$ 可以看做关于 $x,y$ 的二元实函数，于是，一元复变函数作为映射等同于以两个实二元函数为分量的从平面区域到平面的映射，即</p><p>$$<br>z\rightarrow f(z)\Leftrightarrow \begin{pmatrix}<br>x \\ y<br>\end{pmatrix} \rightarrow \begin{pmatrix}<br>u(x,y) \\ v(x,y)<br>\end{pmatrix}<br>$$</p><h2 id="解析函数的微积分"><a href="#解析函数的微积分" class="headerlink" title="解析函数的微积分"></a>解析函数的微积分</h2><h3 id="复变函数的极限和连续性"><a href="#复变函数的极限和连续性" class="headerlink" title="复变函数的极限和连续性"></a>复变函数的极限和连续性</h3><p>复数列的极限：设复数列 $\{ z_n \}$ ，若存在常数 $z_0$ 对任何 $\epsilon&gt;0$ ，存在 $N&gt;0$ ，使当 $n&gt;N$ 时，有 $|z_n-z_0|&lt;\epsilon$ ，则称该复数列 $\{ z_n \}$ 收敛或存在极限， $z_0$ 称为其极限，记为 $\lim_{n\to \infty}z_n=z_0$ 。</p><p>记 $z_n=x_n+\mathrm{i}y,(n=0,1,2,\cdots)$ ，有</p><p>$$<br>\max \{ |x_n-x_0|,|y_n-y_0| \} \leq |z_n-z_0| \leq |x_n-x_0|+|y_n-y_0|<br>$$</p><p>定理：复数列 $\{ z_n \}$ 收敛，当且仅当实数列 $\{ x_n=\mathrm{Re}z_n \}$ 和 $\{ y_n=\mathrm{Im}z_n \}$ 同时收敛，且 $\lim_{n\to \infty}z_n=\lim_{n\to \infty}x_n+\mathrm{i} \lim_{n\to \infty}y_n$ 。</p><p>定理：设 $\{ z_n \}$ 和 $\{ w_n \}$ 为复数列，且极限 $\lim_{n\to \infty}z_n$ 和 $\lim_{n\to \infty}w_n$ 都存在，则</p><ol><li>数列 $\{ z_n \}$ 和 $\{ w_n \}$ 均为有界的。</li><li>$$\lim_{n\to \infty}(z_n+w_n)=\lim_{n\to \infty}z_n \pm \lim_{n\to \infty}w_n$$</li><li>对一切复常数 $c$ ， $\lim_{n\to \infty}cz_n=c\lim_{n\to \infty}z_n$ 。</li><li>$$\lim_{n\to \infty}(z_nw_n)=(\lim_{n\to \infty}z_n)\cdot (\lim_{n\to \infty}w_n)$$</li><li>若 $\lim_{n\to \infty}w_n\neq 0$ ，则存在 $N&gt;0$ ，使得对一切 $n&gt;N$ ，有 $w_n\neq 0$ ，进一步， $\lim_{n\to \infty}w_n^{-1}=(\lim_{n\to \infty}w_n)^{-1}$ 。</li></ol><p>复变函数的极限：设 $f(z)$ 为定义在 $S$ 上的函数， $z_0$ 为 $\overline{S}$ 上的一点，且不是 $S$ 的孤立点。若存在复常数 $A$ ，使对任何 $\epsilon &gt;0$ ，都存在 $\delta &gt;0$ ，使得对 $S$ 上一切满足 $0&lt;|z-z_0|&lt;\delta$ 的点 $z$ ，都有 $|f(z)-A| &lt; \epsilon$ ，则称 $A$ 为 $f(z)$ 当 $z$ 趋向于 $z_0$ 时的极限，记作 $\lim_{z\to z_0}f(z)=A$ 。</p><p>记 $A=a+\mathrm{i}b$ ， $f(z)=u(x,y)+\mathrm{i}v(x,y)$ ，有</p><p>$$<br>\max \{ |u(x,y)-a|,|v(x,y)-b| \} \leq |f(z)-A| \leq |u(x,y)-a|+|v(x,y)-b|<br>$$</p><p>定理：函数 $f(z)$ 在点 $z_0$ 的极限 $\lim_{z\to z_0}f(z)$ 存在，当且仅当实部 $u(x,y)$ 和虚部 $v(x,y)$ 作为二元实函数，极限 $\lim_{x\to x_0 \\ y\to y_0}u(x,y)$ 与 $\lim_{x\to x_0 \\ y\to y_0}v(x,y)$ 同时存在，且</p><p>$$<br>\lim_{z\to z_0}f(z)=\lim_{x\to x_0 \\ y\to y_0}u(x,y)+\mathrm{i}\lim_{x\to x_0 \\ y\to y_0}v(x,y)<br>$$</p><p>定义：设 $f(z)$ 为定义在 $\{ |z| &gt; R \}$ 内的函数， $R$ 为给定的非负数。若存在复常数 $A$ ，使对任何 $\epsilon &gt;0$ 都存在 $G&gt;R$ ，使得对一切满足 $|z| &gt; G$ 的点 $z$ ，都有 $|f(z)-A| &lt; \epsilon$ ，则称 $z$ 为 $f(z)$ 当 $z$ 趋向于无穷远点时的极限，记作 $\lim_{z\to \infty}f(z)=A$ 。</p><p>定义：设 $f(z)$ 为定义在 $S$ 上的函数， $z_0$ 为 $\overline{S}$ 上的一点，若对任何 $M&gt;0$ ，都存在 $\delta&gt;0$ ，使得对 $S$ 内一切满足 $0&lt;|z-z_0|$ 的点 $z$ ，都有 $|f(z)|&gt;M$ ，则称当 $z$ 趋向于 $z_0$ 时 $f(z)$ 趋于无穷远点，记作 $\lim_{z\to z_0}f(z)=\infty$ 。</p><p>定义：设 $f(z)$ 为定义在 $\{ |z|&gt;R \}$ 上的函数， $R$ 为给定的非负数，若对任何 $M&gt;0$ ，都存在 $G&gt;R$ ，使得对一切满足 $|z|&gt;G$ 的点 $z$ ，都有 $|f(z)&gt;M|$ ，则称当 $z$ 趋向于 $\infty$ 时 $f(z)$ 趋于无穷远点，记作 $\lim_{z\to \infty}f(z)=\infty$ 。</p><p>定理：设 $f$ 和 $g$ 都是定义在 $S$ 上的函数，且极限 $\lim_{z\to z_0}f(z)$ 和 $\lim_{z\to z_0}g(z)$ 都存在有限，则以下结论成立：</p><ol><li>存在 $\delta&gt;0$ ，使得 $f(z)$ 和 $g(z)$ 在 \{ 0&lt;|z-z_0|&lt; \delta \} 内均为有界的。</li><li>$$\lim_{z\to z_0}(f(z)\pm g(z))=\lim_{z\to z_0}f(z)\pm \lim_{z\to z_0}g(z)$$ 。</li><li>对一切复常数 $c$ ， $\lim_{z\to z_0}cf(z)=c\lim_{z\to z_0}f(z)$ 。</li><li>$$\lim_{z\to z_0}(f(z) g(z))=\lim_{z\to z_0}f(z)\cdot \lim_{z\to z_0}g(z)$$ 。</li><li>若 $\lim_{z\to z_0}g(z)\neq 0$ ，则存在 $\delta &gt;0$ ，使对 $S$ 上一切满足 $0&lt;|z-z_0|&lt;\delta$ 的 $z$ ，有 $g(z)\neq 0$ ，进一步， $\lim_{z\to z_0}[g(z)]^{-1}=(\lim_{z\to z_0}g(z))^{-1}$ 。</li></ol><p>连续函数：设 $f(z)$ 为定义在 $S$ 上的函数， $z_0$ 为 $S$ 上的一点，若 $\lim_{z\to z_0}f(z)=f(z_0)$ ，则称 $f(z)$ 在点 $z_0$ 连续。若 $f(z)$ 在 $S$ 上的每一点都连续，则称 $f(z)$ 为 $S$ 上的连续函数。</p><p>定理：函数 $f(z)$ 在点 $z_0$ 连续的充分必要条件是 $f(z)$ 的实部 $u(x,y)$ 和虚部 $v(x,y)$ 作为二元实函数在点 $(x_0,y_0)$ 都连续。</p><p>定理：设函数 $f$ 和 $g$ 都在 $S$ 上连续， $c$ 为复常数，则</p><ol><li>函数 $f(z)+g(z)$ ， $cf(z)$ 以及 $f(z)g(z)$ 都在 $S$ 上连续。</li><li>若 $g(z)\neq 0$ ，则函数 $\dfrac{f(z)}{g(z)}$ 在 $S$ 上连续。</li></ol><p>定理：设 $f$ 和 $g$ 分别为定义在 $S$ 与 $S^{\prime}$ 上的连续函数，且 $f$ 的值域包含于 $S^{\prime}$ ，则 $g(f(z))$ 为 $S$ 上的连续函数。</p><p>定理：定义在有界闭区域 $\overline{D}$ 上的连续函数 $f(z)$ ，其模 $|f(z)|$ 必在 $\overline{D}$ 上达到最大值与最小值。</p><h3 id="复变函数的导数和解析函数"><a href="#复变函数的导数和解析函数" class="headerlink" title="复变函数的导数和解析函数"></a>复变函数的导数和解析函数</h3><p>复变函数的导数：设 $f(z)$ 为定义在区域 $D$ 内的函数， $z_0$ 为 $D$ 内一点，如果极限</p><p>$$<br>\lim_{\Delta z\to 0}\dfrac{f(z_0+\Delta z)-f(z_0)}{\Delta z}<br>$$</p><p>存在有限，则称 $f(z)$ 在 $z_0$ 点可导。该极限称为 $f(z)$ 在 $z_0$ 点的导数，记作 $f^{\prime}(z_0)$ 或 $\frac{\mathrm{d}f}{\mathrm{d}z}(z_0)$ ，即</p><p>$$<br>\dfrac{\mathrm{d}f}{\mathrm{d}z}(z_0)=f^{\prime}(z_0)=\lim_{\Delta z\to 0}\dfrac{f(z_0+\Delta z)-f(z_0)}{\Delta z}<br>$$</p><p>如果 $f(z)$ 在区域 $D$ 内每点都可导，就称 $f(z)$ 在区域 $D$ 内可导。此时， $f^{\prime}(z)$ 可看作定义在 $D$ 内的函数，称为 $f(z)$ 的导函数，简称导数。</p><p>复变函数的导数与实函数有许多类似的性质：</p><ul><li>线性性</li><li>积的求导法则</li><li>商的求导法则</li><li>复合函数求导链式法则</li><li>可导必然连续</li></ul><p>反函数求导法则：设 $w=f(z)$ 与 $z=\varphi(w)$ 是两个互为反函数的单值可导函数，则 $f^{\prime}(z)\neq 0$ ， $\varphi^{\prime}(w)\neq 0$ ，且 $f^{\prime}(z)=\frac{1}{\varphi^{\prime}(f(z))}$ 。</p><p>在一元实函数的反函数求导法则中，导数不为0是定理的条件，而在复变函数中，导数不为0是结论。这一点的证明需要用到 Rouche 定理。</p><p>柯西-黎曼方程：设 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 为定义在区域 $D$ 的函数，且在 $z=x+\mathrm{i}y\in D$ 处处可导，则</p><p>$$<br>f^{\prime}(z)=\lim_{\Delta z\to 0}\dfrac{f(z+\Delta z)-f(z)}{\Delta z}<br>$$</p><p>记 $\Delta z = \Delta x+\mathrm{i}\Delta y$ ，则</p><p>$$<br>f(z+\Delta z)-f(z)=[u(x+\Delta x,y+\Delta y)-u(x,y)]+\mathrm{i}[v(x+\Delta x,y+\Delta y)-v(x,y)]=\Delta u+\mathrm{i}\Delta v<br>$$</p><p>分别沿平行于实轴和虚轴的方向取极限，可得</p><p>$$<br>f^{\prime}(z)=\lim_{\Delta x\to 0}\dfrac{\Delta u+\mathrm{i}\Delta v}{\Delta x}=u_x+\mathrm{i}v_x \\ f^{\prime}(z)=\lim_{\Delta y\to 0}\dfrac{\Delta u+\mathrm{i}\Delta v}{\Delta y}=u_y+\mathrm{i}v_y<br>$$</p><p>比较实部与虚部有</p><p>$$<br>\frac{\partial u}{\partial x}=\frac{\partial v}{\partial y},\frac{\partial u}{\partial y}=-\frac{\partial v}{\partial x}<br>$$</p><p>这就是著名的柯西-黎曼方程。</p><p>定理：设函数 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 定义在区域 $D$ 内， $f(z)$ 在 $z=x+\mathrm{i}y\in D$ 处可导的必要条件是其实部函数 $u(x,y)$ 和虚部函数 $v(x,y)$ 在点 $(x,y)$ 偏导数存在，并且在该点满足柯西-黎曼方程。进一步，当 $f(z)$ 在 $z=z+\mathrm{i}y$ 处可导时，其导数可表达为 $f^{\prime}(z)=u_x+\mathrm{i}v_x=v_y-\mathrm{i}u_y$ 。</p><p>定理：设函数 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 定义在区域 $D$ 内， $f(z)$ 在 $z=x+\mathrm{i}y\in D$ 处可导的充分必要条件是 $u(x,y)$ 和 $v(x,y)$ 在点 $(x,y)$ 可微，并且在该点满足柯西-黎曼方程。</p><p>解析函数：如果 $f(z)$ 在点 $z_0$ 的某个邻域处处可导，则称 $f(z)$ 在点 $z_0$ 解析。若 $f(z)$ 在复平面的子集 $S$ 上的每一点都解析，则称 $f(z)$ 在 $S$ 上解析，或称 $f(z)$ 为 $S$ 上的解析函数。</p><p>定理：设函数 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 在区域 $D$ 内有定义， $f(z)$ 在 $z_0\in D$ 处解析的充分必要条件是存在点 $z_0$ 的一个邻域，使得 $u(x,y)$ 和 $v(x,y)$ 在该邻域内处处可微并且满足柯西-黎曼方程。</p><p>定理：设函数 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ ，则 $f(z)$ 在区域 $D$ 内解析的充分必要条件是 $u(x,y)$ 和 $v(x,y)$ 在区域 $D$ 内处处可微，并且柯西-黎曼方程在区域 $D$ 内处处成立。</p><p>定理：设 $f(z)$ 在区域 $D$ 内解析且 $f^{\prime}(z)\equiv 0$ ，则 $f(z)$ 为常值函数。</p><p>推论：设 $f(z)$ 在区域 $D$ 内解析且 $|f(z)|$ 为常数，则 $f(z)$ 是区域 $D$ 内的常值函数。</p><h3 id="初等函数"><a href="#初等函数" class="headerlink" title="初等函数"></a>初等函数</h3><p>指数函数：对复数 $z=x+\mathrm{i}y$ ，规定指数函数为</p><p>$$<br>\mathrm{e}^z=\mathrm{e}^{x+\mathrm{i}y}=\mathrm{e}^x \mathrm{e}^{\mathrm{i}y}=\mathrm{e}^x(\cos y+ \mathrm{i} \sin y)<br>$$</p><p>单叶性区域：设 $f(z)$ 为定义在区域 $D$ 内的函数，如果对于任何 $z_1,z_2 \in D$ ，只要 $z_1 \neq z_2$ ，就有 $f(z_1)\neq f(z_2)$ ，则称 $f(z)$ 在 $D$ 内是单叶的，区域 $D$ 称为 $f(z)$ 的单叶性区域。</p><p>对数函数：对一切非零复数 $z$ ，定义对数函数为</p><p>$$<br>\mathrm{Ln}z=\ln{|z|}+\mathrm{i}\mathrm{Arg}z<br>$$</p><p>对于一个给定的整数 $k$ ，记</p><p>$$<br>\mathrm{Ln}_k z=\ln{|z|}+\mathrm{i}(\mathrm{arg}z+2k\pi)<br>$$</p><p>称为对数函数 $\mathrm{Ln}z$ 的一个单值分支函数。</p><p>定义：称 $\mathrm{Ln}_0 z$ 为对数函数的主值，记为 $\ln{z}$ ，即</p><p>$$<br>\ln{z}=\ln{|z|}+\mathrm{i} \mathrm{arg}z<br>$$</p><p>定理：对数函数的每个单值分支函数在复平面去掉原点和负实轴的区域内解析。</p><p>三角函数：记</p><p>$$<br>\sin z = \dfrac{\mathrm{e}^{\mathrm{i}z}-\mathrm{e}^{-\mathrm{i}z}}{2},\cos z = \dfrac{\mathrm{e}^{\mathrm{i}z}+\mathrm{e}^{-\mathrm{i}z}}{2}<br>$$</p><p>分别称为复变量 $z$ 的正弦函数和余弦函数。</p><p>注意：在复平面上，正弦函数和余弦函数无界，正弦函数和余弦函数解析，零点个数没有增加。</p><p>双曲函数：对一切的复数 $z$ ，规定</p><p>$$<br>\sin z = \dfrac{\mathrm{e}^{z}-\mathrm{e}^{-z}}{2},\cos z = \dfrac{\mathrm{e}^{z}+\mathrm{e}^{-z}}{2}<br>$$</p><p>分别称为 $z$ 的双曲正弦和双曲余弦。</p><p>幂函数：设 $a$ 为复常数，定义 $w=z^a=\mathrm{e}^{a\mathrm{Ln}z},z\neq 0$ ，称为 $z$ 的幂函数，当对数 $\mathrm{Ln} z$ 取主值 $\ln{z}$ 时，函数 $\mathrm{e}^{a\mathrm{Ln}z}$ 称为幂函数的主值。</p><p>反三角函数</p><h3 id="复变函数的积分"><a href="#复变函数的积分" class="headerlink" title="复变函数的积分"></a>复变函数的积分</h3><p>复积分：设 $C$ 是区域 $D$ 内一条有向的简单曲线，起点为 $A$ ，终点为 $B$ ， $f(z)$ 为定义在 $D$ 内的函数。在 $C$ 上从 $A$ 向 $B$ 依次插入分点</p><p>$$<br>A=z_0,z_1,\cdots,z_n=B<br>$$</p><p>将该曲线 $C$ 分割成 $n$ 个小弧段。在每一个从 $z_{k-1}$ 到 $z_k$ 的小弧段上任取一点 $\zeta_k$ ，记 $\Delta z_k=z_k-z_{k-1}$ ，以及 $\lambda=\max \{ |\Delta z_k| : k=1,2,\cdots,n\}$ 为所有小线段的最大长度，如果极限</p><p>$$<br>\lim_{\lambda\to 0}\sum_{k=1}^{n}f(\zeta_k)\Delta z_k<br>$$</p><p>不依赖与曲线 $C$ 的分割方法和点 $\zeta_k$ 的取法而存在，则该极限为 $f(z)$ 沿曲线 $C$ 的复积分。</p><p>复积分的运算性质：</p><ol><li>线性性</li><li>逐段积分</li><li>记 $C^{-}$ 为 $C$ 的反向曲线，则 $\int_{C^{-}}f(z)\mathrm{d}z=\int_{C}f(z)\mathrm{d}z$ 。</li></ol><p>定理：对任意 $z_0 \in C$ ，以及正数 $\rho$ 和整数 $n$ ，有</p><p>$$<br>\int_{|z-z_0|=\rho}\dfrac{\mathrm{d}z}{(z-z_0)^n}=\begin{cases} 2\pi \mathrm{i} ,n=1 \\ 0,n\neq 1\end{cases}<br>$$</p><p>这里积分曲线 $|z-z_0|=\rho$ 取逆时针方向。</p><p>复变函数关于弧长的积分：设 $C$ 是一段光滑曲线，函数 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 在 $C$ 上连续，定义函数 $f(z)$ 关于弧长的积分为</p><p>$$<br>\int_{C}f(z)\mathrm{d}s=\int_{C}u(x,y)\mathrm{d}x+\mathrm{i}\int_{C}v(x,y)\mathrm{d}s<br>$$</p><p>若曲线 $C$ 的参数方程为 $z(t)=x(t)+\mathrm{i}y(t),(\alpha\leq t \leq \beta)$ ，由于 $\mathrm{d}z=\mathrm{d}x+\mathrm{i}\mathrm{d}y$ ，所以弧长微分</p><p>$$<br>\mathrm{d}s=\sqrt{(\mathrm{d}x)^2+(\mathrm{d}y)^2}=|\mathrm{d}z|=|z^{\prime}(t)|\mathrm{d}t<br>$$</p><p>则有</p><p>$$<br>\int_{C}f(z)\mathrm{d}s=\int_{\alpha}^{\beta}f(z(t))|z^{\prime}(t)|\mathrm{d}t<br>$$</p><p>定理：设 $C$ 为简单有向曲线， $f(z)$ 在包含 $C$ 的一个区域内连续，则</p><p>$$<br>|\int_C f(z)\mathrm{d}z|\leq \int_C|f(z)|\mathrm{d}s<br>$$</p><p>特别的，记 $C$ 的长度为 $\mathrm{Length}(C)$ ，且在 $C$ 上有 $|f(z)|\leq M$ ，则</p><p>$$<br>|\int_C f(z)\mathrm{d}z|\leq M\cdot \mathrm{Length}(C)<br>$$</p><p>复积分与路径无关：设 $f(z)$ 为定义在区域 $D$ 内的函数，所谓积分 $f(z)$ 在 $D$ 内与路径无关是指对 $D$ 内任意给定的两点 $z_1,z_2$ ，以及 $D$ 内任意两条连接起点为 $z_1$ 终点为 $z_2$ 的简单曲线 $C$ ，都有 $\int_C f(z)\mathrm{d}z=0$ 。</p><p>定理：设 $f(z)$ 为定义在区域 $D$ 内的连续函数，则以下事实等价：</p><ol><li>$f(z)$ 在 $D$ 内与路径无关。</li><li>对 $D$ 内任一简单闭曲线 $C$ ，都有 $\int_C f(z)\mathrm{d}z=0$ 。</li><li>在 $D$ 内存在函数 $F(z)$ ，使得 $f(z)=F^{\prime}(z)$ （此时称 $F(z)$ 为 $f(z)$ 在区域 $D$ 内的一个函数）。</li></ol><p>复积分的牛顿莱布尼兹公式：设 $f(z)$ 为定义在区域 $D$ 内连续函数，且在 $D$ 内存在原函数 $F(z)$ ，则对任何 $z_1,z_2\in D$ 以及连接 $z_1,z_2$ 的曲线 $C$ ，有</p><p>$$<br>\int_C f(z)\mathrm{d}z=F(z_2)-F(z_1)<br>$$</p><h3 id="柯西积分公式"><a href="#柯西积分公式" class="headerlink" title="柯西积分公式"></a>柯西积分公式</h3><p>格林公式：设 $D$ 为有界区域， $P(x,y),Q(x,y)$ 在 $D$ 上有一阶连续偏导数，则</p><p>$$<br>\int_{\partial D} P\mathrm{d}x+Q\mathrm{d}y=\iint_{D}(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\mathrm{d}x\mathrm{d}y)<br>$$</p><p>这里 $\partial D$ 为区域 $D$ 的正向边界。</p><p>柯西积分定理：设 $D$ 为有界区域， $f(z)$ 在 $D$ 内解析，在 $\overline{D}$ 上连续，则有 $\int_{\partial D}f(z)\mathrm{d}z=0$ ，这里 $\partial D$ 为区域 $D$ 的正向边界。</p><p>定理：设 $D$ 为单连通区域， $f(z)$ 在 $D$ 内解析， $C$ 为 $D$ 内任一条简单闭曲线，则有 $\int_{C}f(z)\mathrm{d}z=0$ ，从而 $f(z)$ 在 $D$ 内积分与路径无关。</p><p>解析函数的平均值性质：设 $f(z)$ 在区域 $D$ 内解析，则对一切 $z_0\in D$ ，以及满足 $\{ |z-z_0|\leq R \}\subset D$ 的正数 $R$ ，有</p><p>$$<br>f(z_0)=\dfrac{1}{2\pi}\int_{0}^{2\pi} f(z_0+R\mathrm{e}^{\mathrm{i}\theta})\mathrm{d}\theta<br>$$</p><p>柯西积分公式：设 $D$ 为有界区域，若 $f(z)$ 在 $D$ 内解析，在 $\overline{D}$ 上连续，则对一切 $z_0\in D$ ，</p><p>$$<br>f(z_0)=\dfrac{1}{2\pi \mathrm{i}}\int_{\partial D}\dfrac{f(z)}{z-z_0}\mathrm{d}z<br>$$</p><p>这里 $\partial D$ 为区域 $D$ 的正向边界。</p><p>定理：设函数 $f(z),g(z)$ 都在有界区域 $D$ 内解析，在 $\overline{D}$ 上连续，且当 $z\in \partial D$ 时有 $f(z)=g(z)$ 则当 $z\in \overline{D}$ 时， $f(z)=g(z)$ 。</p><p>柯西高阶导数公式：设 $D$ 为有界区域，且 $f(z)$ 在 $D$ 内解析，在 $\overline{D}$ 上连续，则对一切 $z_0\in D$ 和正整数 $n$ ，有</p><p>$$<br>f^{(n)}(z_0)=\dfrac{n!}{2\pi \mathrm{i}}\int_{\partial D}\dfrac{f(z)}{(z-z_0)^{n+1}}\mathrm{d}z<br>$$</p><p>这里 $\partial D$ 为区域 $D$ 的正向边界。</p><p>定理：设 $f(z)$ 为定义在区域 $D$ 内的连续函数，且 $f(z)$ 在 $D$ 内积分与路径无关，则 $f(z)$ 在 $D$ 内解析。</p><p>定理：有界整函数必定是常值函数。</p><p>皮卡小定理：非常值函数，其值域只有两种类型，全体复数或全体复数除去一个值。</p><p>代数学基本定理：任何复系数多项式方程在复平面上至少有一个根。</p><h3 id="调和函数"><a href="#调和函数" class="headerlink" title="调和函数"></a>调和函数</h3><p>调和函数：设二元实函数 $H(x,y)$ 在平面区域 $D$ 内有二阶连续的偏导数，且满足拉普拉斯方程</p><p>$$<br>\frac{\partial^2 H}{\partial x^2}+\frac{\partial^2 H}{\partial y^2}=\Delta H=0<br>$$</p><p>则称其为 $D$ 内的调和函数。</p><p>共轭调和函数：若二元实函数 $u(x,y),v(x,y)$ 都是区域 $D$ 内的调和函数，且满足柯西黎曼方程，则称 $v(x,y)$ 为 $u(x,y)$ 的共轭调和函数。</p><p>注意：共轭调和函数不具有自反性。</p><p>定理：复变函数 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 在区域 $D$ 内解析的充分必要条件是 $u(x,y)$ 与 $v(x,y)$ 都在区域 $D$ 内调和，且 $v(x,y)$ 为 $u(x,y)$ 的共轭调和函数。</p><p>定理：对一切定义在单连通区域 $D$ 的调和函数 $u(x,y)$ ，由下式定义的函数</p><p>$$<br>v(x,y)=\int_{(x_0,y_0)}^{(x,y)}-u_y\mathrm{d}x+u_x\mathrm{d}y+c<br>$$</p><p>恰为 $u$ 在 $D$ 内的共轭调和函数，这里 $c$ 为任意实数。</p><p>定理：设 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 在区域 $D$ 内解析，取值在区域 $D_1$ 中， $h(x,y)$ 在区域 $D_1$ 内调和，则 $h(u(x,y),v(x,y))$ 在区域 $D$ 内调和。</p><p>调和函数的平均值性质：设 $u(x,y)$ 在区域 $D$ 内调和，则对一切 $z_0=x_0+\mathrm{i}y_0\in D$ ，以及满足 ${\overline{B_r}} {(z_0)}\subset D$ 的正数 $r$ ，有</p><p>$$<br>u( x_0 , y_0 )=\dfrac{1}{2\pi}\int_{0}^{2\pi}u( x_0+r\cos \theta, y_0+r\sin \theta)\mathrm{d}\theta<br>$$</p><p>极值原理：设 $u(x,y)$ 在有界区域 $D$ 内调和，在 $\overline{D}$ 上连续，若 $u$ 在 $\overline{D}$ 上的最大值或最小值在 $\overline{D}$ 的内部取到，则 $u$ 必定为 $\overline{D}$ 上的常数函数。</p><p>引理：若非负函数 $f(x)$ 在 $[a,b]$ 上连续，且 $\int_{a}^{b}f(x)\mathrm{d}x=0$ ，则 $f(x)$ 在 $[a,b]$ 上恒为零。</p><p>最大模原理：设 $f(z)$ 在有界区域 $D$ 内解析，在 $\overline{D}$ 上连续，若 $|f(z)|$ 在 $\overline{D}$ 上的最大值在 $D$ 的内部取到，则 $|f(z)|$ 必定为常数函数。</p><p>定理：在平面上调和并且有上界（或下界）的调和函数，必定是常值函数。</p><h2 id="解析函数的级数理论与留数定理"><a href="#解析函数的级数理论与留数定理" class="headerlink" title="解析函数的级数理论与留数定理"></a>解析函数的级数理论与留数定理</h2><h3 id="复数列的级数与幂级数"><a href="#复数列的级数与幂级数" class="headerlink" title="复数列的级数与幂级数"></a>复数列的级数与幂级数</h3><p>级数：给定复数列 $\{ z_k \}$ ，其前 $k$ 项之和记为</p><p>$$<br>S_k=z_1+z_2+\cdots+z_k<br>$$</p><p>数列 $\{ S_k \}$ 的极限记为 $\sum_{k=1}^{\infty}z_k$ ，称为级数， $S_k$ 称为级数 $\sum_{k=1}^{\infty}z_k$ 的部分和。若部分和数列 $\{ S_k \}$ 收敛，则称级数 $\sum_{k=1}^{\infty}z_k$ 收敛，否则称级数 $\sum_{k=1}^{\infty}z_k$ 发散。</p><p>定理：复数项级数 $\sum_{k=1}^{\infty}z_k$ 收敛的充分必要条件是实数项级数 $\sum_{k=1}^{\infty}x_k$ 和 $\sum_{k=1}^{\infty}y_k$ 同时收敛。</p><p>定理：若 $\sum_{k=1}^{\infty}z_k$ 收敛，则 $\lim_{k\to \infty}z_k=0$ ，即 $\lim_{k\to \infty}|z_k|=0$ 。</p><p>绝对收敛：对复数项级数 $\sum_{k=1}^{\infty}z_k$ ，若正项级数 $\sum_{k=1}^{\infty}|z_k|$ 收敛，则称 $\sum_{k=1}^{\infty}z_k$ 绝对收敛。</p><p>定理：若 $\sum_{k=1}^{\infty}z_k$ 绝对收敛，则 $\sum_{k=1}^{\infty}z_k$ 收敛。</p><p>和函数：设 $\{ f_k(z) \}$ 为定义在区域 $D$ 内的函数序列，则对每个固定的 $z$ ，当 $\sum_{k=0}^{\infty}f_k(z)$ 作为数项级数收敛时，记其和为 $S(z)$ ，于是 $S(z)$ 为定义在使得级数 $\sum_{k=0}^{\infty}f_k(z)$ 收敛的点集上的函数，称为函数项级数 $\sum_{k=0}^{\infty}f_k(z)$ 的和函数。</p><p>幂级数：函数项级数 $\sum_{k=0}^{\infty}c_k(z-z_0)^k$ 称为以 $z_0$ 为中心的幂级数，这里 $c_k$ 为复常数，并约定 $(z-z_0)^0=1$ 。</p><p>定理：如果 $\sum_{k=0}^{\infty}c_kz^k$ 在非零点 $z_0$ 收敛，则在区域 $\{ |z| &lt; |z_0| \}$ 内，幂级数 $\sum_{k=0}^{\infty}c_kz^k$ 绝对收敛，如果 $\sum_{k=0}^{\infty}c_kz^k$ 在 $z_0$ 点发散，则在区域 $\{ |z| &gt; |z_0| \}$ 内，幂级数 $\sum_{k=0}^{\infty}c_kz^k$ 发散。</p><p>考虑实数集合</p><p>$$<br>S=\{ r|\text{当}|z-z_0|&lt;r\text{时，级数} \sum_{k=0}^{\infty}c_k(z-z_0)^k \}<br>$$</p><p>可以证明 $S$ 只可能是三种情形：空集，有界半闭区间 $(0,b]$ 和 $(0,+\infty)$ 。</p><p>记 $R$ 为 $S$ 的最小上界，称为幂级数 $\sum_{k=0}^{\infty}c_k(z-z_0)^k$ 的收敛半径，约定 $S$ 为空集时，$R=0$ ,$S$ 为 $(0,+\infty)$ 时， $R=+\infty$ 。此时 $\{ |z-z_0|&lt;R \}$ 称为幂级数 $\sum_{k=0}^{\infty}c_k(z-z_0)^k$ 的收敛圆盘。</p><p>定理：幂级数 $\sum_{k=0}^{\infty}c_k(z-z_0)^k$ 在收敛圆盘的内部处处绝对收敛，在收敛圆盘的外部处处发散。</p><p>定理：对幂级数 $\sum_{k=0}^{\infty}c_kz^k$ ，若极限 $\lambda =\lim_{k\to \infty}|c_k|^{\frac{1}{k}}$ 存在，则该幂级数的收敛半径 $R\frac{1}{\lambda}$ 。</p><p>定理：对幂级数 $\sum_{k=0}^{\infty}c_kz^k$ ，若极限 $\lambda =\lim_{k\to \infty}|\frac{c_{k+1}}{c_k}|$ 存在，则该幂级数的收敛半径 $R=\frac{1}{\lambda}$ 。</p><p>定理：设幂级数 $\sum_{k=0}^{\infty}c_k(z-z_0)^k$ 的收敛半径为 $R$ ，则其和函数 $S(z)$ 满足：</p><ol><li>在收敛圆盘内可逐项求极限，即 $\lim_{z\to z_1}S(z)=\sum_{k=0}^{\infty}c_k(z-z_0)^k$ ，其中 $|z_1-z_0|&lt;R$ 。</li><li>在收敛圆盘内可逐项求导，且逐项求导不改变收敛半径，特别， $S(z)$ 在收敛圆盘内部解析， $S^{\prime}(z)=\sum_{k=1}^{\infty}\dfrac{c_k}{k+1}(z-z_0)^{k+1}$ 。</li><li>在收敛圆盘内可逐项积分，且逐项积分不改变收敛半径，即<br>$$<br>\int_{z_0}^{z}S(\zeta)\mathrm{d}\zeta = \sum_{k=0}^{\infty}\dfrac{c_k}{k+1}(z-z_0)^{k+1}<br>$$<br>其中 $|z-z_0|&lt;R$ 。</li></ol><h3 id="泰勒级数"><a href="#泰勒级数" class="headerlink" title="泰勒级数"></a>泰勒级数</h3><p>定理：设 $f(z)$ 在区域 $D$ 内解析， $z_0$ 为 $D$ 内一点，则只要圆盘 $\{ \vert z-z_0 \vert &lt;R \}\subset D$ ，就有</p><p>$$<br>f(z)=\sum_{n=0}^{\infty}a_n(z-z_0)^n<br>$$</p><p>在该圆盘上成立，其中 $a_n=\dfrac{f^{(n)}(z_0)}{n!}$ ，称为 $f(z)$ 在点 $z_0$ 处的泰勒系数，该级数称为 $f(z)$ 在圆盘 $\{ \vert z-z_0 \vert &lt;R \}$ 内的泰勒级数。</p><p>定理：若 $f(z)$ 在 $z_0$ 点的某个邻域内可展开称幂级数，则该幂级数只能是 $f(z)$ 在 $z_0$ 点的泰勒级数，即解析函数在一点的幂级数表达式唯一。</p><p>几个初等函数的泰勒级数：</p><p>$$<br>\mathrm{e}^z=\sum_{n=0}^{\infty}\dfrac{z^n}{n!}<br>$$</p><p>$$<br>\sin z = \sum_{n=0}^{\infty}\dfrac{(-1)^n}{(2n+1)!z^{2n+1}}<br>$$</p><p>$$<br>\cos z = \sum_{n=0}^{\infty}\dfrac{(-1)^n}{(2n)!z^{2n}}<br>$$</p><p>$$<br>\operatorname{Ln}_k(1+z)=\operatorname{ln}(1+z)+\mathrm{i}2k\pi = \mathrm{i}2k\pi+\sum_{n=0}^{\infty}(-1)^n\dfrac{z^{n+1}}{n+1},\vert z \vert &lt;1,k=0,\pm 1,\pm 2,\cdots<br>$$</p><p>零点：设函数 $f(z)$ 在点 $z_0$ 有定义且 $f(z_0)=0$ ，则称 $z_0$ 为 $f(z)$ 的零点。</p><p>定义：若 $z_0$ 是解析函数 $f(z)$ 的零点，且 $f(z)$ 在点 $z_0$ 的泰勒系数不全为零，即存在正整数 $m$ ，使得 $f^{(m)}(z_0)$ 且 $f(z_0)=f^{\prime}(z_0)=\cdots =f^{(m-1)}(z_0)=0$ ，则称 $z_0$ 为 $f(z)$ 的 $m$ 重零点， $m$ 称为零点 $z_0$ 的重数。当 $z_0$ 的重数为 $1$ 时， $z_0$ 也称为 $f(z)$ 的单零点。</p><p>定理：解析函数 $f(z)$ 以 $z_0$ 为 $m$ 重当且仅当存在 $z_0$ 点邻域 $B_{\delta}(z_0)=\{ \vert z-z_0 \vert &lt;\delta \}$ ，在该邻域， $f(z)$ 可以表示为</p><p>$$<br>f(z)=(z-z_0)^m\varphi(z)<br>$$</p><p>其中 $\varphi(z)$ 在 $z_0$ 点解析，且 $\varphi(z)$ 在该邻域内恒不为零。特别， $f(z)$ 在该邻域内只有 $z_0$ 一个零点，此时称 $z_0$ 作为 $f(z)$ 的零点是孤立的。</p><p>定理：不恒为零的解析函数的零点一定是孤立的。</p><p>定理：设 $f_1(z)$ 和 $f_2(z)$ 均在区域 $D$ 内解析， $\{ z_n \}$ 为 $D$ 中收敛到 $D$ 内一点 $z_0$ 的点列，这里 $z_n\neq z_0$ ，若在点列 $\{ z_n \}$ 上  ，则在 $D$ 内有 $f_1(z)\equiv f_2(z)$ 。</p><h3 id="洛朗级数"><a href="#洛朗级数" class="headerlink" title="洛朗级数"></a>洛朗级数</h3><p>洛朗级数：具有如下形式的级数</p><p>$$<br>\sum_{n=-\infty}^{+\infty}c_n(z-z_0)^n+\sum_{n=0}^{+\infty}c_n(z-z_0)^n<br>$$</p><p>称为洛朗级数，其中 $c_n$ 和 $z_0$ 是复常数。</p><h2 id="积分变换"><a href="#积分变换" class="headerlink" title="积分变换"></a>积分变换</h2><h2 id="共形映照"><a href="#共形映照" class="headerlink" title="共形映照"></a>共形映照</h2>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>纯数学</category>
      
      <category>分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实变函数</title>
    <link href="/archives/3178e13f.html"/>
    <url>/archives/3178e13f.html</url>
    
    <content type="html"><![CDATA[<p>这是门要学十遍的课。写这篇笔记纯属兴趣使然，不过由于作业越来越多，估计很长时间无法更新笔记，而且我感觉参考的实变函数的教材十分难懂（可能只是因为我比较菜），回头看看有没有相对简单易懂的教材。</p><span id="more"></span><h1 id="实变函数"><a href="#实变函数" class="headerlink" title="实变函数"></a>实变函数</h1><h2 id="集合与关系"><a href="#集合与关系" class="headerlink" title="集合与关系"></a>集合与关系</h2><h3 id="集合及其运算"><a href="#集合及其运算" class="headerlink" title="集合及其运算"></a>集合及其运算</h3><p>集合的表示：枚举法，描述法。</p><p>广义实数系：以 $\overline{\mathbb{R}}$ 表示全体实数与正无穷大 $+ \infty$ 和负无穷大 $- \infty$ 所成之集，称为广义实数系。</p><p>子集：以 $A\subset B$ 或 $B\supset A$ 表示集合 $A$ 是集合 $B$ 的真子集。以 $A\subseteq B$ 或 $B\supseteq A$ 表示 $A$ 是 $B$ 的子集或 $B$ 是 $A$ 的超集。</p><p>$$\mathbb{N}\subset \mathbb{Z}\subset \mathbb{Q}\subset \mathbb{R}\subset \mathbb{C}\subset \mathbb{H}$$</p><p>子集的性质：</p><ul><li>空集是任何集合的子集： $\emptyset \subseteq A$ 。</li><li>自反性：当 $A$ 是集合时， $A\subseteq A$ 。</li><li>反称性：当 $A\subseteq B$ 且 $B\subseteq A$ 时， $A=B$ 。</li><li>传递性：当 $A\subseteq B$ 且 $B\subseteq C$ 时， $A\subseteq C$ 。</li><li>上定向性：当 $A$ 和 $B$ 是集合时，有集合 $C$ 使 $A\subseteq C$ 且 $B\subseteq C$ 。</li><li>下定向性：当 $A$ 和 $B$ 是集合时，有集合 $C$ 使 $A\supseteq C$ 且 $B\supseteq C$ 。</li></ul><p>有限个集合的运算：<br>集合的交，并，差运算。</p><p>对称差： $A\Delta B=(A-B)\cup (B-A)$ 。</p><p>运算律：</p><ul><li>零元律：<br>$$A\cup \emptyset = A-\emptyset =A,A\cap \emptyset =\emptyset$$</li><li>交换律：<br>$$A\cup B=B\cup A,A\cap B=B\cap A,A\Delta B=B\Delta A$$</li><li>结合律：<br>$$(A\cup B)\cup C=A\cup (B\cup C)$$<br>$$(A\cap B)\cap C=A\cap (B\cap C)$$</li><li>分配律：<br>$$(A-B)\cap C=(A\cap C)-(B\cap C)$$</li><li>单调性：<br>$$(A_1\subseteq A_2)\wedge (B_2\subseteq B_1)\Rightarrow (A_1-B_1)\subseteq (A_2-B_2)$$</li></ul><p>集族的运算：</p><ul><li><p>幂等律：<br>$$\bigcup _{i\in I}A=A$$<br>其中 $I\neq \emptyset$ 且每个指标 $i\in I$ 对应的集合都是 $A$ 。</p><p>$$\bigcap _{i\in I}A=A$$</p><p>其中 $I\neq \emptyset$ 且每个指标 $i\in I$ 对应的集合都是 $A$ 。</p></li><li><p>对偶律：<br>$$B-\bigcup _{i\in I}A_i=\bigcap _{i\in I}(B-A_i)$$</p><p>$$B-\bigcap _{i\in I}A_i=\bigcup _{i\in I}(B-A_i)$$</p></li><li><p>结合律：<br>$$\bigcup _{i\in I}A_i=\bigcup _{j\in J}\bigcup _{i\in I_j}A_i,I=\bigcup _{j\in J}I_j$$</p><p>$$\bigcap _{i\in I}A_i=\bigcap _{j\in J}\bigcap _{i\in I_j}A_i,I=\bigcup _{j\in J}I_j$$</p></li><li><p>分配律：<br>$$B\cap (\bigcup \{ A_i | i\in I \})=\bigcup \{ B\cap A_i | i\in I \}$$</p><p>$$B\cap (\bigcap \{ A_i | i\in I \})=\bigcap \{ B\cap A_i | i\in I \}$$</p></li><li><p>单调性：<br>设 $A_i\subseteq B_i (i\in I)$ ，则</p><p>$$\bigcup _{i\in I}A_i\subseteq \bigcup _{i\in I} B_i,\bigcap _{i\in I}A_i\subseteq \bigcap _{i\in I} B_i$$</p></li></ul><p>补集：固定一个集合 $X$ 。当 $A\subseteq X$ 时，称 $X-A$ 为 $A$ 在 $X$ 中的补集或余集。这可以用 $A^c$ 表示。</p><p>无交并：$\bigsqcup$</p><p>集列的极限：</p><p>上限集：对于一般的集列 $\{ A_n \}$ ,称 ${\bigcap _{n=1}^{\infty}\bigcup _{k=n}^{\infty}A_k}$ 为 $\{ A_n \}$ 的上限集，记为 ${\lim _{n\rightarrow \infty} \sup A_n}$ 或 ${\lim _{n\rightarrow \infty} \sup A_n}$ 。</p><p>下限集：对于一般的集列 $\{ A_n \}$ ,称 ${\bigcup _{n=1}^{\infty}\bigcap _{k=n}^{\infty}A_k}$ 为 $\{ A_n \}$ 的下限集，记为 ${\lim _{n\rightarrow \infty} \inf A_n}$ 或 ${\lim _{n\rightarrow \infty} \inf A_n}$ 。</p><p>笛卡尔积：分量依次在 $X_1,X_2,\cdots ,X_n$ 中的 $n$ 元组所成的集合<br>$$<br>\prod_{i=1}^n X_i=X_1\times X_2\times \cdots \times X_n:=\{ (x_1,\cdots,x_n)| x_n\in X_n \}<br>$$<br>称为笛卡尔积。其中两个 $n$ 元组 $(x_1,\cdots,x_n)$ 与 $(y_1,\cdots,y_n)$ 相等是指他们的对应分量相等： $x_1=y_1, \cdots ,x_n=y_n $ 。</p><p>截口：子集 $G\subseteq X\times Y$ 在 $a\in X$ 处截口 $G_a$ 和在 $b\in Y$ 处截口 $G^b$ 为<br>$$<br>G_a=\{ y\in Y|(a,y)\in G \}<br>$$</p><p>$$<br>G^b=\{ x\in X|(x,b)\in G \}<br>$$</p><ol><li>截口保持单调性</li><li>截口保持并运算</li><li>截口保持较运算</li><li>截口保持差运算</li><li>若 $G\cap H=\emptyset$ ，则 $G_x\cap H_x =\emptyset$ 且 $G^y\cap H^y =\emptyset$ 。</li></ol><p>像集与原像集：设 $f:X\rightarrow Y$ 是映射，对于 $B\subseteq Y$ ，令 $f^{-1}(B)=\{ x\in X|f(x)\in B \}$ ，这称为 $B$ 在映射 $f$ 下的原像。对于 $A\subseteq X$ ，令 $f(A)=\{ f(x)|x\in A \}$ （即 $f(A)=\{ f(x)|x\in A \}$ ），这称为 $A$ 在映射 $f$ 下的像。记 $ran f=f(X)$ ，这是 $f$ 的值域。</p><ol><li>像集保持单调性</li><li>像集保持并运算</li><li>原像保持单调性</li><li>原像保持并运算</li><li>原像保持交运算</li><li>原像保持差运算</li><li>原像保持补运算</li><li>$f(A)\subseteq B$ 当且仅当 $A\subseteq f^{-1}(B)$ 。</li></ol><p>单射：设 $f$ 是由集合 $A$ 到集合 $B$ 的映射，如果所有 $x,y\in A$ ，且 $x\neq y$ ，都有 $f(x)\neq f(y)$ ，则称 $f$ 为由 $A$ 到 $B$ 的单射。</p><p>满射：设 $f$ 是由集合 $A$ 到集合 $B$ 的映射，如果所有 $y\in B$  ，都有 $\exists x\in A,f(x)=y$ ，则称 $f$ 为由 $A$ 到 $B$ 的满射。</p><p>双射：设 $f$ 是由集合 $A$ 到集合 $B$ 的映射，如果 $f$ 是单射又是满射，那么就是双射，也叫一一对应。</p><h3 id="三类常用关系"><a href="#三类常用关系" class="headerlink" title="三类常用关系"></a>三类常用关系</h3><p>关系：一些元素对 $(x,y)$ 构成的集合 $R$ 称为一个关系，此时记 $xRy$ 。</p><p>现在设 $R$ 是集合 $X$ 上的一个关系，这即 $R\subseteq X\times X$ 。</p><ol><li>自反性：$x\in X$，时 $xRx$ 。</li><li>对称性： $xRy$ 时， $yRx$ 。</li><li>传递性： $xRy$ 且 $yRz$ 时， $xRz$ 。</li><li>反称性： $xRy$ 且 $yRx$ 时， $x=y$ 。</li></ol><p>等价关系与划分：集合 $X$ 上具有自反性、对称性和传递性的关系 $R$ 称为等价关系。当 $xRy$ 时，记 $x\sim y$ ，称 $x$ 与 $y$ 等价。</p><ol><li>与 $x$ 等价的元素全体 $[x]$ 称为 $x$ 所在的等价类： $[x]=\{ y\in X|y\sim x \}$ 等价元素所在的等价类相同。不等价元素所在的等价类不相交。</li><li>等价关系 $\sim $ 的商集 $\{ [x]|x\in X \}$ 记为 $X/\sim $ 或 $\tilde{X}$ 。令 $\pi (x)=[x]$ ，得自然射影或商映射 $\pi :X\rightarrow \tilde{X}$ 使 $\pi (x_1)=\pi (x_2)$ 当且仅当 $x_1\sim x_2$ 。</li><li>每个映射 $f:X\rightarrow Y$ 都按照等值方式诱导 $X$ 上一个等价关系 $\sim $ 使 $x_1\sim x_2$ 表示 $f(x_1)=f(x_2)$ 。</li><li>等价关系 $\sim $ 确定的互异等价类全体记为 $[x_i]:i\in J$ ，则 $X=\bigcup_{i\in J}[x_i]$ 。<br>一般的，当集类 $\mathcal{D}$ 中成员都非空且相互不交而使 $X=\bigcup \mathcal{D}$ 时，称 $\mathcal{D}$ 是 $X$ 的一个划分。</li><li>集合 $X$ 上的关系 $R$ 是个等价关系当且仅当 $X$ 有唯一的划分 $\{ X_i|i\in I \}$ ，使 $xRy$ 表示 $x$ 与 $y$ 在同一个 $X_i$ 中。此时每个等价类恰好是某个 $X_i$ 。</li></ol><p>设 $\mathcal{D}$ 与 $\mathcal{D}^{\prime}$ 是 $X$ 的划分使 $\mathcal{D}$ 的成员 $A$ 都有划分 $\{ B\in \mathcal{D}^{\prime}|B\subseteq A \}$ ，称 $\mathcal{D}^{\prime}$ 是 $\mathcal{D}$ 的细分并记为 $\mathcal{D}^{\prime} \preceq \mathcal{D}$ 。细分有以下性质：</p><ul><li>自反性： $\mathcal{D}\preceq \mathcal{D}$ 。</li><li>反称性： $\mathcal{D}^{\prime} \preceq \mathcal{D}$ 且 $\mathcal{D} \preceq \mathcal{D}^{\prime}$ 时， $\mathcal{D}^{\prime} = \mathcal{D}$ 。</li><li>传递性： $\mathcal{D} \preceq \mathcal{D}^{\prime}$ 且 $\mathcal{D}^{\prime} \preceq \mathcal{D}^{\prime \prime}$ 时， $\mathcal{D} \preceq \mathcal{D}^{\prime \prime}$ 。</li><li>定向性： $\mathcal{D}$ 与 $\mathcal{D}^{\prime}$ 有细分 $$\mathcal{D}\vee \mathcal{D}^{\prime}:=\{ A\cap B | A\in \mathcal{D},B\in \mathcal{D} \} - \{ \emptyset  \}$$</li></ul><h3 id="对等集合与势"><a href="#对等集合与势" class="headerlink" title="对等集合与势"></a>对等集合与势</h3><p>对等：称 $X$ 与 $Y$ 是对等集合也称为等势集合是指它们是空集或有双射 $f:X\rightarrow Y$ 。此时，记 $X\sim Y$ 。对等集合具有相同的势。以 $|X|$ 表示 $X$ 的势。</p><ol><li>对等具有自反性： $X\sim X$ 。</li><li>对等具有对称性： $X\sim Y\Rightarrow Y\sim X$ 。</li><li>对等具有传递性： $X\sim Y,Y\sim Z\Rightarrow X\sim Z$ 。</li><li>笛卡尔积保持对等： $X_i\sim Y_i(i\in I)$ 时， $\prod X_i\sim \prod Y_i$ 。</li><li>无交并保持对等： $\bigsqcup X_i\sim \bigsqcup Y_i$ 在诸 $X_i\sim Y_i$ 时成立。</li><li>一般幂集保持对等： $X_1\sim X_2$ 且 $Y_1\sim Y_2$ 时， $Y_1^{X_1}\sim Y_2^{X_2}$ 。这里约定 $Y^X$ 表示 $X$ 至 $Y$ 的映射全体。</li></ol><p>令 $F_0=\emptyset$ 及 $F_n=F_{n-1}\cup \{n\}$ ，直观上它们只有有限个元素。</p><p>可数集：与某个 $F_n$ 对等的集合 $A$ 称为有限集，它的势用 $n$ 表示，也称 $n$ 为 $A$ 的基数。与自然数对等的集合称为可列集，它的势记为 $\aleph _{0}$ 。有限集与可列集统称为可数集。</p><ol><li>有限集的子集是有限集且有限集不与其真子集对应。</li><li>有限集的像集，两个有限集的并与笛卡尔积都是有限集。</li><li>可列集的子集与像集都是可数集。</li><li>有限个可列集的笛卡尔积与可列个可列集的并是可列集。</li></ol><p>康托-伯恩斯坦定理：设集合 $X$ 与集合 $Y$ 的一个子集对等且 $Y$ 也与 $X$ 的一个子集对等，则 $X$ 与 $Y$ 对等。</p><p>连续统：与实数系对等的集合称为连续统。所有长度非零的区间都是连续统。</p><p>集合 $A$ 是无限集当且仅当 $A$ 包含一个可列子集 $S$ 当且仅当 $A$ 与任何可数集之并与 $A$ 对等当且仅当 $A$ 与自身的一个真子集对等。</p><p>势的比较和运算：集合 $X$ 对于等于集合 $Y$ 的一个子集当且仅当有单射 $f:X\rightarrow Y$ 当且仅当有满射 $g:Y\rightarrow X$ ，此时记 $|X|\leq |Y|$ 。</p><ol><li>自反性： $|X|\leq |X|$ 。</li><li>反称性： $|X|\leq |Y|$ 且 $|Y|\leq |X|$ 时， $|X|=|Y|$ 。</li><li>传递性： $|X|\leq |Y|$ 且 $|Y|\leq |Z|$ 时， $|X|\leq |Z|$ 。</li><li>三歧性：两个势有且只有三种可能性（大于，小于，等于）。</li></ol><p>一般集合 $X$ 的幂集 $2^{X}$ 的势记为 $2^{|X|}$ 。</p><p>定理：任何集合 $X$ 满足势的不等式： $|X|&lt;2^{|X|}$ 。</p><p>连续统的势记为 $\aleph$ 并称为连续势，可列集的势记为 $\aleph _{0}$ 。在势的意义下，<br>$$<br>0&lt;1&lt;\cdots&lt;\aleph _{0}&lt;\aleph =2^{\aleph _{0}}<br>$$</p><p>Konig 不等式：设 $i\in I$ 时 $|A_i|&lt;|B_i|$ ，则 $| \bigcup_{i\in I}A_i |&lt;| \prod_{i\in I}B_i |$ 。</p><p>以 $\alpha$ 和 $\beta$ 分别记 $A$ 和 $B$ 的势。笛卡尔积 $A\times B$ 的势记为 $\alpha \beta$ 。当 $A\cap B=\emptyset$ 时，将 $A\bigsqcup B$ 的势记为 $\alpha+\beta$ 。两个集合之间的映射 $f:A\rightarrow B$ 全体 $B^A$ 的势记为 $\beta ^{\alpha}$ 。</p><ol><li>交换律： $\alpha+\beta=\beta +\alpha$， $\alpha \beta=\beta \alpha$ 。</li><li>零元律： $0+\alpha=\alpha$ ， $0 \alpha=0$ ， $\beta ^{0}=1$， $0^{\gamma}=0(\gamma &gt;0)$ 。</li><li>单位律： $1\alpha =\alpha$，$1^{\alpha} =1$， $\alpha ^1 =\alpha$ 。</li><li>结合律： $(\alpha+\beta)+\gamma=\alpha+(\beta+\gamma)$， $(\alpha\beta)\gamma=\alpha(\beta\gamma)$ 。</li><li>吸收律：如果 $\beta$ 是无限势而 $1\leq \alpha \leq \beta$ ，则 $\alpha+\beta=\alpha\beta=\beta$ 。</li><li>单调性：如果 $\alpha_1\leq \alpha_2$ 且 $\beta_{1}\leq \beta_{2}$ ，则 $\alpha _{1}^{\beta_1}\leq \alpha _{2}^{\beta_2}$ 。</li></ol><p>重要等式：</p><ol><li>设 $n$ 是正整数，则 $n+\aleph_0=n\aleph_0=\aleph_0^{n}=\aleph_0$ 。</li><li>设 $n$ 是正整数，则 $n\aleph=\aleph_0\aleph=\aleph^{n}=\aleph$ 。</li><li>设整数 $n\geq 2$ ，则 $n^{\aleph} =\aleph_0^{\aleph}=\aleph^{\aleph}=2^{\aleph}$ 。</li><li>设整数 $n\geq 2$ ，则 $n^{\aleph_0}=\aleph_0^{\aleph_0}=\aleph^{\aleph_0}=\aleph$ 。</li></ol><p>以 $\alpha_i$ ， $\beta_{i}$ 和 $\gamma_i$ 分别记 $A_i$ ， $B_i$ 和 $C_i$ 的势，则 $\prod_{i\in I}A_i$ 的势记为 $\prod_{i\in I}\alpha_i$ ，无交并 $\bigsqcup_{i\in I}A_i$ 的势记为 $\sum_{i\in I}\alpha_i$ 。约定 $\sum_{i\in \emptyset}\alpha_i=0$ 且 $\prod_{i\in \emptyset}=1$ 。</p><ol><li>完全次可加性： $|\cup_{i\in I}A_i|\leq \sum_{i\in I}|A_i|$ 。</li><li>结合律： $\sum_{i\in I}\gamma_i=\sum_{j\in J}\sum_{i\in I_j}\gamma_i$ ，其中 $I=\bigsqcup_{j\in J}I_j$ 。</li><li>分配律： $\alpha\sum_{i\in I}\gamma_i=\sum_{i\in I}\alpha\gamma_i$ 。</li><li>分解律： $\sum_{a\in A}\beta =\alpha\beta$ 及 $\prod_{a\in A}\beta =\beta^{\alpha}$ 。</li><li>单调性：<br>$$<br>\forall i\in I:\alpha_i\leq \beta_i\Rightarrow \sum_{i\in I}\alpha_i\leq \sum_{i\in I}\beta_i<br>$$<br>$$<br>\forall i\in I:\alpha_i\leq \beta_i\Rightarrow \prod_{i\in I}\alpha_i\leq \prod_{i\in I}\beta_i<br>$$</li></ol><h3 id="实数与无穷大"><a href="#实数与无穷大" class="headerlink" title="实数与无穷大"></a>实数与无穷大</h3><p>上确界与下确界：设 $S$ 是偏序集 $X$ 的非空子集， $S$ 的最小上界（若存在）称为 $S$ 的上确界，并记为 $\sup S$ 或 $\sup_{x\in S}x$ 。因此<br>$$<br>\sup S=\min \{ b\in X|\forall x\in S:x\leq b \}<br>$$<br>而 $S$ 的有最大下界（若存在）称为 $S$ 的下确界并记为 $\inf S$ 或 $\inf_{x\in S}x$ ，即<br>$$<br>\inf S=\max \{ a\in X|\forall x\in S:x\geq a \}<br>$$</p><ol><li>对偶律： $\sup (-A)=-\inf A$ 而 $\inf(-A)=-\sup A$ 。</li><li>单调性：如果 $A\subseteq B$ ，则 $\sup A\leq \sup B$ 且 $\inf B\leq \inf A$ 。</li><li>分配律： $\sup (\bigcup_{i\in I}A_i)=\sup_{i\in I}\sup A_i$ 且 $\inf (\bigcup_{i\in I}A_i)=\inf_{i\in I}\inf A_i$ 。</li><li>平移律： $\sup(x+B)=x+\sup B$ 在两边有意义时成立， $\inf(x+B)=x+\inf B$ 在两边有意义时成立。</li><li>分配律： $\sup(A+B)=\sup A+\sup B$ 在两边有意义时成立， $\inf(A+B)=\inf A+\inf B$ 在两边有意义时成立。</li></ol><p>定理：广义数集 $A$ 在广义实数系中有上确界 $\sup A$ 和下确界 $\inf A$ 。</p><p>上极限与下极限：广义实数序列 $(x_n)$ 有上极限<br>$$<br>\varlimsup_{n\to \infty}x_n=\inf_{n\geq 1}\sup_{k\geq n}x_k<br>$$<br>也有下极限<br>$$<br>\varliminf_{n\to \infty}x_n=\sup_{n\geq 1}\inf_{k\geq n}x_k<br>$$<br>总有不等式<br>$$<br>\varliminf_{n\to \infty}x_n\leq \varlimsup_{n\to \infty}x_n<br>$$<br>它们相等时记为 $\lim_{n\to \infty}x_n$ 并称为 $(x_n)$ 的极限。</p><ol><li> $\varlimsup (-x_n)=-\varliminf x_n$ 而 $\varliminf (-x_n)=-\varlimsup x_n$ 。</li><li>对于子列 $(k_n)$ ，有 $\varliminf x_n\leq \varliminf x_{k_n}$ 且 $\varlimsup x_{k_n}\leq \varlimsup x_{n}$ 。</li><li>从某项起 $x_n\leq y_n$ ，则 $\varliminf x_n\leq \varliminf y_n$ 且 $\varlimsup x_n\leq \varlimsup y_n$ 。</li><li> $0&lt;\lim x_n&lt;\infty$ 时， $\varlimsup (x_ny_n)=\lim x_n\varlimsup y_n$ 。</li><li> $0&lt;\lim x_n&lt;\infty$ 时， $\varliminf (x_ny_n)=\lim x_n\varliminf y_n$ 。</li><li>在有意义时， $\varlimsup (x_n+y_n)\leq \varlimsup x_n+\varlimsup y_n$ 。</li><li>在有意义时， $\varliminf (x_n+y_n)\geq \varliminf x_n+\varliminf y_n$ 。</li><li>在有意义时，$$\varliminf (x_n+y_n)\leq \varliminf x_n+\varlimsup y_n\leq \varlimsup (x_n+y_n)$$</li></ol><p>柯西收敛原理：关于实数列 $(x_n)$ 的以下三个条件等价：</p><ol><li><p>$(x_n)$ 是收敛数列：<br>$$<br>\exists x\in \mathbb{R} , \forall \epsilon &gt;0 , \exists m\geq 1,\forall n&gt;m:|x_n-x|&lt;\epsilon<br>$$</p></li><li><p>$(x_n)$ 是基本数列：<br>$$<br>\forall \epsilon &gt;0 , \exists m\leq 1,\forall n,l&gt;m:|x_n-x_l|&lt;\epsilon<br>$$</p></li><li><p> $(x_n)$ 是有界数列并且极限存在。此时 $x=\lim_{n\to \infty}x_n$ 。</p></li></ol><p>单调完备性：单调广义数列 $(x_n)$ 有极限。在递增情形， $\lim_{n\to \infty}x_n=\sup_{n\geq 1}x_n$ ；在递减情形， $\lim_{n\to \infty}x_n=\inf_{n\geq 1}x_n$ 。</p><p>广义实数列： $(x_n)$ 的上极限是其子列极限中的最大者，而 $(x_n)$ 的下极限是其子列极限中的最小者。</p><p>定理：广义实数列都有其收敛子列。</p><p>数值项级数</p><p>级数形式的单调收敛定理：设 $J$ 是定向集，设 $i\in I$ 时非负函数 $u_i$ 是递增的——当 $k\preceq l$ 时 $u_i(k)\leq u_i(l)$ ，则<br>$$<br>\sup_{j\in J}\sum_{i\in I}u_i(j)=\sum_{i\in I}\sup_{j\in J}u_i(j)<br>$$<br>小数</p><h3 id="Euclid-空间"><a href="#Euclid-空间" class="headerlink" title="Euclid 空间"></a>Euclid 空间</h3><p>Euclid 距离性质：<br>非负对称性： $ |y-x| = |x-y| \geq 0$ ， $ |x-y| =0$ 当且仅当 $x=y$ 。<br>三角不等式： $ |x-z|\leq |x-y|+|y-z|$ 或 $ | | x-z |-| y-z | | \leq | x-y |$ 。</p><p>在 Euclid 空间中，以点 $x$ 为球心以正数 $r$ 为半径，定义</p><p>开球： $O(x,r)=\{ y\in {\mathbb{R}}^n: |y-x|&lt;r \}$ ，<br>闭球： $B(x,r)=\{ y\in {\mathbb{R}}^n: |y-x|\leq r \}$ ，<br>球面： $S(x,r)=\{ y\in {\mathbb{R}}^n: |y-x|=r \}$ 。</p><p>在实直线上，它们分别是开区间 $(x-r,x+r)$ ，闭区间 $[x-r,x+r]$ 与两点集 $\{ x-r,x+r \}$ 。在平面上，它们分别是开圆盘、闭圆盘与圆周。</p><p>Euclid 空间的拓扑：Euclid 空间 ${\mathbb{R}}^n$ 的子集 $U$ 为开集是指任何 $x\in U$ 都拥有个 $r&gt;0$ 使 $O(x,r)\subseteq U$ 。而 ${\mathbb{R}}^n$ 的子集 $F$ 为闭集是指 ${\mathbb{R}}^n-F$ 为开集。任何开覆盖都有有限子覆盖的集合称为紧集。</p><p>可列个开集的交集称为 $G_{\delta}-$ 型集，而可列个闭集的并集称为 $F_{\sigma}-$ 型集。</p><ol><li>空集与 Euclid 空间是开集，空集与 Euclid 空间是闭集。</li><li>任意个开集的并集是开集，任意个闭集的交集是闭集。</li><li>有限个开集的交集是开集，有限个闭集的并集是闭集。</li><li>开集减闭集是开集，闭集减开集是闭集。</li><li> Euclid 空间的开集都是 $G_{\delta}-$ 型集而闭集都是 $F_{\sigma}-$ 型集。</li></ol><p>定理（Heine-Borel）： Euclid 空间的子集为紧集当且仅当它是有界闭集。</p><p>定理（Cantor）：实直线上非空开集 $U$ 可唯一地表示为至多可列个相互不交开区间的并。这些开区间称为 $U$ 的构成区间，它们的端点不在 $U$ 中。</p><p>定理：对于函数 $f:X\rightarrow Y$ ，以下条件等价：</p><ol><li> $f$ 是连续函数——逐点连续的函数。</li><li>对于 ${\mathbb{R}}^m$ 的开集 $V$ ，存在 ${\mathbb{R}}^n$ 的开集 $U$ 使 $f^{-1}(V\cap Y)=U\cap X$ 。</li><li>对于 ${\mathbb{R}}^m$ 的开集 $F$ ，存在 ${\mathbb{R}}^n$ 的开集 $E$ 使 $f^{-1}(F\cap Y)=E\cap X$ 。</li></ol><p>此时， $f$ 将 $X$ 中的紧集映为紧集而 $F_{\sigma}-$ 型集映为 $F_{\sigma}-$ 型集。</p><p>设函数 $g:[a,b]\rightarrow \mathbb{R}$ 的不连续点都是第一类的，命 $\hat{g}(a)=g(a+)$ 与 $\hat{g}(b)=g(b-)$ 。当 $a&lt;x&lt;b$ 时，命 $\hat{g}(x)=\max \{ g(x),g(x-),g(x+) \}$ ，设 $a&lt;x&lt;y&lt;b$ 使 $\hat{g}(x)&lt;\hat{g}(y)$ ，称 $x$ 为 $g$ 的一个右控点。设 $a&lt;y&lt;x&lt;b$ 使 $g(y)&gt;\hat{g}(x)$ ，称 $x$ 为 $g$ 的一个左控点。</p><p>定理（F.Riesz）：不连续点都是第一类的函数 $g:[a,b]\rightarrow\mathbb{R}$ 的右控点全体 $U$ 是开集且其构成区间 $(u,v)$ 都满足不等式 $g(u+)\leq \hat{g}(v)$ 。</p><p>定理（F.Riesz）：不连续点都是第一类的函数 $g:[a,b]\rightarrow\mathbb{R}$ 的左控点全体 $U$ 是开集且其构成区间 $(u,v)$ 都满足不等式 $g(v-)\leq \hat{g}(u)$ 。</p><p>康托集与康托函数：将闭区间 $[0,1]$ 三等分后移去中间的开区间 $(0.1,0.2)$ ，其中小数为三进制的。剩下的两个闭区间 $[0,0.1]$ 与 $[0.2,1]$ 分别三等分后各移去中间的开区间 $(0.01,0.02)$ 和 $(0.21,0.22)$ 。如此下去，这些被移去的开区间作为构成区间并成一个开集 $O$ 。剩下的集 $K$ 称为康托集。等式 $K=[0,1]-O$ 表明 $K$ 是紧集。</p><p>线性组合：以 $\mathbb{K}$ 代表一个数域，设 $X$ 是数域 $\mathbb{K}$ 上线性空间。如果 $x,x_i$ 是 $X$ 中向量而 $a_i$ 是 $\mathbb{K}$ 中数使得<br>$$<br>x=a_1x_1+\cdots +a_nx_n<br>$$<br>称 $x$ 是 $x_1,\cdots ,x_n$ 的线性组合。如果 $x=0$ 必导致 $a_1=\cdots =a_n=0$ ，称 $x_1,\cdots,x_n$ 是线性无关组。</p><ol><li>对于线性组合封闭的子集称为线性子空间。一般非空子集 $S$ 的线性包<br>$$<br>\mathrm{span} S=\bigcup_{n=1}^{\infty} \{\sum_{i=1}^{n}a_ix_i|a_i\in\mathbb{K};x_i\in S \}<br>$$<br>这是包含 $S$ 的最小线性子子空间。</li><li>称 $S$ 为线性无关集是指 $S$ 中任何有限个互异向量线性无关。这即 $S$ 对 $\mathrm{span} S$ 中向量都有唯一线性表示。一个非零向量构成一个线性无关集。</li><li>对于 $a\in \mathbb{K}$ ，命 $aS=\{ax|x\in S\}$ 。对于 $S_i\subseteq X$ ，作代数和差 $S_1\pm S_2=\{ x_1\pm x_2|x_1\in S_1,x_2\in S_2 \}$ 。</li><li>当 $a_i$ 都非负且 $a_1+\cdots +a_n$ 时，称 $a_1x_1+\cdots+a_nx_n$ 是 $x_1,\cdots ,x_n$ 的凸组合。非空子集 $E$ 对凸组合封闭当且仅当满足 $0&lt;t&lt;1$ 的实数 $t$ 使 $tE+(1-t)E=E$ 当且仅当 $a$ 和 $b$ 是非负实数时 $aE+bE=(a+b)E$ ，此时称 $E$ 是凸集。</li><li>包含非空子集 $S$ 的所有凸集之交 $\mathrm{cov} S$ 是 $S$ 的凸包——包含 $S$ 的最小凸集：<br>$$<br>\mathrm{cov}=\bigcup_{n=1}^{\infty}\{ \sum_{i=1}^nt_ix_i|t_i\geq 0:\sum_{i\leq n}t_i=1;x_i\in S \}<br>$$<br>定理：设 $X$ 是数域 $\mathbb{K}$ 上非平凡线性空间【而 $S$ 是其线性无关集】，则 $X$ 有个【含 $S$ 的】线性基或 Hamel 基——使 $\mathbb{span}B$ 的线性无关集 $B$ 。</li></ol><p>平移：对于线性空间 $X$ 的子集 $E$ 与向量 $x$ ，作平移<br>$$<br>x+E={x+y|y\in E}<br>$$<br>这是 $S$ 在双射 $X\rightarrow X,y\rightarrow x+y$ 下的像集。它有如下性质：</p><ol><li>平移保持单调性： $E\subseteq F\Rightarrow x+E\subseteq x+F$ 。</li><li>平移保持并运算： $x+\bigcup\{ E_i|i\in I \}=\bigcup \{ x+E_i|i\in I \}$ 。</li><li>平移保持交运算： $x+\bigcap\{ E_i|i\in I \}=\bigcap \{ x+E_i|i\in I \}$ 。</li><li>平移保持差运算： $x+(E-F)=(x+E)-(x+F)$ 。</li><li>平移服从结合律： $x+(y+E)=(x+y)+E$ 。</li><li>凸集的平移还是凸集，但线性子空间不必是线性子空间。</li></ol><h2 id="测度与可测性"><a href="#测度与可测性" class="headerlink" title="测度与可测性"></a>测度与可测性</h2><h3 id="环与测度"><a href="#环与测度" class="headerlink" title="环与测度"></a>环与测度</h3><p>设某些集合组成集类 $\mathcal{A}$ 使 $X=\bigcup \mathcal{A}$ ，称 $X$ 为 $\mathcal{A}$ 的基本空间。</p><ul><li> $\mathcal{A}$ 对有限并运算封闭。</li><li> $\mathcal{A}$ 对有限无交并运算封闭。</li><li> $\mathcal{A}$ 对有限交运算封闭。</li><li> $\mathcal{A}$ 对差运算封闭。</li><li> $\mathcal{A}$ 对补运算封闭。</li><li> $\mathcal{A}$ 对可列并运算封闭。</li><li> $\mathcal{A}$ 对可列无交并运算封闭。</li></ul><p>环与代数：对于集合差运算与有限无交并运算封闭的集类 $\mathcal{R}$ 称为一个环。以基本空间 $X$ 为其成员的环也称为一个代数。</p><ol><li>空集是每个环的成员；环对于有限个集的并运算与交运算封闭。</li><li>一簇环 $\mathcal{R}_{i}:i\in I$ 之交 $\bigcap _{i\in I}\mathcal{R} _i$ 还是环。</li><li>幂集 $2^X$ 是 $X$ 上最大的代数。包含集类 $\mathcal{A}$ 的所有环之交 $R(\mathcal{A})$ 是包含 $\mathcal{A}$ 的最小环——这称为 $\mathcal{A}$ 生成的环。</li><li>大的集类生成的环不会小： $\mathcal{\theta}\subset\mathcal{F}\Rightarrow R(\theta)\subset\ R(F)$ 。</li></ol><p>初等分解与半环：集类 $\mathcal{A}$ 中有限个相互不交的成员 $E_1,\cdots,E_n$ 之并为 $E$ 时，称 $\{ E_i|i\leq n \}$ 是 $E$ 相对于 $\mathcal{A}$ 的初等分解。</p><ol><li>设集类 $\mathcal{A}$ 是半环——它对有限交运算封闭且 $\mathcal{A}$ 中两个成员的差可由 $\mathcal{A}$ 初等分解，则 $R(\mathcal{A})$ 中成员都可由 $\mathcal{A}$ 初等分解。</li><li>设 $\mathcal{E}$ 和 $\mathcal{F}$ 是半环，则 $\mathcal{E}*\mathcal{F}=\{ E\times F|E\in \mathcal{E},F\in \mathcal{F} \}$ 是半环。</li></ol><p>测度：设环上集函数 $\mu :\mathcal{R}\rightarrow\overline{\mathbb{R}}$ 满足以下条件：</p><ol><li>空集是其零集——取值为零的集： $\mu(\varnothing)=0$ 。</li><li>非负性： $E\in \mathcal{R}$ 时， $0\leq \mu(E)\leq +\infty$ 。</li><li>可列可加性： $\mathcal{R}$ 中相互不交序列 $(E_n)$ 之并 $E$ 仍在 $\mathcal{R}$ 中时，<br>$$<br>\mu(E)=\mu(E_1)+\mu(E_2)+\cdots<br>$$<br>则称 $\mu$ 为测度。它有以下性质（以下点集都来自 $\mathcal{R}$ 中）</li><li>有限可加性： $\mu(\sqcup_{i=1}^{n}E_i)=\sum_{i=1}^{n}\mu(E_i)$ 。</li><li>分割测量性（与有限可加性等价）： $\mu(F)=\mu(F\cap E)+\mu(F-E)$ 。</li><li>单调性：若 $E$ 是 $F$ 的子集，则 $\mu(E)\leq \mu(F)$ 。</li><li>可减性：若 $E$ 是 $F$ 的测度有限子集，则 $\mu(F-E)=\mu(F)-\mu(E)$ 。</li><li>可列次可加性： $\{ E_n \}$ 覆盖 $E$ 时， $\mu(E)\leq \sum_{i=1}^{\infty}\mu(E_i)$ 。</li><li>下连续性： $(E_n)$ 递增至 $E$ 时， $\lim_{n\to \infty}\mu(E_n)=\mu(E)$ 。</li><li>上连续性： $(E_n)$ 递减至 $E$ 且某项测度有限时， $\lim_{n\to \infty}\mu(E_n)=\mu(E)$ 。</li><li>序列 $(E_n)$ 的下限集为 $E$ 时， $\mu(E)\leq \varliminf_{n \to \infty}\mu(E_n)$ 。</li><li> $E=\varlimsup_{n\to \infty}E_n$ 且有 $k$ 使 $\mu(\cup_{n\geq k}E_n$ 有限时， $\varlimsup_{n\to \infty}\leq \mu(E)$ 。</li></ol><p>任何环 $\mathcal{R}$ 上都有一个计数测度——有限集 $E$ 的计数测度 $|E|_0$ 是 $E$ 中元素的个数而无限集 $E$ 的计数测度 $|E|_0=+\infty$ 。</p><p>Borel-Cantelli 引理：设 $\mu$ 是环 $\mathcal{R}$ 上的测度，设 $(E_n)$ 是 $\mathcal{R}$ 中序列使 $E=\varlimsup_{n\to \infty}E_n$ 在 $\mathcal{R}$ 中。若有 $k$ 使 $\sum_{n\geq k}\mu(E_n)&lt;+\infty$ ，则 $\mu(E)=0$ 。</p><p>定理：如果环上非负集函数 $\mu:\mathcal{R}\rightarrow\overline{\mathbb{R}}$ 具有分割测量性（相当于有限可加性）与可列次可加性，则它具有可列可加性。</p><p>单调性与 $\sigma -$ 环：<br>（一）对于单调集列的极限运算封闭的集类 $\mathcal{M} $ 称为单调类。如果幂集 $ 2^X $ 是单调类。一簇单调类 $ \{ \mathcal{M}_i | i\in I \} $ 之交 $\cap_{i\in I} {\mathcal{M}_i} $ 还是单调类。集类 $ \mathcal{A} $ 生成的单调类 $ M(\mathcal{A}) $ 是包含 $ \mathcal{A} $ 的最小单调类。</p><p>（二）对于差运算与可列无交并运算封闭的集类 $\mathcal{S}$ 称为 $\sigma -$ 环。以基本空间为成员的 $\sigma -$ 环也称为 $\sigma -$ 代数。幂集 $2^X$ 是 $X$ 上最大的 $\sigma -$ 代数和单调类。</p><p>单调类定理：包含环 $\mathcal{R}$ 的单调类 $\mathcal{M}$ 必包含 $\mathcal{R}$ 生成的 $\sigma-$ 环 $S(\mathcal{R})$ 。特别的，环 $\mathcal{R}$ 生成的单调类 $M(\mathcal{R})$ 与 $\sigma-$ 环 $S(\mathcal{R})$ 相等。</p><p>外测度：环 $\mathcal{R}$ 上的非负集函数 $\nu$ 称为外测度是指 $\nu$ 在空集上取值为 $0$ 且满足单调性与可列次可加性。设 $\mu$ 是环 $\mathcal{R}$ 上测度。对任何 $E\in H(\mathcal{R})$ ，作其外测度<br>$$<br>\mu^*(E)=\inf\{ \sum_{i=1}^{\infty}\mu(E_i)|\{ E_i|i\geq 1 \}\subseteq \mathcal{R}:E\subseteq \cup_{i=1}^{\infty}E_i \}<br>$$</p><ol><li>外测度 $\mu^*$ 在空集上为零： $\mu^*(\varnothing)=0$ 。</li><li>外测度 $\mu^*$ 具有非负性： $0\leq \mu^* \leq +\infty$ 。</li><li>外测度 $\mu^*$ 具有单调性： $E\subseteq F$ 蕴涵 $\mu^*(E)\leq \mu^*(F)$ 。</li><li>外测度具有可列次可加性：设 $H(\mathcal{R})$ 中序列 $(E_n)$ 覆盖 $E$ ，则<br>$$<br>\mu^*(E)\leq \mu^*(E_1)+\mu^*(E_2)+\cdots<br>$$</li><li>外测度 $\mu^*$ 是测度 $\mu$ 的集函数延拓： $E\in \mathcal{R}$ 蕴涵 $\mu(E)=\mu^*(E)$ 。</li><li>对于 $E\in H(\mathcal{R})$ ， $\mu^*(E)=\min\{ \mu^*(F)|E\subseteq F\in S(\mathcal{R}) \}$ 。</li><li>如果 $\mathcal{R}$ 由半环 $\mathcal{A}$ 生成，则<br>$$<br>\mu^*(E)=\inf\{ \sum_{n\geq 1}\mu(E_n) |\{ E_n \}\subseteq \mathcal{A}:E\subseteq \sqcup_{n\geq 1}E_n\}<br>$$</li></ol><p>定理：设 $\mu$ 是环 $\mathcal{R}$ 上测度而 $E\in H(\mathcal{R})$ 。如果 $E$ 能分割测量 $\mathcal{R}$ 中所有成员，则 $E$ 满足Caratheodory 条件——对任何 $F\in H(\mathcal{R})$ ，<br>$$<br>\mu^*(F)=\mu^*(F\cap E)+\mu^*(F-E)<br>$$</p><p>定理：设 $\mu$ 是环 $\mathcal{R}$ 上测度。全体 $\mu^*-$ 可测集组成一个包含 $\mathcal{R}$ 与一切 $\mu^*-$ 零集的 $\sigma-$ 环 $\mathcal{R}^*$ ，而 $\mu^*$ 限制在 $\mathcal{R}^*$ 上后是 $\mu$ 的一个完全测度延拓。</p><p>定理：设 $\mu$ 是环 $\mathcal{R}$ 上 $\sigma- $ 有限测度而 $E$ 是 $\mu^*-$ 可测集，则 $\mathcal{R}$ 中有个测度有限的递增序列 $(H_n)$ 覆盖 $E$ （因而 $\mu^*$ 在 $\mathcal{R}^*$ 与 $S(\mathcal{R})$ 上都 $\sigma-$ 有限）。进而，</p><ol><li>有 $D,F\in S(\mathcal{R})$ 使 $D\subseteq E\subseteq F$ 且 $\mu^*(F-D)=0$ 。</li><li> $\mu^*(E)&lt;+\infty$ 且 $\varepsilon&gt;0$ 时，有 $F\in\mathcal{R}$ 使 $\mu^*(E\Delta F)&lt;\varepsilon$ 。</li></ol><p>定理：环 $\mathcal{R}$ 上的 $\sigma -$ 有限测度在 $S(\mathcal{R})$ 上有唯一测度延拓。 </p><h3 id="勒贝格测度"><a href="#勒贝格测度" class="headerlink" title="勒贝格测度"></a>勒贝格测度</h3><p>定理：环  上有唯一有限测度  使任何  维区间  的测度就是它的  维体积——各边长度之积  。而  诱导的外测度是</p><p>欧几里得空间与Borel集：将  环  记为  ，其成员称为  的Borel集。另外  还有5个生成系：区间  全体，区间  全体，区间  全体，开集全体和紧集全体。</p><h2 id="积分与可积性"><a href="#积分与可积性" class="headerlink" title="积分与可积性"></a>积分与可积性</h2><h2 id="微分与不定积分"><a href="#微分与不定积分" class="headerlink" title="微分与不定积分"></a>微分与不定积分</h2>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>纯数学</category>
      
      <category>分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog</title>
    <link href="/archives/301227eb.html"/>
    <url>/archives/301227eb.html</url>
    
    <content type="html"><![CDATA[<p>这是一种用来设计电路的语言。学还是挺好学的，就是一个仿真模拟的软件有十几个G的大小，我的电脑装不下。</p><span id="more"></span><h1 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="什么是-Verilog"><a href="#什么是-Verilog" class="headerlink" title="什么是 Verilog"></a>什么是 Verilog</h3><p><strong>Verilog HDL</strong>是一种用于数字逻辑电路设计的硬件描述语言，可以用来进行数字电路的仿真验证、时序分析、逻辑综合。</p><p>用Verilog HDL描述的电路设计就是该电路的<strong>Verilog HDL模型</strong>。</p><p>Verilog HDL 既是一种<strong>行为描述</strong>语言也是一种<strong>结构描述</strong>语言。</p><p>Verilog HDL模型可以是实际电路的不同级别的抽象。<strong>抽象级别</strong>可分为五级：</p><ul><li><strong>系统级</strong>：用高级语言结构（如case语句）实现的设计模块外部性能的模型；</li><li><strong>算法级</strong>：用高级语言结构实现的设计算法模型（写出逻辑表达式）；</li><li><strong>RTL级</strong>：描述数据在寄存器之间流动和如何处理这些数据的模型；</li><li><strong>门级</strong>：描述逻辑门（如与门、非门、或门、与非门、三态门等）以及逻辑门之间连接的模型；</li><li><strong>开关级</strong>：描述器件中三极管和储存节点及其之间连接的模型。</li></ul><h3 id="Verilog-HDL的特点"><a href="#Verilog-HDL的特点" class="headerlink" title="Verilog HDL的特点"></a>Verilog HDL的特点</h3><ul><li>形式化地表示电路的行为和结构；</li><li>借用C语言的结构和语句；</li><li>可在多个层次上对所设计的系统加以描述，语言对设计规模不加任何限制；</li><li>具有混合建模能力：一个设计中的各子模块可用不同级别的抽象模型来描述；</li><li>基本逻辑门、开关级结构模型均内置于语言中，可直接调用；</li></ul><h2 id="Verilog-HDL-的基本结构"><a href="#Verilog-HDL-的基本结构" class="headerlink" title="Verilog HDL 的基本结构"></a>Verilog HDL 的基本结构</h2><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//2位比较器</span><br><span class="hljs-keyword">module</span> compare2 (equal,a,b);<br>    <span class="hljs-keyword">output</span> equal;<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a,b;<br>    <span class="hljs-keyword">assign</span> equal = (a == b)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><ol><li>端口定义</li><li>I/O说明</li><li>信号类型声明</li><li>功能描述</li></ol><p>逻辑功能定义</p><p>有三种方法可以描述电路的逻辑功能</p><ol><li>用 assign 语句</li></ol><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> x = (b &amp; ~c);<br></code></pre></div></td></tr></table></figure><ol start="2"><li>用元件<strong>例化</strong></li></ol><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">and</span> myand3(f,a,b,c);<span class="hljs-comment">//门元件例化</span><br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//模块元件例化</span><br><span class="hljs-keyword">module</span> trist1(out,in,enable);<br>    <span class="hljs-keyword">output</span> out;<br>    <span class="hljs-keyword">input</span> in,enable;<br>    mytri tri_inst(out,in,enable);<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> mytri(out,on,enable);<br>    <span class="hljs-keyword">output</span> out;<br>    <span class="hljs-keyword">input</span> in,enable;<br>    <span class="hljs-keyword">assign</span> out = enable?in:<span class="hljs-number">&#x27;bz</span>;<span class="hljs-comment">//&#x27;bz表示高阻态</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p>模块元件例化——顶层模块（trist1）调用由某子模块（mytri）定义的实例元件（tri_inst）来实现某功能。</p><ul><li>元件例化是调用 Verilog HDL 提供的元件</li><li>元件例化包括<strong>门元件例化</strong>和<strong>模块元件例化</strong></li><li>每个实例元件的名字必须<strong>唯一</strong>！避免与其他调用元件的实例相混淆</li><li>例化元件名也可以省略（当元件只用到一个时）</li></ul><ol start="3"><li>用 “always” 引导的块语句</li></ol><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-comment">//敏感信号变化就执行块内语句</span><br>    <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(load)<br>            out = data;<span class="hljs-comment">//同步预置数据</span><br>        <span class="hljs-keyword">else</span><br>            out = data + <span class="hljs-number">1</span> + cin;<span class="hljs-comment">//加1计数</span><br>    <span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><ul><li>“always” 块语句通常用于描述时序逻辑，也可以描述组合逻辑</li><li>“always” 块语句可用多种手段表达逻辑关系</li><li>“always” 块语句与 assign 语句是<strong>并发执行</strong>的， assign 语句一定要放在 “always” 块语句之外</li></ul><p>Verilog HDL 模块的模板</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> &lt;顶层模块名&gt; (&lt; 输入输出端口列表&gt;) ；<br>    <span class="hljs-keyword">output</span> 输出端口列表；<br>    <span class="hljs-keyword">input</span> 输入端口列表；<br> <span class="hljs-comment">//（1）使用assign语句定义逻辑功能</span><br>    <span class="hljs-keyword">wire</span> 结果信号名；<br>    <span class="hljs-keyword">assign</span> &lt;结果信号名&gt; = 表达式 ；  <br> <span class="hljs-comment">//（2）使用always块定义逻辑功能</span><br>    <span class="hljs-keyword">always</span> @(&lt;敏感信号表达式&gt;)<br>        <span class="hljs-keyword">begin</span><br>       <span class="hljs-comment">//过程赋值语句</span><br>            <span class="hljs-comment">//if语句</span><br>            <span class="hljs-comment">// case语句</span><br>           <span class="hljs-comment">// while,repeat,for循环语句</span><br>           <span class="hljs-comment">// task,function调用</span><br>       <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h2 id="数据类型及常量、变量"><a href="#数据类型及常量、变量" class="headerlink" title="数据类型及常量、变量"></a>数据类型及常量、变量</h2><h3 id="Verilog-关键字"><a href="#Verilog-关键字" class="headerlink" title="Verilog 关键字"></a>Verilog 关键字</h3><p><strong>关键字</strong>:事先定义好的确认符，用来组织语言结构；或者用于定义Verilog HDL提供的门元件（如and，not，or，buf）。用小写字母定义！</p><p>Verilog的关键字:</p><blockquote><p>always， and， assign，begin，buf，bufif0，bufif1，case，casex，casez，cmos，deassign， default，defparam，disable，edge，else，end，endcase，endmodule，endfunction，endprimitive, endspecify, endtable， endtask， event， for， force， forever， fork， function，highz0， highz1, if，initial, inout, input，integer，join,large，macromodule，medium，module， nand，negedge，nmos，nor，not，notif0，notifl, or, output, parameter, pmos, posedge, primitive, pull0, pull1, pullup, pulldown, rcmos, reg, releses, repeat, mmos, rpmos, rtran, rtranif0,rtranif1,scalared,small，specify，specparam，strength，strong0, strong1, supply0, supply1, table, task, time, tran, tranif0, tranif1, tri, tri0, tri1, triand, trior， trireg，vectored，wait，wand，weak0，weak1，while， wire，wor, xnor， xor</p></blockquote><h3 id="Verilog-标识符"><a href="#Verilog-标识符" class="headerlink" title="Verilog 标识符"></a>Verilog 标识符</h3><p><strong>标识符</strong>:任何用Verilog HDL语言描述的“东西”都通过其名字来识别，这个名字被称为标识符。</p><p>标识符可由字母、数字、下划线和美元符号构成；但第一个字符必须是字母或下划线，不能是数字或美元符号！</p><p>Verilog HDL中变量名是<strong>区分大小写</strong>。</p><h3 id="Verilog-数据类型"><a href="#Verilog-数据类型" class="headerlink" title="Verilog 数据类型"></a>Verilog 数据类型</h3><p>Verilog HDL中共有19种数据类型；其中4个最基本的数据类型为：</p><ul><li>integer型</li><li>parameter型</li><li>reg型</li><li>wire型</li></ul><p>其它数据类型：large型、medium型、 scalared型、 small型、time型、tri型、tri0型、tri1型、triand型、trior型、trireg型、vectored型、wand型、wor型等</p><p><strong>常量</strong>：在程序运行过程中，其值不能被改变的量，称为常量。 </p><ul><li>数字（包括整数，x和z值，负数）</li><li>parameter常量（或称符号常量）</li></ul><p>(1)<strong>整数型常量</strong>（即整常数）的4种进制表示形式：</p><ul><li>二进制整数（b或B）；</li><li>十进制整数（d或D）；</li><li>十六进制整数（h或H）；</li><li>八进制整数（o或O）。</li></ul><table><thead><tr><th>表达方式</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>&lt;位宽&gt; ’&lt;进制&gt; &lt;数字&gt;</td><td>完整表达方式</td><td>8’b11000101或8’hc5或8’b1100_0101</td></tr><tr><td>&lt;进制&gt; &lt;数字&gt;</td><td>缺省位宽，则位宽由机器系统决定，至少32位</td><td>hc5</td></tr><tr><td>&lt;数字&gt;</td><td>缺省进制为十进制，位宽默认为32位</td><td>197</td></tr></tbody></table><p>(2)<strong>x和z值</strong></p><p>x表示不定值，z表示高阻值；</p><ul><li>每个字符代表的二进制数的宽度取决于所用的进制；</li><li>当用二进制表示时，已标明位宽的数若用x或z表示某些位，则只有在最左边的x或z具有扩展性！为清晰可见，最好直接写出每一位的值！<br>[例]8’bzx = 8’bzzzz_zzzx<br>[例]8’b1x = 8’b0000_001x</li><li>“？”是z的另一种表示符号，建议在case语句中使用？表示高阻态z<br>[例] </li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">casez</span> (select)<br>        <span class="hljs-number">4</span>’b???<span class="hljs-number">1</span>: out = a;<br>        <span class="hljs-number">4</span>’b??<span class="hljs-number">1</span>?: out = b;<br>        <span class="hljs-number">4</span>’b?<span class="hljs-number">1</span>??: out = c;<br>        <span class="hljs-number">4</span>’b1???: out = d;<br><span class="hljs-keyword">endcase</span><br></code></pre></div></td></tr></table></figure><p>(3)<strong>负数</strong></p><ul><li>在位宽前加一个减号，即表示负数<br>如：-8’d5    //5的补数，= 8‘b11111011</li><li>减号不能放在位宽与进制之间，也不能放在进制与数字之间！<br>8 ’ d-5    //非法格式</li></ul><blockquote><p>为提高可读性，在较长的数字之间可用下划线_隔开！但不可以用在&lt;进制&gt;和&lt;数字&gt;之间。<br>当常量未指明位宽时，默认为32位。</p></blockquote><p>(4)<strong>parameter常量（符号常量）</strong></p><p>用parameter来定义一个标识符，代表一个常量——称为符号常量</p><p>parameter 参数名1 = 表达式,参数名2 = 表达式, ……；</p><ul><li>每个赋值语句的右边必须为常数表达式，即只能包含数字或先前定义过的符号常量！</li><li>常用参数来定义延迟时间和变量宽度。</li><li>可用字符串表示的任何地方,都可以用定义的参数来代替。</li><li>参数是本地的，其定义只在本模块内有效。</li><li>在模块或实例引用时，可通过参数传递改变在被引用模块或实例中已定义的参数！</li></ul><p><strong>参数常量的使用</strong>：</p><ol><li><p>利用defparam定义参数声明语句！<br>defparam 例化模块名.参数名1 = 常数表达式,<br>例化模块名.参数名2 = 常数表达式, ……；</p><ul><li>defparam语句在编译时可重新定义参数值。</li><li>可综合性问题：一般情况下是不可综合的。</li><li>提示：不要使用defparam语句！在模块的实例引用时可用“#”号后跟参数的语法来重新定义参数。</li></ul></li><li><p>利用特殊符号“#”<br>被引用模块名 # （参数1,参数2,…）例化模块名（端口列表）；</p></li></ol><p><strong>变量</strong>：在程序运行过程中，其值可以改变的量，称为变量。</p><p>其数据类型有19种，常用的有3种：</p><ul><li>网络型（nets type）</li><li>寄存器型（register type ）</li><li>数组（memory type）</li></ul><p><strong>nets型变量</strong>：输出始终随输入的变化而变化的变量。表示结构实体（如门）之间的物理连接。</p><p><strong>常用nets型变量</strong>：</p><ul><li>wire，tri：连线类型（两者功能一致）</li><li>wor，trior：具有线或特性的连线（两者功能一致）</li><li>wand，triand：具有线与特性的连线（两者功能一致）</li><li>tri1，tri0：上拉电阻和下拉电阻</li><li>supply1，supply0：电源（逻辑1）和地（逻辑0）</li></ul><p><strong>wire型变量</strong>：</p><ul><li><strong>最常用的nets型变量</strong>，常用来表示以assign语句赋值的组合逻辑信号。</li><li>模块中的输入/输出信号类型缺省为wire型。</li><li>可用做任何方程式的输入，或“assign”语句和实例元件的输出。</li></ul><p>wire 数据名1,数据名2, ……,数据名n;</p><p>wire型向量（总线）：wire[n-1:0] 数据名1,数据名2, ……,数据名m;或 wire[n:1] 数据名1,数据名2, ……,数据名m;</p><p><strong>register型变量</strong>：对应具有状态保持作用的电路元件（如触发器、寄存器等）,常用来表示过程块语句（如initial，always，task，function）内的指定信号 。</p><p><strong>常用register型变量</strong>：</p><ul><li>reg：常代表触发器</li><li>integer：32位带符号整数型变量</li><li>real：64位带符号实数型变量</li><li>time：无符号时间变量</li></ul><p><strong>reg型变量</strong>：在过程块中被赋值的信号，往往代表触发器，但不一定就是触发器（也可以是组合逻辑信号）！</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> 数据名<span class="hljs-number">1</span>,数据名<span class="hljs-number">2</span>, ……,数据名n;<br></code></pre></div></td></tr></table></figure><p>reg型向量（总线）：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><br><span class="hljs-keyword">reg</span>[n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] 数据名<span class="hljs-number">1</span>,数据名<span class="hljs-number">2</span>, ……,数据名m; <br><span class="hljs-comment">//或</span><br><span class="hljs-keyword">reg</span>[n:<span class="hljs-number">1</span>] 数据名<span class="hljs-number">1</span>,数据名<span class="hljs-number">2</span>, ……,数据名m;<br></code></pre></div></td></tr></table></figure><p>对比register型变量和nets型变量</p><ul><li>register型变量需要被明确地赋值，并且在被重新赋值前一直保持原值。</li><li>register型变量必须通过过程赋值语句赋值！不能通过assign语句赋值！</li><li>在过程块内被赋值的每个信号必须定义成register型！</li><li>wire型变量只能生成组合逻辑。 reg型变量既可生成触发器，也可生成组合逻辑。</li></ul><p><strong>memory型变量</strong>：由若干个相同宽度的reg型向量构成的数组。</p><ul><li>Verilog HDL通过reg型变量建立数组来对存储器建模。</li><li>memory型变量可描述RAM、ROM和reg文件。</li><li>memory型变量通过扩展reg型变量的地址范围来生成：</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span>[n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] 存储器名[m-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];或 <span class="hljs-keyword">reg</span>[n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]存储器名[m:<span class="hljs-number">1</span>];<br></code></pre></div></td></tr></table></figure><p>memory型变量与reg型变量的区别：</p><ul><li>含义不同：reg[n-1:0] rega；//一个n位的寄存器 reg mema [n-1:0] ；//由n个1位寄存器组成的存储器</li><li>赋值方式不同:一个n位的寄存器可用一条赋值语句赋值； 一个完整的存储器则不行！若要对某存储器中的存储单元进行读写操作，必须指明该单元在存储器中的地址！</li></ul><h2 id="运算符及表达式"><a href="#运算符及表达式" class="headerlink" title="运算符及表达式"></a>运算符及表达式</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table><thead><tr><th>算术运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>/</td><td>除</td></tr><tr><td>%</td><td>求模</td></tr></tbody></table><ul><li>除法取整：进行整数除法运算时，结果值略去小数部分，只取整数部分！</li><li>%称为求模（或求余）运算符，要求%<strong>两侧均为整型数据</strong>；</li><li>求模运算结果值的符号位取第一个操作数的符号位！<br>[例] -11%3     结果为-2</li><li>进行算术运算时，若某操作数为不定值x，则整个结果也为x。</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符把它的操作数当作布尔变量：</p><ul><li>非零的操作数被认为是真(1’b1)；</li><li>零被认为是假(1’b0)；</li><li>不确定的操作数如4’bxx00, 被认为是不确定的(可能为零，也可能为非零）（记为1’bx)； 但4’bxx11被认为是真（记为1’b1，因为它肯定是非零的）。</li><li>进行逻辑运算后的结果为布尔值（为1或0或x）！</li><li>“&amp;&amp;”和“||”的优先级除高于条件运算符外，低于关系运算符、等式运算符等几乎所有运算符；</li><li>逻辑非“！”优先级最高。</li></ul><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th>关系运算符</th><th>说明</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr></tbody></table><ul><li>运算结果为1位的逻辑值1或0或x。关系运算时，若关系为真，则返回值为1；若声明的关系为假，则返回值为0；若某操作数为不定值x，则返回值为x。</li><li>所有的关系运算符优先级别相同。</li><li>关系运算符的优先级低于算术运算符。</li></ul><h3 id="等式运算符"><a href="#等式运算符" class="headerlink" title="等式运算符"></a>等式运算符</h3><table><thead><tr><th>等式运算符</th><th>说明</th></tr></thead><tbody><tr><td>==</td><td>等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>===</td><td>全等</td></tr><tr><td>!==</td><td>不全等</td></tr></tbody></table><ul><li>运算结果为1位的逻辑值1或0或x。</li><li>等于运算符(= =)和全等运算符(= = =)的区别:<br>使用等于运算符时，两个操作数必须逐位相等,结果才为1；若某些位为x或z，则结果为x。<br>使用全等运算符时，若两个操作数的相应位完全一致（如同是1，或同是0，或同是x，或同是z）,则结果为1；否则为0。</li><li>所有的等式运算符优先级别相同。</li><li>= = =和！= =运算符常用于case表达式的判别，又称为“case等式运算符”。</li></ul><h3 id="缩减运算符"><a href="#缩减运算符" class="headerlink" title="缩减运算符"></a>缩减运算符</h3><table><thead><tr><th>缩减运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td></tr><tr><td>~&amp;</td><td>与非</td></tr><tr><td>|</td><td>或</td></tr><tr><td>~|</td><td>或非</td></tr><tr><td>^</td><td>异或</td></tr><tr><td>^ ~,~ ^</td><td>同或</td></tr></tbody></table><ul><li>运算法则与位运算符类似，但运算过程不同！</li><li>对单个操作数进行递推运算,即先将操作数的最低位与第二位进行与、或、非运算，再将运算结果与第三位进行相同的运算，依次类推，直至最高位 。</li><li>运算结果缩减为1位二进制数。<br>[例]reg[3:0] a;<br>b=|a;          //等效于 b =( (a[0] | a[1]) | a(2)) | a[3]</li></ul><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>条件运算符为？：<br>用法：信号=条件?表达式1:表达式2</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table><thead><tr><th>位运算符</th><th>说明</th></tr></thead><tbody><tr><td>~</td><td>按位取反</td></tr><tr><td>&amp;</td><td>按位与</td></tr><tr><td>|</td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>^ ~,~ ^</td><td>按位同或</td></tr></tbody></table><ul><li>位运算其结果与操作数位数相同。位运算符中的双目运算符要求对两个操作数的相应位逐位进行运算。</li><li>两个不同长度的操作数进行位运算时，将<strong>自动按右端对齐</strong>，位数少的操作数会在高位用0补齐。<br>[例] 若A = 5’b11001，B = 3’b101，<br>则A &amp; B = （5’b11001）&amp;（5’b00101）= 5’b00001</li></ul><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><table><thead><tr><th>移位运算符</th><th>说明</th></tr></thead><tbody><tr><td>&gt;&gt;</td><td>右移</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr></tbody></table><ul><li>用法：A&gt;&gt;n   或 A&lt;&lt;n<br>将操作数右移或左移n位，同时用n个0填补移出的空位。<br>[例] 4’b1001&gt;&gt;3 = 4’b0001； 4’b1001&gt;&gt;4 = 4’b0000<br>4’b1001&lt;&lt;1 = 5’b10010；4’b1001&lt;&lt;2 = 6’b100100；<br>1&lt;&lt;6 = 32’b1000000</li></ul><h3 id="位拼接运算符"><a href="#位拼接运算符" class="headerlink" title="位拼接运算符"></a>位拼接运算符</h3><ul><li>位拼接运算符为{ }</li><li>用于<strong>将两个或多个信号的某些位拼接起来</strong>，表示一个整体信号。</li><li>用法：{信号1的某几位，信号2的某几位，···，信号n的某几位}</li><li>例如在进行加法运算时，可将进位输出与和拼接在一起使用。</li></ul><h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><p>运算符优先级</p><p><img src="301227eb/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.jpg" alt="运算符优先级"></p><p>为提高程序的可读性，建议使用括号来控制运算的优先级！</p><h2 id="Verilog-语句"><a href="#Verilog-语句" class="headerlink" title="Verilog 语句"></a>Verilog 语句</h2><p><img src="301227eb/%E8%AF%AD%E5%8F%A5.jpg" alt="语句"></p><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><ol><li><strong>连续赋值语句</strong>——assign语句，用于对wire型变量赋值，是描述组合逻辑最常用的方法之一。[例] assign c=a&b;    //a、b、c均为wire型变量。</li><li><strong>过程赋值语句</strong>——用于对reg型变量赋值，有两种方式：<ul><li>非阻塞（non-blocking)赋值方式：赋值符号为&lt;=，如 b &lt;= a ；</li><li>阻塞（blocking)赋值方式：赋值符号为=，如 b = a ；</li></ul></li></ol><p>非阻塞赋值与阻塞赋值的<strong>区别</strong></p><ol><li><p><strong>非阻塞赋值</strong>方式<br>非阻塞赋值在<strong>块结束时</strong>才完成赋值操作</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)  <br>    <span class="hljs-keyword">begin</span>  <br>            b &lt;=  a ; <br>            c &lt;= b;<br>        <span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p> 注：c的值比b的值落后一个时钟周期！</p></li><li><p><strong>阻塞赋值</strong>方式<br>阻塞赋值在<strong>该语句结束时</strong>就完成赋值操作！</p> <figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)  <br>    <span class="hljs-keyword">begin</span>  <br>            b = a ; <br>            c = b;<br>        <span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p> 注：在一个块语句中，如果有多条阻塞赋值语句，在前面的赋值语句没有完成之前，后面的语句就不能被执行，就像被阻塞了一样，因此称为阻塞赋值方式。<br> 这里c的值与b的值一样 ！</p></li></ol><p>非阻塞赋值与阻塞赋值方式的<strong>主要区别</strong></p><p>非阻塞（non-blocking)赋值方式 ( b&lt;= a)：</p><ul><li>b的值被赋成新值a的操作, 并不是立刻完成的，而是在块结束时才完成；</li><li>块内的多条赋值语句在块结束时同时赋值；</li><li>硬件有对应的电路。</li></ul><p>阻塞（blocking)赋值方式 ( b = a)：</p><ul><li>b的值立刻被赋成新值a；</li><li>完成该赋值语句后才能执行下一句的操作；</li><li>硬件没有对应的电路，因而综合结果未知。</li></ul><p>建议在初学时只使用一种方式，不要混用！</p><p>建议在可综合风格的模块中使用非阻塞赋值！</p><h3 id="块语句"><a href="#块语句" class="headerlink" title="块语句"></a>块语句</h3><p>用来将两条或多条语句组合在一起，使其在格式上更像一条语句，以增加程序的可读性。</p><p>顺序块语句：</p><ul><li>begin_end语句——标识顺序执行的语句</li></ul><p><img src="301227eb/%E9%A1%BA%E5%BA%8F%E5%9D%97%E6%A0%BC%E5%BC%8F.jpg" alt="顺序块格式"></p><p>特点：</p><p>块内的语句是<strong>顺序执行</strong>的；</p><ul><li>每条语句的延迟时间是相对于前一条语句的仿真时间而言的；</li><li>直到最后一条语句执行完，程序流程控制才跳出该顺序块。</li></ul><p>并行块语句：</p><ul><li>用fork_join标识的块</li></ul><p><img src="301227eb/%E5%B9%B6%E8%A1%8C%E5%9D%97%E6%A0%BC%E5%BC%8F.jpg" alt="并行块格式"></p><p>特点：</p><ul><li>块内的语句是<strong>同时执行</strong>的；</li><li>块内每条语句的延迟时间是相对于程序流程控制进入到块内时的仿真时间而言的；</li><li>延迟时间用于给赋值语句提供时序；</li><li>当按时间排序在最后的语句执行完或一个disable语句执行时，程序流程控制跳出该并行块。</li></ul><h3 id="编译预处理语句"><a href="#编译预处理语句" class="headerlink" title="编译预处理语句"></a>编译预处理语句</h3><p>一、‵define语句<br>宏定义语句——用一个指定的标志符（即宏名）来代表一个字符串（即宏内容）</p><p>宏展开——在编译预处理时将宏名替换为字符串的过程。</p><p>宏定义的作用：</p><ul><li>以一个简单的名字代替一个长的字符串或复杂表达式；</li><li>以一个有含义的名字代替没有含义的数字和符号。</li></ul><p>注意：</p><ul><li>宏名可以用大写字母，也可用小写字母表示；但建议用大写字母，以与变量名相区别。</li><li>‵define语句可以写在模块定义的外面或里面。宏名的有效范围为定义命令之后到源文件结束。</li><li>在引用已定义的宏名时，必须在其前面加上符号“‵ ” ！</li><li>使用宏名代替一个字符串，可简化书写，便于记忆，易于修改。</li><li>预处理时只是将程序中的宏名替换为字符串，不管含义是否正确。只有在编译宏展开后的源程序时才报错。</li><li>宏名和宏内容必须在同一行中进行声明！</li><li>宏定义不是Verilog HDL语句，不必在行末加分号！如果加了分号，会连分号一起置换！</li><li>在进行宏定义时，可引用已定义的宏名，实现层层置换。</li></ul><p>二、‵include语句<br>文件包含语句——一个源文件可将另一个源文件的全部内容包含进来。</p><p>好处：</p><p>避免程序设计人员的重复劳动！不必将源代码复制到自己的另一源文件中，使源文件显得简洁。<br>（1）可以将一些常用的宏定义命令或任务（task）组成一个文件，然后用‵include语句将该文件包含到自己的另一源文件中，相当于将工业上的标准元件拿来使用。<br>（2）当某几个源文件经常需要被其他源文件调用时，则在其他源文件中用‵include语句将所需源文件包含进来。</p><p>注意：</p><ul><li>一个‵include语句只能指定一个被包含的文件；若要包含n个文件，需用n个‵include语句。</li><li>‵include语句可出现在源程序的任何地方。被包含的文件若与包含文件不在同一子目录下，必须指明其路径！</li><li>可将多个‵include语句写在一行；在该行中，只可出现空格和注释行。<br>文件包含允许嵌套。</li></ul><p>三、‵timescale语句<br>时间尺度语句——用于定义跟在该命令后模块的时间单位和时间精度。</p><p>‵timescale &lt;时间单位&gt; / &lt;时间精度&gt;</p><ul><li>时间单位——用于定义模块中仿真时间和延迟时间的基准单位；</li><li>时间精度——用来声明该模块的仿真时间和延迟时间的精确程度。</li><li>在同一程序设计里，可以包含采用不同时间单位的模块。此时用最小的时间精度值决定仿真的时间单位。</li></ul><p>注意：</p><ul><li>时间精度至少要和时间单位一样精确，时间精度值不能大于时间单位值！</li><li>在‵timescale语句中，用来说明时间单位和时间精度参量值的数字必须是整数。</li><li>其有效数字为1、10、100；</li><li>单位为秒（s）、毫秒（ms）、微秒（us）、纳秒（ns）、皮秒（ps）、毫皮秒（fs）。</li></ul><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>条件语句分为两种：if-else语句和case语句；<br>它们都是顺序语句，应放在“always”块内！</p><ol><li>if-else 语句</li></ol><p>判定所给条件是否满足，根据判定的结果（真或假）决定执行给出的两种操作之一。</p><p>if-else语句有3种形式：</p><ul><li>其中“表达式”为逻辑表达式或关系表达式，或一位的变量。</li><li>若表达式的值为0、或z，则判定的结果为“假”；若为1，则结果为“真”。</li><li>语句可为单句，也可为多句；多句时一定要用“begin_end”语句括起来，形成一个复合块语句。</li></ul><p>允许一定形式的表达式简写方式，如：<br>if(expression) 等同于if(expression = = 1)<br>if(！expression) 等同于if(expression ！= 1)</p><p>方式1：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>（表达式） 语句<span class="hljs-number">1</span>；<br></code></pre></div></td></tr></table></figure><p>方式2：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>（表达式<span class="hljs-number">1</span>） 语句<span class="hljs-number">1</span>；<br><span class="hljs-keyword">else</span> 语句<span class="hljs-number">2</span>；<br></code></pre></div></td></tr></table></figure><p>方式3：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>（表达式<span class="hljs-number">1</span>） 语句<span class="hljs-number">1</span>；<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>（表达式<span class="hljs-number">2</span>）语句<span class="hljs-number">2</span>；<br>      …<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>（表达式n）语句n；<br></code></pre></div></td></tr></table></figure><ul><li>if语句可以嵌套；</li><li>若if与else的数目不一样，注意用“begin_end”语句来确定if与else的配对关系！</li></ul><p>if语句的嵌套：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>（表达式<span class="hljs-number">1</span>） <br>  <span class="hljs-keyword">if</span>（表达式<span class="hljs-number">2</span>）语句<span class="hljs-number">1</span>；<br>  <span class="hljs-keyword">else</span>         语句<span class="hljs-number">2</span>；<br><span class="hljs-keyword">else</span><br>  <span class="hljs-keyword">if</span>（表达式<span class="hljs-number">3</span>）语句<span class="hljs-number">3</span>；<br>  <span class="hljs-keyword">else</span>         语句<span class="hljs-number">4</span>；<br><br></code></pre></div></td></tr></table></figure><p>当if与else的数目不一样时，最好用“begin_end”语句将单独的if语句括起来：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>（表达式<span class="hljs-number">1</span>） <br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>（表达式<span class="hljs-number">2</span>）语句<span class="hljs-number">1</span>；<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br>  语句<span class="hljs-number">2</span>；<br><br></code></pre></div></td></tr></table></figure><p>注意：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span> (reset)<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (load)<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cin)<br></code></pre></div></td></tr></table></figure><p>不要写成3个并列的if语句：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span> (reset)<br><span class="hljs-keyword">if</span> (load)<br><span class="hljs-keyword">if</span> (cin)<br></code></pre></div></td></tr></table></figure><p>因为这样写则是同时对3个信号reset、load和cin进行判断，现实中很可能出现三者同时为“1”的情况，即3个条件同时满足，则应该同时执行它们对应的执行语句，但3条执行语句是对同一个信号qout赋不同的值，显然相互矛盾。故编译时会报错！</p><ol start="2"><li>case 语句</li></ol><ul><li>当敏感表达式取不同的值时, 执行不同的语句。</li><li>功能：当某个（控制）信号取不同的值时，给另一个（输出）信号赋不同的值。常用于多条件译码电路（如译码器、数据选择器、状态机、微处理器的指令译码）！</li><li>case语句有3种形式：case，casez，casex</li></ul><p>(1)case 语句</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><br><span class="hljs-keyword">case</span>（敏感表达式） <br>    值<span class="hljs-number">1</span>：语句<span class="hljs-number">1</span>；<br>    值<span class="hljs-number">2</span>：语句<span class="hljs-number">2</span>；<br>      …<br>    值n：语句n；<br>    <span class="hljs-keyword">default</span>: 语句n+<span class="hljs-number">1</span>；<br><span class="hljs-keyword">endcase</span><br><br></code></pre></div></td></tr></table></figure><p>说明：</p><ul><li>其中“敏感表达式”又称为“控制表达式”，通常表示为控制信号的某些位。<br>值1~值n称为分支表达式，用控制信号的具体状态值表示，因此又称为常量表达式。</li><li>default项可有可无，一个case语句里只能有一个default项!</li><li>值1~值n必须互不相同，否则矛盾。</li><li>值1~值n的位宽必须相等，且与控制表达式的位宽相同。</li></ul><p>(2)casex 语句与casez 语句</p><ul><li>在case语句中，分支表达式每一位的值都是确定的（或者为0，或者为1）；</li><li>在casez语句中，若分支表达式某些位的值为高阻值z，则不考虑对这些位的比较；</li><li>在casex语句中，若分支表达式某些位的值为z或不定值x，则不考虑对这些位的比较。</li><li>在分支表达式中，可用“？”来标识x或z。</li></ul><p>[例] 用casez描述的数据选择器</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mux_z(out,a,b,c,d,select);<br>      <span class="hljs-keyword">output</span> out;<br>      <span class="hljs-keyword">input</span> a,b,c,d;<br>      <span class="hljs-keyword">input</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] select;<br>      <span class="hljs-keyword">reg</span> out; <span class="hljs-comment">//必须声明</span><br>     <span class="hljs-keyword">always</span>@ (select[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> a <span class="hljs-keyword">or</span> b <span class="hljs-keyword">or</span> c <span class="hljs-keyword">or</span> d)<br>     <span class="hljs-keyword">begin</span><br>         <span class="hljs-keyword">casez</span> (select)<br>             <span class="hljs-number">4</span>’b???<span class="hljs-number">1</span>: out = a；<br>             <span class="hljs-number">4</span>’b??<span class="hljs-number">1</span>? : out = b；<br>             <span class="hljs-number">4</span>’b? <span class="hljs-number">1</span>?? : out = c；<br>             <span class="hljs-number">4</span>’b <span class="hljs-number">1</span>??? : out = d；<br>         <span class="hljs-keyword">endcase</span><br>     <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>循环语句分为4种：</p><ul><li><p>for语句——通过3个步骤来决定语句的循环执行：<br>（1）给控制循环次数的变量赋初值。<br>（2）判定循环执行条件，若为假则跳出循环；若为真，则执行指定的语句后，转到第（3）步。<br>（3）修改循环变量的值，返回第（2）步。</p></li><li><p>repeat语句——连续执行一条语句n次</p></li><li><p>while语句——执行一条语句，直到循环执行条件不满足；若一开始条件即不满足，则该语句一次也不能被执行！</p></li><li><p>forever语句——无限连续地执行语句，可用disable语句中断！</p></li></ul><ol><li>for语句</li></ol><p>一般形式：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">for</span> （表达式<span class="hljs-number">1</span>；表达式<span class="hljs-number">2</span>；表达式<span class="hljs-number">3</span>）语句<br></code></pre></div></td></tr></table></figure><p>简单应用形式：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">for</span>（循环变量赋初值；循环执行条件；循环变量增值）<br>    执行语句<br><br></code></pre></div></td></tr></table></figure><p>[例]用for语句描述的7人投票表决器：若超过4人（含4人）投赞成票，则表决通过。</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><br><span class="hljs-keyword">module</span>  vote7 ( pass,vote ); <br>      <span class="hljs-keyword">output</span> pass;<br>      <span class="hljs-keyword">input</span> [<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] vote; <br>      <span class="hljs-keyword">reg</span>[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sum;      <span class="hljs-comment">//sum为reg型变量，用于统计赞成的人数</span><br>      <span class="hljs-keyword">integer</span> i; <br>      <span class="hljs-keyword">reg</span> pass;<br>      <span class="hljs-keyword">always</span> @(vote)<br>          <span class="hljs-keyword">begin</span><br>              sum = <span class="hljs-number">0</span>;                                    <span class="hljs-comment">//sum初值为0</span><br>              <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">6</span>;i = i+<span class="hljs-number">1</span>)                <span class="hljs-comment">//for语句</span><br>    <span class="hljs-keyword">if</span>(vote[i])      sum = sum+<span class="hljs-number">1</span>; <br>                                                    <span class="hljs-comment">//只要有人投赞成票，则 sum加1</span><br>              <span class="hljs-keyword">if</span>(sum[<span class="hljs-number">2</span>])     pass = <span class="hljs-number">1</span>;  <span class="hljs-comment">//若超过4人赞成，则表决通过else                 pass = 0;</span><br>         <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><br><br></code></pre></div></td></tr></table></figure><p>[例] 用for语句初始化memory。</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><br><span class="hljs-keyword">begin</span>:init_mem <br>    <span class="hljs-keyword">reg</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] tempi;      <span class="hljs-comment">//存储器的地址变量</span><br>    <span class="hljs-keyword">for</span>(tempi = <span class="hljs-number">0</span>;tempi&lt;memsize;tempi = tempi+<span class="hljs-number">1</span>)<br>        memory[tempi] = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">end</span><br><br></code></pre></div></td></tr></table></figure><p>注：当执行语句有多条时，可用begin_end语句将其括起来！</p><ol start="2"><li>while 语句</li></ol><ul><li>有条件地执行一条或多条语句。</li><li>首先判断循环执行条件表达式是否为真。若为真，则执行后面的语句或语句块；然后再回头判断循环执行条件表达式是否为真，若为真，再执行一次后面的语句；如此不断，直到条件表达式不为真。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">while</span> （循环执行条件表达式）语句<br><span class="hljs-comment">//或</span><br><span class="hljs-keyword">while</span> （循环执行条件表达式）<br>  <span class="hljs-keyword">begin</span><br>    ……<br>   <span class="hljs-keyword">end</span><br><br></code></pre></div></td></tr></table></figure><p>注1：首先判断循环执行条件表达式是否为真，若不为真，则其后的语句一次也不被执行！<br>注2：在执行语句中，必须有一条改变循环执行条件表达式的值的语句！<br>注3：while语句只有当循环块有事件控制（即@（posedge clock））时才可综合！</p><h3 id="结构说明语句"><a href="#结构说明语句" class="headerlink" title="结构说明语句"></a>结构说明语句</h3><ul><li>initial说明语句——只执行一次</li><li>always说明语句——不断重复执行，直到仿真结束</li><li>task说明语句——可在程序模块中的一处或多处调用</li><li>function说明语句——可在程序模块中的一处或多处调用</li></ul><ol><li>always 块语句</li></ol><p>包含一个或一个以上的声明语句(如:过程赋值语句、任务调用、条件语句和循环语句等），在仿真运行的全过程中，在定时控制下被反复执行。</p><ul><li>在always块中被赋值的只能是register型变量（如reg，integer，real，time）。</li><li>每个always块在仿真一开始便开始执行，当执行完块中最后一个语句，继续从always块的开头执行。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> &lt;时序控制&gt; &lt;语句&gt;<br></code></pre></div></td></tr></table></figure><p>注1：如果always块中包含一个以上的语句，则这些语句必须放在begin_end或fork_join块中！</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> clear)<br>   <span class="hljs-keyword">begin</span><br>       <span class="hljs-keyword">if</span>(!clear)  qout = <span class="hljs-number">0</span>;   <span class="hljs-comment">//异步清零</span><br>       <span class="hljs-keyword">else</span>           qout = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">end</span>  <br><br></code></pre></div></td></tr></table></figure><p>注2：always语句必须与一定的时序控制结合在一起才有用！如果没有时序控制，则易形成仿真死锁！</p><p>always块语句模板</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (&lt;敏感信号表达式&gt;) <br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// 过程赋值语句</span><br>    <span class="hljs-comment">// if语句</span><br>    <span class="hljs-comment">// case语句</span><br>    <span class="hljs-comment">// while，repeat，for循环</span><br>    <span class="hljs-comment">// task，function调用    </span><br>  <span class="hljs-keyword">end</span><br><br><br></code></pre></div></td></tr></table></figure><ul><li>敏感信号表达式又称事件表达式或敏感表，当其值改变时，则执行一遍块内语句；</li><li>在敏感信号表达式中应列出影响块内取值的所有信号!</li><li>敏感信号可以为单个信号，也可为多个信号，中间需用关键字or连接！</li><li>敏感信号不要为x或z，否则会阻挡进程！</li><li>always的时间控制可以为沿触发，也可为电平触发。</li><li>关键字posedge表示上升沿；negedge表示下降沿。</li></ul><p>由两个沿触发的always 块：常用于描述时序逻辑</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@ (<span class="hljs-keyword">posedge</span> clock <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> reset)<br>   <span class="hljs-keyword">begin</span><br>        …… <br>   <span class="hljs-keyword">end</span><br><br></code></pre></div></td></tr></table></figure><p>由多个电平触发的always 块：常用于描述组合逻辑</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@ (a <span class="hljs-keyword">or</span> b <span class="hljs-keyword">or</span> c)<br>   <span class="hljs-keyword">begin</span><br>        …… <br>   <span class="hljs-keyword">end</span><br><br></code></pre></div></td></tr></table></figure><p>always块语句是用于综合过程的最有用的语句之一，但又常常是不可综合的。为得到最好的综合结果， always块程序应严格按以下模板来编写：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (Inputs) <span class="hljs-comment">//所有输入信号必须列出，用or隔开</span><br>   <span class="hljs-keyword">begin</span><br>       ……                 <span class="hljs-comment">//组合逻辑关系</span><br>   <span class="hljs-keyword">end</span>  <br><br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (Inputs) <span class="hljs-comment">//所有输入信号必须列出，用or隔开</span><br>   <span class="hljs-keyword">if</span> (Enable) <br>      <span class="hljs-keyword">begin</span><br>        ……                 <span class="hljs-comment">//锁存动作</span><br>      <span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> Clock)  <span class="hljs-comment">// Clock only</span><br>   <span class="hljs-keyword">begin</span><br>       ……                               <span class="hljs-comment">// 同步动作</span><br>   <span class="hljs-keyword">end</span>  <br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> Clock <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> Reset)<br><span class="hljs-comment">// Clock and Reset only</span><br>   <span class="hljs-keyword">begin</span><br>       <span class="hljs-keyword">if</span> (! Reset)            <span class="hljs-comment">// 测试异步复位电平是否有效</span><br>           ……                  <span class="hljs-comment">// 异步动作</span><br>       <span class="hljs-keyword">else</span><br>           ……                 <span class="hljs-comment">// 同步动作</span><br>   <span class="hljs-keyword">end</span>                           <span class="hljs-comment">// 可产生触发器和组合逻辑</span><br><br></code></pre></div></td></tr></table></figure><p>（1）当always块有多个敏感信号时，一定要采用if - else if语句，而不能采用并列的if语句！否则易造成一个寄存器有多个时钟驱动，将出现编译错误。<br> （2）通常采用异步清零！只有在时钟周期很小或清零信号为电平信号时（容易捕捉到清零信号）采用同步清零。</p><ol start="2"><li>initial 语句</li></ol><p>格式：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span><br> <span class="hljs-keyword">begin</span><br>   语句<span class="hljs-number">1</span>；<br>   语句<span class="hljs-number">2</span>；<br>   ……<br>   语句n；<br>  <span class="hljs-keyword">end</span><br><br></code></pre></div></td></tr></table></figure><p>用途：</p><ul><li>在仿真的初始状态对各变量进行初始化；</li><li>在测试文件中生成激励波形作为电路的仿真信号。</li></ul><h2 id="一些Verilog程序"><a href="#一些Verilog程序" class="headerlink" title="一些Verilog程序"></a>一些Verilog程序</h2><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//计算rega中1的个数</span><br><span class="hljs-keyword">module</span> count1s_for_good(count,rega);<br>    <span class="hljs-keyword">output</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count;<br>    <span class="hljs-keyword">input</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] rega;<br>    <span class="hljs-keyword">reg</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count;<br>    <span class="hljs-keyword">always</span> @ (rega)<br>    <span class="hljs-keyword">begin</span>:<br>        block<br>        <span class="hljs-keyword">integer</span> i;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">7</span>;i=i+<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">if</span>(rega[i] == <span class="hljs-number">1</span>)<br>                count = count +<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑</title>
    <link href="/archives/812c5abc.html"/>
    <url>/archives/812c5abc.html</url>
    
    <content type="html"><![CDATA[<p>数字逻辑其实就是数字电路。数字电路隔壁电光专业要大二下学期才学，我们计算机科学与技术的却要大二上学期就学。（虽然我们学的应该比较简单）。这门课主要就是教我们设计数字电路的，对今后计算机组成等方面的学习还是有很大的帮助的。</p><span id="more"></span><h1 id="数字逻辑"><a href="#数字逻辑" class="headerlink" title="数字逻辑"></a>数字逻辑</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>数字信号：若信号的变化在时间上和数值上都是离散的，或者说断续的，则称为离散信号。离散信号的变化可以用不同的数字反映，所以又称为数字信号，简称为数字量。</p><p>数字电路： 用来处理数字信号的电子线路称为数字电路。 用来处理数字信号的电子线路称为数字电路。</p><p>数字逻辑电路的类型（根据一个电路是否具有记忆功能）：</p><ul><li>组合逻辑电路</li></ul><p>组合逻辑电路 : 如果一个逻辑电路在任何时刻的稳定输出仅取决于该时刻的输入，而与电路过去的输入无关，则称为组合逻辑(Combinational Logic)电路。</p><ul><li>时序逻辑电路</li></ul><p>时序逻辑电路:  如果一个逻辑电路在任何时刻的稳定输出不仅取决于该时刻的输入，而且与过去的输入相关，则称为时序逻辑(Sequential Logic)电路。</p><p>时序逻辑电路按照是否有统一的时钟信号进行同步，又可进一步分为同步时序逻辑电路和异步时序逻辑电路。</p><h3 id="数制及其转换"><a href="#数制及其转换" class="headerlink" title="数制及其转换"></a>数制及其转换</h3><p>R进制：</p><p>广义地说，一种进位计数制包含着基数和位权两个基本的因素：</p><p>基数: 指计数制中所用到的数字符号的个数。在基数为R计数制中，包含0、1、…、R-1共R个数字符号，进位规律是“逢R进一”。称为R进位计数制，简称R进制。</p><p>位权: 是指在一种进位计数制表示的数中，用来表明不同数位上数值大小的一个固定常数。不同数位有不同的位权，某一个数位的数值等于这一位的数字符号乘上与该位对应的位权。R进制数的位权是R的整数次幂。</p><p>一个R进制数N可以有两种表示方法：</p><ul><li>并列表示法（位置计数法）</li></ul><p>$$<br>N_R=(K_{n-1} K_{n-2} \cdots K_1 K_0.K_{-1} K_{-2} \cdots K_{-m})_R<br>$$</p><ul><li>多项式表示法（按权展开法）</li></ul><p>$$<br>N_R = (K_{n-1} \times R^{n-1}+K_{n-2} \times R^{n-2}+ \cdots K_{1} \times R^{1}+K_{0} \times R^{0}+K_{-1} \times R^{-1}+ \cdots K_{-m} \times R^{-m})_R<br>$$</p><p>基数R=2的进位计数制称为二进制。二进制数中只有0和1两个基本数字符号，进位规律是“逢二进一”。二进制数的位权是2的整数次幂。</p><p>数字系统中普遍采用二进制,通常采用八进制数和十六进制数作为二进制数的缩写。</p><p>基数R=8的进位计数制称为八进制。八进制数中有0、1、…、7共8个基本数字符号，进位规律是“逢八进一”。八进制数的位权是8的整数次幂。</p><p>基数R=16的进位计数制称为十六进制。十六进制数中有0、1、…、9、A、B、C、D、E、F共16个数字符号，其中，A～F分别表示十进制数的10～15。进位规律为“逢十六进一”。十六进制数的位权是16的整数次幂。</p><p>数制转换</p><ol><li>二进制与十进制之间的转换</li></ol><ul><li><p>二进制转十进制<br>多项式替代法：将二进制数表示成按权展开式，并按十进制运算法则进行计算，所得结果即为该数对应的十进制数。</p></li><li><p>十进制转二进制<br>基数乘除法：十进制数转换成二进制数时，应对整数和小数分别进行处理。<br>整数转换——采用“除2取余”的方法；<br>小数转换——采用“乘2取整”的方法。</p></li></ul><ol start="2"><li>二进制数与八进制数、十六进制数之间的转换</li></ol><ul><li>二进制数转换成八进制数：以小数点为界，分别往高、往低每3位为一组，最后不足3位时用0补充，然后写出每组对应的八进制字符，即为相应八进制数。</li><li>二进制数转换成十六进制数：以小数点为界，分别往高、往低每4位为一组，最后不足4位时用0补充，然后写出每组对应的十六进制字符即可。 </li></ul><h3 id="带符号二进制数的代码表示"><a href="#带符号二进制数的代码表示" class="headerlink" title="带符号二进制数的代码表示"></a>带符号二进制数的代码表示</h3><p>原码：<br>符号位用0表示正，1表示负；数值位保持不变。原码表示法又称为符号—数值表示法。</p><p>反码：</p><p>带符号二进制数的反码表示：</p><p>符号位———用0表示正，用1表示负；</p><p>数值位———正数反码的数值位和真值的数值位相同；而负数反码的数值位是真值的数值位按位变反。</p><p>加减运算：</p><p>$$［X_1 + X_2］_反 =［X_1］_反 +［X_2］_反$$<br>$$［X_1 – X_2］_反 =［X_1］_反 +［-X_2］_反$$</p><p>补码：</p><p>带符号二进制数的补码表示：</p><p>符号位——用0表示正，用1表示负；</p><p>数值位——正数补码的数值位与真值相同；负数补码的数值位是真值的数值位按位变反，并在最低位加1。</p><p>加减运算：</p><p>$$［X_1 + X_2］_补 =［X_1］_补 +［X_2］_补$$<br>$$［X_1 – X_2］_补 =［X_1］_补 +［-X_2］_补$$</p><h3 id="几种常用的编码"><a href="#几种常用的编码" class="headerlink" title="几种常用的编码"></a>几种常用的编码</h3><p>十进制数的二进制编码（BCD码）：用4位二进制代码对十进制数字符号进行编码，简称为二–十进制代码，或称BCD(Binary Coded Decimal)码。</p><ul><li><p>8421码：是用4位二进制码表示一位十进制字符的一种有权码，4位二进制码从高位至低位的权依次为23、22、21、20，即为8、4、2、1,故称为8421码。<br>8421码与十进制数之间的转换是按位进行的，即十进制数的每一位与4位二进制编码对应。</p></li><li><p>2421码: 是用4位二进制码表示一位十进制字符的另一种有权码，4位二进制码从高位至低位的权依次为2、4、2、1,故称为2421码。<br>2421码与十进制数之间的转换同样是按位进行的。</p><ol><li>2421码不具备单值性。例如，0101和1011都对应十进制数字5。为了与十进制字符一一对应，2421码不允许出现0101～1010的6种状态。</li><li>2421码是一种对9的自补代码。即一个数的2421码只要自身按位变反，便可得到该数对9的补数的2421码。</li></ol></li><li><p>余3码：是由8421码加上0011形成的一种无权码，由于它的每个字符编码比相应8421码多3，故称为余3码。</p><ol><li>余3码中不允许出现0000、0001、0010、1101、1110和1111六种状态。</li><li>余3码与十进制数进行转换时，每位十进制数字的编码都应余3。</li><li>余3码是一种对9的自补代码。</li></ol></li></ul><p>可靠性编码</p><ul><li><p>格雷码：</p><p>转换规则：</p><p>设二进制码为 $B=B_{n-1}B_{n-2} \cdots B_{i+1}B_i \cdots B_1B_0$</p><p>对应格雷码为 $G=G_{n-1}G_{n-2} \cdots G_{i+1}G_i \cdots G_1G_0$</p></li></ul><p>$$<br>G_{n-1} = B_{n-1}<br>$$</p><p>$$<br>G_i = B_{i+1}⊕B_i  \quad  0 ≤  i≤ n-2<br>$$</p><p>  其中，运算“⊕”称为“异或”运算，运算规则是：</p><p>  0⊕0=0；  0⊕1=1； </p><p>  1⊕0=1；  1⊕1=0。</p><ul><li><p>奇偶检验码：</p><p>组成：信息位——位数不限的一组二进制代码+奇偶检验位——仅有一位。</p><p>编码方式：有两种编码方式.</p><p>奇检验:使信息位和检验位中“1”的个数共计为奇数；</p><p>偶检验:使信息位和检验位中“1”的个数共计为偶数。</p></li></ul><ul><li>字符编码：<br>最常用的字符编码是美国信息交换标准码，简称ASCII码(American Standard Code for Information Interchange)。ASCII码用7位二进制码表示128种字符，由于数字系统中实际是用一个字节表示一个字符，所以使用ASCII码时，通常在最左边增加一位奇偶检验位。 </li></ul><h2 id="逻辑代数基础"><a href="#逻辑代数基础" class="headerlink" title="逻辑代数基础"></a>逻辑代数基础</h2><h3 id="逻辑代数的基本概念"><a href="#逻辑代数的基本概念" class="headerlink" title="逻辑代数的基本概念"></a>逻辑代数的基本概念</h3><p>逻辑代数L是一个封闭的代数系统，它由一个逻辑变量集K，常量0和1以及“或”、“与”、“非”三种基本运算所构成，记为 $L=\{K,+,·, ¯,0,1\}$ 。该系统应满足下列公理</p><ul><li><p>交换律：对于任意逻辑变量 $A,B$ ，有 $A + B = B + A$ ； $A·B = B ·A$ </p></li><li><p>结合律：对于任意的逻辑变量 $A,B,C$ ，有 $(A + B) + C = A + ( B + C )$ ， $( A·B )· C = A·( B· C )$</p></li><li><p>分配律：对于任意的逻辑变量 $A,B,C$ ，有 $A + ( B·C ) = (A + B)·(A + C) $ ； $A·( B + C) = A·B + A·C$</p></li><li><p>0─1 律：对于任意逻辑变量 $A$ ，有 $A + 0 = A$  ； $A \cdot 1 = A$ $A + 1 = 1$  ； $A \cdot 0 = 0$ </p></li><li><p>互补律：对于任意逻辑变量 $A$ ，存在唯一的 $\overline{A}$ ，使得 $\overline{A}+A=1 \quad \overline{A}\cdot A=0$ 。</p></li></ul><p>逻辑代数中定义了“或”、“与” 、“非”三种基本运算。<br>1．“或”运算<br>　　如果决定某一事件是否发生的多个条件中，只要有一个或一个以上条件成立，事件便可发生，则这种因果关系称之为“或”逻辑。</p><p>2．“与” 运算<br>　　如果决定某一事件发生的多个条件必须同时具备，事<br>件才能发生，则这种因果关系称之为“与”逻辑。</p><p>3．“非” 运算<br>　　如果某一事件的发生取决于条件的否定，即事件与事件发生的条件之间构成矛盾，则这种因果关系称为“非”逻辑。</p><p>设某一逻辑电路的输入逻辑变量为 $A_1,A_2,\cdots,A_n$ ，输出逻辑变量为 $F$ ， $F$ 被称为 $A_1,A_2,\cdots,A_n$ 的逻辑函数，记为 $F = f( A1，A2，…，An )$ 。</p><p>逻辑函数的表示法：</p><ul><li>逻辑表达式：是由逻辑变量和“或”、“与”、“非”3种运算符以及括号所构成的式子。</li><li>真值表：依次列出一个逻辑函数的所有输入变量取值组合及其相应函数值的表格称为真值表。一个 $n$ 个变量的逻辑函数，其真值表有 $2^n$ 行。</li><li>卡诺图：卡诺图是由表示逻辑变量所有取值组合的小方格所构成的平面图。</li></ul><h3 id="逻辑代数的基本定理和规则"><a href="#逻辑代数的基本定理和规则" class="headerlink" title="逻辑代数的基本定理和规则"></a>逻辑代数的基本定理和规则</h3><h4 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理:"></a>基本定理:</h4><ul><li>定理1<br>$$0 + 0 = 0　1 + 0 = 1$$<br>$$0 \cdot 0 = 0　1 \cdot 0 = 0$$<br>$$0 + 1 = 1　1 + 1 = 1$$<br>$$0 \cdot 1 = 0　1 \cdot 1 = 1$$</li><li>定理2<br>$$A + A = A $$<br>$$ A \cdot A = A$$</li><li>定理3<br>$$A + A \cdot B = A $$<br>$$ A \cdot ( A + B ) = A$$</li><li>定理4<br>$$A+A·B = A+B $$<br>$$ A·(A+B) = A·B$$</li><li>定理5<br>$$\overline{\overline{A}}=A$$</li><li>定理6<br>$$\overline{A+B}=\overline{A}\cdot \overline{B} $$<br>$$\overline{A\cdot B}=\overline{A} + \overline{B}$$</li><li>定理7<br>$$A\cdot B+A\cdot \overline{B} = A  $$<br>$$( A + B ) \cdot ( A+ \overline{B}) = A$$</li><li>定理8<br>$$A\cdot B+\overline{A}\cdot C+B\cdot C=A\cdot B+\overline{A}\cdot C $$ $$ (A+B)\cdot (\overline{A}+C)\cdot (B+C)=(A+B)\cdot \overline{A}+C)$$</li></ul><h4 id="重要规则："><a href="#重要规则：" class="headerlink" title="重要规则："></a>重要规则：</h4><ul><li>代入规则：任何一个含有变量$A$的逻辑等式,如果将所有出现A的位置都代之以同一个逻辑函数$F$，则等式仍然成立。这个规则<br>称为代入规则。</li><li>反演规则：若将逻辑函数表达式F中所有的“·”变成“+”，“+”变<br>成“·”,“0”变成“1”,“1”变成“0”,原变量变成反变量，反变<br>量变成原变量，并保持原函数中的运算顺序不变，则所<br>得到的新的函数 $\overline{F}$ 为原函数$F$的反函数。</li><li>对偶规则：如果将逻辑函数表达式F中所有的“·”变成“+”,“+”变成“·”，“0”变成“1”，“1”变成“0”，并保持原函数中的运算顺序不变，则所得到的新的逻辑表达式称为函数F的对偶式，并记作$F^{\prime}$。</li></ul><h4 id="复合逻辑"><a href="#复合逻辑" class="headerlink" title="复合逻辑"></a>复合逻辑</h4><ul><li>与非逻辑<br>与非逻辑是由与、非两种逻辑复合形成的，可用逻辑函数表示为 $F=\overline{A\cdot B\cdot C\cdots}$ 。<br>逻辑功能：只要变量 $A,B,C,\cdots$ 中有一个为0，则函数 $F$ 为1；仅当变量 $A,B,C,\cdots$ 全部为1时，函数 $F$ 为0。<br>实现与非逻辑的门电路称为“与非”门。<br>只要有了与非门便可组成实现各种逻辑功能的电路，通常称与非门为通用门。</li></ul><ul><li>或非逻辑<br>或非逻辑是由或、非两种逻辑复合形成的，可表示为 $F=\overline{A+B+C+\cdots}$ 。<br>逻辑功能：只要变量 $A,B,C,\cdots$ 中有一个为1，则函数 $F$ 为0；仅当变量 $A,B,C,\cdots$ 全部为0时，函数 $F$ 为1。实现或非逻辑的门电路称为“或非”门。<br>或非门同样可实现各种逻辑功能，是一种通用门。</li></ul><ul><li><p>与或非逻辑<br>与或非逻辑是由3种基本逻辑复合形成的，逻辑函数表达式的形式为 $F=\overline{AB+CD+\cdots}$ 。<br>逻辑功能：仅当每一个“与项”均为0时，才能使F为1，否则F为0。<br>　实现与或非功能的门电路称为“与或非”门。</p></li><li><p>异或逻辑及同或逻辑</p><ol><li>异或逻辑<br>异或逻辑是一种两变量逻辑关系，可用逻辑函数表示为 $S=A\oplus B=\overline{A}B+A \overline{B}$ 。<br>逻辑功能：变量 $A,B$ 取值相同， $F$ 为0；变量 $A,B$ 取值相异， $F$ 为1。<br>实现异或运算的逻辑门称为“异或门”。<br>在进行异或运算的多个变量中，若有奇数个变量的值为1，则运算结果为1；若有偶数个变量的值为1，则运算结果为0。</li><li>同或逻辑<br>同或逻辑也是一种两变量逻辑关系，其逻辑函数表达式为 $F=A \odot B=\overline{A}\cdot \overline{B}+AB$ 。<br>功能逻辑：变量 $A,B$ 取值相同， $F$ 为1；变量 $A,B$ 取值相异， $F$ 为0。<br>实现同或运算的逻辑门称为“同或门”。<br>当多个变量进行同或运算时，若有奇数个变量的值为0，则运算结果为0；反之，若有偶数个变量的值为0，则运算结果为1。 </li></ol><p>同或逻辑与异或逻辑的关系既互为相反，又互为对偶。<br>$$<br>\overline{A\oplus B}=\overline{A\overline{B}+\overline{A}B}=(\overline{A}+B)(A+\overline{B})=AB+\overline{A}\cdot \overline{B}=A\odot B<br>$$</p><p>$$<br>(A\oplus B)^{\prime} = (A\overline{B}+\overline{A}B)^{\prime}=(A+\overline{B})(\overline{A}+B)=\overline{A} \cdot \overline{B}+AB=A\odot B<br>$$</p></li></ul><h3 id="逻辑函数表达式的形式与变换"><a href="#逻辑函数表达式的形式与变换" class="headerlink" title="逻辑函数表达式的形式与变换"></a>逻辑函数表达式的形式与变换</h3><h4 id="逻辑函数表达式的两种基本形式"><a href="#逻辑函数表达式的两种基本形式" class="headerlink" title="逻辑函数表达式的两种基本形式"></a>逻辑函数表达式的两种基本形式</h4><p>两种基本形式：指“与-或”表达式和“或-与”表达式。</p><p>“与-或”表达式：是指由若干“与项”进行“或”运算构成的表达式。</p><p>“或-与”表达式：是指由若干“或项”进行“与”运算构成的表达式。</p><p>逻辑函数表达式可以被表示成任意的混合形式。</p><p>逻辑函数的基本形式都不是唯一的。</p><h4 id="逻辑函数表达式的标准形式"><a href="#逻辑函数表达式的标准形式" class="headerlink" title="逻辑函数表达式的标准形式"></a>逻辑函数表达式的标准形式</h4><p>一、最小项和最大项</p><p>最小项：如果一个具有 $n$ 个变量的函数的“与项”包含全部 $n$ 个变量，每个变量都以原变量或反变量形式出现一次，且仅出现一次，则该“与项”被称为最小项。有时又将最小项称为标准“与项”。</p><p>最小项的数目： $n$ 个变量可以构成 $2^n$ 个最小项。</p><p>简写：用 $m_i$ 表示最小项。下标 $i$ 的取值规则是：按照变量顺序将最小项中的原变量用1表示，反变量用0表示，由此得到一个二进制数，与该二进制数对应的十进制数即下标 $i$ 的值。</p><p>性质——最小项具有如下四条性质。</p><p>性质1：任意一个最小项，其相应变量有且仅有一种取值使这个最小项的值为1。并且，最小项不同，使其值为1的变量取值不同。</p><p>性质2：相同变量构成的两个不同最小项相“与” 为0。因为任何一种变量取值都不可能使两个不同最小项同时为1，故相“与”为0。即 $m_i\cdot m_j =0$ 。</p><p>性质3： $n$ 个变量的全部最小项相“或”为1。通常借用数学中的累加符号，将其记为 $\sum_{i=0}^{2^n-1}m_i=1$ 。</p><p>性质4： $n$ 个变量构成的最小项有 $n$ 个相邻最小项。相邻最小项：是指除一个变量互为相反外，其余部分均相同的最小项。例如，三变量最小项 $ABC$ 和相邻 $\overline{A}BC$ 。</p><p>最大项：如果一个具有n个变量函数的“或项”包含全部n个变量，每个变量都以原变量或反变量形式出现一次，且仅出现一次，则该“或项”被称为最大项。有时又将最大项称为标准“或项”。</p><p>最大项的数目： $n$ 个变量可以构成 $2^n$ 个最大项。</p><p>简写：用 $M_i$ 表示最大项。下标 $i$ 的取值规则是：将最大项中的原变量用0表示，反变量用1表示，由此得到一个二进制数，与该二进制数对应的十进制数即下标 $i$ 的值。</p><p>性质：最大项具有如下四条性质。</p><p>性质1  任意一个最大项，其相应变量有且仅有一种取值使这个最大项的值为0。并且，最大项不同，使其值为0的变量取值不同。在 $n$ 个变量构成的任意“或项”中，最大项是使其值为1的变量取值组合数最多的一种“或项”，因而将其称为最大项。</p><p>性质2  相同变量构成的两个不同最大项相“或”为1。<br>因为任何一种变量取值都不可能使两个不同最大项同时为<br>0，故相“或”为1。即 $M_i+M_j=1$ 。</p><p>性质3  $n$ 个变量的全部最大项相“与”为0。通常借用数学中的累乘符号将其记为 $\prod_{i=0}^{2^n-1}M_i=0$ 。</p><p>性质4  $n$ 个变量构成的最大项有 $n$ 个相邻最大项。相邻最大项是指除一个变量互为相反外，其余变量均相同的最大项。</p><p>最小项和最大项的关系：在同一问题中，下标相同的最小项和最大项互为反函数。或者说，相同变量构成的最小项mi和最大项Mi之间存在互补关系。即 $m_i = \overline{M_i}$ 。</p><h4 id="逻辑函数表达式的标准形式-1"><a href="#逻辑函数表达式的标准形式-1" class="headerlink" title="逻辑函数表达式的标准形式"></a>逻辑函数表达式的标准形式</h4><p>逻辑函数表达式的标准形式有标准“与-或”表达式和标准“或-与”表达式两种类型。</p><p>1．标准“与 - 或”表达式<br>由若干最小项相“或”构成的逻辑表达式称为标准“与-或”表达式，也叫做最小项表达式。</p><p>2．标准“或-与”表达式<br>由若干最大项相“与”构成的逻辑表达式称为标准“或-与”表达式，也叫做最大项表达式 。</p><h4 id="逻辑函数表达式的转换"><a href="#逻辑函数表达式的转换" class="headerlink" title="逻辑函数表达式的转换"></a>逻辑函数表达式的转换</h4><p>一、代数转换法 </p><p>所谓代数转换法，就是利用逻辑代数的公理、定理和规则进行逻辑变换，将函数表达式从一种形式变换为另一种形式。 </p><p>1 . 求标准“与-或” 式</p><p>一般步骤如下：<br>第一步：将函数表达式变换成一般“与-或”表达式。<br>第二步：反复使用 $X=X(Y+\overline{Y})$ 将表达式中所有非<br>最小项的“与项”扩展成最小项。</p><p>2 . 求一个函数的标准“或-与” 式<br>一般步骤：<br>第一步：将函数表达式转换成一般“或-与”表达式。<br>第二步：反复利用定理 $A+(A+B)(A+\overline{B})$ 把表达式中<br>所有非最大项的“或项”扩展成最大项。</p><p>二、真值表转换法</p><p>1 . 求标准“与-或” 式<br>逻辑函数的最小项表达式与真值表具有一一对应的关系。假定函数 $F$ 的真值表中有 $k$ 组变量取值使 $F$ 的值为1，其他变量取值下F的值为0，那么，函数F的最小项表达式由这k组变量取值对应的k个最小项相或组成。<br>真值表上使函数值为1的变量取值组合对应的最小项相“或”,即可构成一个函数的标准“与-或”式 。</p><p>2 . 求一个函数的标准“或-与” 式<br>逻辑函数的最大项表达式与真值表之间同样具有一一<br>对应的关系。<br>假定在函数 $F$ 的真值表中有 $p$ 组变量取值使 $F$ 的值为0，其他变量取值下 $F$ 的值为1，那么，函数 $F$ 的最大项表达式由这 $p$ 组变量取值对应的p个最大项“相与”组成。真值表上使函数值为0的变量取值组合对应的最大项相“与”即可构成一个函数的标准“或-与”式 。</p><p>由于函数的真值表与函数的两种标准表达式之间存在一一对应的关系，而任何一个逻辑函数的真值表是唯一的，可见，任何一个逻辑函数的两种标准形式也是唯一的。</p><h3 id="逻辑函数化简"><a href="#逻辑函数化简" class="headerlink" title="逻辑函数化简"></a>逻辑函数化简</h3><p>实现某一逻辑功能的逻辑电路的复杂性与描述该功能的逻辑表达式的复杂性直接相关。为了降低系统成本、减小复杂度、提高可靠性，必须对逻辑函数进行化简。</p><p>逻辑函数化简有3种常用方法。即：代数化简法、卡诺图化简法和列表化简法。</p><h4 id="代数化简法"><a href="#代数化简法" class="headerlink" title="代数化简法"></a>代数化简法</h4><p>代数化简法就是运用逻辑代数的公理、定理和规则对逻辑函数进行化简的方法。</p><p>一、“与-或”表达式的化简</p><p>1．表达式中的“与”项个数最少；<br>2．在满足上述条件的前提下，每个“与”项中的变量个数最少。</p><p>几种常用方法如下：</p><p>1．并项法<br>2．吸收法<br>3．消去法<br>4．配项法 </p><p>二、“或-与”表达式的化简</p><p>1．表达式中的“或”项个数最少；<br>2．在满足上述条件的前提下，每个“或”项中的变量个数最少。</p><p>用代数化简法化简“或-与”表达式可直接运用公理、定理中的“或-与”形式，并综合运用前面介绍“与-或”表达式化简时提出的各种方法进行化简。</p><p>代数化简法的优点是：不受变量数目的约束；当对公理、定理和规则十分熟练时，化简比较方便。<br>缺点是：没有一定的规律和步骤，技巧性很强，而且在很多情况下难以判断化简结果是否最简。</p><h4 id="卡诺图化简法"><a href="#卡诺图化简法" class="headerlink" title="卡诺图化简法"></a>卡诺图化简法</h4><p>卡诺图化简法具有简单、直观、容易掌握等优点，在逻辑设计中得到广泛应用。</p><p>一、卡诺图的构成 </p><p>卡诺图是一种平面方格图，每个小方格代表一个最小项，故又称为最小项方格图。</p><p>结构特点：<br>(1)  $n$ 个变量的卡诺图由 $2^n$ 个小方格构成；<br>(2) 几何图形上处在相邻、相对、相重位置的小方格所代表的最小项为相邻最小项。<br><img src="812c5abc/%E5%8D%A1%E8%AF%BA%E5%9B%BE.jpg" alt="卡诺图"><br>在n个变量的卡诺图中，能从图形上直观、方便地找到每个最小项的n个相邻最小项。</p><p>二、卡诺图的性质</p><p>性质：可以从图形上直观地找出相邻最小项合并。合并的理论依据是并项定理： $A\overline{B}+AB=A$ 。</p><p>用卡诺图化简逻辑函数的基本原理：把卡诺图上表征相邻最小项的相邻小方格“圈”在一起进行合并，达到用一个简单“与”项代替若干最小项的目的。通常把用来包围那些能由一个简单“与”项代替的若干最小项的“圈”称为卡诺圈。 </p><p><img src="812c5abc/%E5%8D%A1%E8%AF%BA%E5%9C%88.jpg" alt="卡诺圈"></p><p>三、逻辑函数在卡诺图上的表示</p><p>1．给定逻辑函数为标准“与-或”表达式<br>当逻辑函数为标准“与-或”表达式时，只需在卡诺图上找出和表达式中最小项对应的小方格填上1，其余小方格填上0，即可得到该函数的卡诺图。</p><p>2．逻辑函数为一般“与-或”表达式<br>当逻辑函数为一般“与-或”表达式时，可根据“与”的公共性和“或”的叠加性作出相应卡诺图。</p><p>为了叙述的方便，通常将卡诺图上填1的小方格称为1方格，填0的小方格称为0方格。0方格有时用空格表示。</p><p>四、卡诺图上最小项的合并规律</p><p>1．两个小方格相邻, 或处于某行(列)两端时，所代表的最小项可以合并，合并后可消去一个变量。</p><p>2．四个小方格组成一个大方格、或组成一行（列）、或处于相邻两行（列）的两端、或处于四角时，所代表的最小项可以合并，合并后可消去两个变量。</p><p>4变量卡诺图上四个相邻最小项合并的典型情况：</p><p><img src="812c5abc/%E5%9B%9B%E4%B8%AA%E7%9B%B8%E9%82%BB%E6%9C%80%E5%B0%8F%E9%A1%B9%E5%90%88%E5%B9%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5.jpg" alt="四个相邻最小项合并的几种情况"></p><p>3．八个小方格组成一个大方格、或组成相邻的两行(列)、或处于两个边行(列)时，所代表的最小项可以合并，合并后可消去三个变量。</p><p> $n$ 个变量卡诺图中最小项的合并规律归纳如下：<br> (1) 卡诺圈中小方格的个数必须为 $2^m$ 个， $m$ 为小于或等于 $n$ 的整数。<br> (2) 卡诺圈中的 $2^m$ 个小方格有一定的排列规律，具体地说，它们含有 $m$ 个不同变量， $(n-m)$ 个相同变量。<br> (3) 卡诺圈中的 $2^m$ 个小方格对应的最小项可用 $(n-m)$ 个变量的“与”项表示，该“与”项由这些最小项中的相同变量构成。<br> (4) 当 $m=n$ 时，卡诺圈包围了整个卡诺图，可用1表示，即 $n$ 个变量的全部最小项之和为1。</p><p>五、卡诺图化简逻辑函数的步骤</p><p>1．几个定义<br>蕴涵项:在函数的“与-或”表达式中，每个“与”项被称为该函数的蕴涵项(Implicant)。<br>在函数卡诺图中，任何一个1方格所对应的最小项或者卡诺圈中的2m个1方格所对应的“与”项都是函数的蕴涵项。</p><p>质蕴涵项:若函数的一个蕴涵项不是该函数中其他蕴涵项的子集，则此蕴涵项称为质蕴涵项(Prime Implicant),简称为质项。<br>在函数卡诺图中，按照最小项合并规律，如果某个卡诺圈不可能被其他更大的卡诺圈包含，那么，该卡诺圈所对应的“与”项为质蕴涵项。</p><p>必要质蕴涵项：若函数的一个质蕴涵项包含有不被函数的其他任何质蕴涵项所包含的最小项，则此质蕴涵项被称为必要质蕴涵项(Essential Prime Implicant)，简称为必要质项。<br>在函数卡诺图中，若某个卡诺圈包含了不可能被任何其他卡诺圈包含的1方格，那么，该卡诺圈所对应的“与”项为必要质蕴涵项。</p><p>2．求逻辑函数最简“与-或”表达式的一般步骤 </p><p>第一步：作出函数的卡诺图；<br>第二步：在卡诺图上圈出函数的全部质蕴涵项；<br>第三步：从全部质蕴涵项中找出所有必要质蕴涵项；<br>第四步：求函数的最简质蕴涵项集。<br>当函数的所有必要质蕴涵项尚不能覆盖卡诺图上的所有1方格时，则从剩余质蕴涵项中找出最简的所需质蕴涵项，使它和必要质蕴涵项一起构成函数的最小覆盖。</p><p>用卡诺图化简总的原则是：<br>(1) 在覆盖函数中所有最小项的前提下，卡诺圈的个数应达到最少；<br>(2) 在满足合并规律的前题下卡诺圈应达到最大；<br>(3) 根据合并的需要，每个最小项可以被多个卡诺圈包围。 </p><ol><li>求逻辑函数最简“或-与”表达式的一般步骤</li></ol><p>当给定逻辑函数为“与—或”表达式或标准“与—或”<br>表达式时，通常采用“两次取反法”。具体如下：<br>(1)作出 $F$ 的卡诺图，求出反函数 $\overline{F}$ 的最简“与-或”表<br>达式(合并卡诺图上的0方格)；<br>(2)对 $\overline{F}$ 的最简“与-或”表达式取反，得到函数F的<br>最简“或-与”表达式。</p><p>当给定逻辑函数为“或—与”表达式或标准“或—与”表达式时，通常采用“两次对偶法”。具体如下：</p><p>(1) 作出 $F$ 对偶式 $F^{\prime}$ 的卡诺图，并求出 $F^{\prime}$ 的最简“与-或”表达式；<br>(2) 对 $F^{\prime}$ 的最简“与-或”表达式取对偶，得到函数F的最简“或-与”表达式。</p><p>卡诺图化简逻辑函数具有方便、直观、容易掌握等优点。 但受到变量个数的约束，当变量个数大于6时，画图以及对图形的识别都变得相当复杂。 </p><h4 id="列表化简法"><a href="#列表化简法" class="headerlink" title="列表化简法"></a>列表化简法</h4><p>略</p><h2 id="集成门电路与触发器"><a href="#集成门电路与触发器" class="headerlink" title="集成门电路与触发器"></a>集成门电路与触发器</h2><p>集成门电路和触发器等逻辑器件是实现数字系统功能的物质基础。</p><p>随着微电子技术的发展，人们把实现各种逻辑功能的元器件及其连线都集中制造在同一块半导体材料小片上，并封装在一个壳体中，通过引线与外界联系，即构成所谓的集成电路块，通常又称为集成电路芯片。</p><p>采用集成电路进行数字系统设计的优点：</p><p>　　可靠性高、可维性好、功耗低、成本低等优点，可以大大简化设计和调试过程。</p><h3 id="数字集成电路的分类"><a href="#数字集成电路的分类" class="headerlink" title="数字集成电路的分类"></a>数字集成电路的分类</h3><p>一、根据所采用的半导体器件进行分类 </p><p>根据所采用的半导体器件，数字集成电路可以分为两大类。<br>　　1.双极型集成电路：采用双极型半导体器件作为元件。主要特点是速度快、负载能力强，但功耗较大、 集成度较低。<br>　　2.单极型集成电路(又称为MOS集成电路): 采用金属-氧化<br>物半导体场效应管(Metel Oxide Semiconductor Field  Effect<br>Transister)作为元件。主要特点是结构简单、制造方便、集<br>成度高、功耗低，但速度较慢。</p><p>二、根据集成电路规模的大小进行分类</p><p>通常根据一片集成电路芯片上包含的逻辑门个数或元件个数，分为 SSI 、MSI 、LSI 、VLSI。 </p><ol><li>SSI (Small Scale Integration ) 小规模集成电路:<br>逻辑门数小于10 门(或元件数小于100个)；</li><li>MSI (Medium Scale Integration ) 中规模集成电路:<br>逻辑门数为10 门～99 门(或元件数100个～999个)；</li><li>LSI (Large  Scale Integration ) 大规模集成电路:<br>逻辑门数为100 门～9999 门(或元件数1000个～99999个)；</li><li>VLSI (Very Large Scale Integration) 超大规模集成电路:<br>逻辑门数大于10000 门(或元件数大于100000个)。</li></ol><h3 id="半导体器件的开关特性"><a href="#半导体器件的开关特性" class="headerlink" title="半导体器件的开关特性"></a>半导体器件的开关特性</h3><p>数字电路中的晶体二极管、三极管和MOS管等器件一般是以开关方式运用的，其工作状态相当于开关的“接通”与“断开”。<br>数字系统中的半导体器件运用在开关频率十分高的电路中(通常开关状态变化的速度可高达每秒百万次数量级甚至千万次数量级)，研究这些器件的开关特性时，不仅要研究它们的静止特性，而且还要分析它们的动态特性。</p><h4 id="晶体二极管的开关特性"><a href="#晶体二极管的开关特性" class="headerlink" title="晶体二极管的开关特性"></a>晶体二极管的开关特性</h4><p>一、静态特性 </p><p>静态特性是指二极管在导通和截止两种稳定状态下的特性。</p><p>典型二极管的静态特性曲线(又称伏安特性曲线) ：<br><img src="812c5abc/%E5%85%B8%E5%9E%8B%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E9%9D%99%E6%80%81%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF.png" alt="典型二极管的静态特性曲线"></p><ol><li>正向特性<br>门槛电压 ( $V_{TH}$ )：使二极管开始导通的正向电压，又称为阈值电压 (一般锗管约0.1V，硅管约0.5V)。</li></ol><ul><li>正向电压 $V_D ≤ V_{TH}$  ：管子截止，电阻很大、正向电流 $I_F$ 接近于 0， 二极管类似于开关的断开状态 ；</li><li>正向电压 $V_D  = V_{TH}$  ：管子开始导通，正向电流 $I_F$ 开始上升；</li><li>正向电压 $V_D ＞V_{TH}$ (一般锗管为0.3V，硅管为0.7V) ：管子充分导通，电阻很小，正向电流$I_F$ 急剧增加，二极管类似于开关的接通状态。使二极管充分导通的电压为导通电压，用$V_F$表示。</li></ul><p>2．反向特性<br>二极管在反向电压 $V_R$ 作用下，处于截止状态，反向电阻很大，反向电流 $I_R$ 很小（将其称为反向饱和电流，用 $I_S$ 表示，通常可忽略不计 ），二极管的状态类似于开关断开。而且反向电压在一定范围内变化基本不引起反向电流的变化。</p><p>注意事项：</p><ul><li>正向导通时可能因电流过大而导致二极管烧坏。组成实际电路时通常要串接一只电阻 $R$，以限制二极管的正向电流；</li><li>反向电压超过某个极限值时，将使反向电流$I_R$突然猛增，致使二极管被击穿（通常将该反向电压极限值称为反向击穿电压$V_{BR}$），一般不允许反向电压超过此值。</li></ul><p>由于二极管的单向导电性，所以在数字电路中经常把它当作开关使用。</p><p>二极管组成的开关电路图如图（a）所示。二极管导通状态下的等效电路如图(b)所示，截止状态下的等效电路如图(c)所示，图中忽略了二极管的正向压降。</p><p><img src="812c5abc/%E4%BA%8C%E6%9E%81%E7%AE%A1%E5%BC%80%E5%85%B3%E7%94%B5%E8%B7%AF%E5%8F%8A%E5%85%B6%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF.png" alt="二极管开关电路及其等效电路"></p><p>二、动态特性</p><p>二极管的动态特性是指二极管在导通与截止两种状态转换过程中的特性，它表现在完成两种状态之间的转换需要一定的时间。为此，引入了反向恢复时间和开通时间的概念。</p><ol><li><p>反向恢复时间<br>反向恢复时间：二极管从正向导通到反向截止所需要的时间称为反向恢复时间。<br>反向恢复时间$t_{re}$=存储时间$t_s$+渡越时间$t_t$</p></li><li><p>开通时间<br>开通时间：二极管从反向截止到正向导通的时间称为开通时间。<br>二极管的开通时间很短，对开关速度影响很小，相对反向恢复时间而言几乎可以忽略不计。</p></li></ol><p><img src="812c5abc/%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7.png" alt="二极管的动态特性"></p><h4 id="晶体三极管的开关特性"><a href="#晶体三极管的开关特性" class="headerlink" title="晶体三极管的开关特性"></a>晶体三极管的开关特性</h4><p>一、静态特性</p><p>晶体三极管由集电结和发射结两个PN结构成。根据两个PN结的偏置极性，三极管有截止、放大、饱和3种工作状态。　　</p><p><img src="812c5abc/%E4%B8%89%E6%9E%81%E7%AE%A1%E5%BC%80%E5%85%B3%E7%94%B5%E8%B7%AF%E5%8F%8A%E5%85%B6%E8%BE%93%E5%87%BA%E7%89%B9%E6%80%A7.png" alt="三极管开关电路及其输出特性"></p><p>在数字逻辑电路中，三极管相当于一个由基极信号控制的无触点开关，其作用对应于触点开关的“闭合”与“断开”。<br>电路在三极管截止与饱和状态下的等效电路如下:</p><p><img src="812c5abc/%E4%B8%89%E6%9E%81%E7%AE%A1%E6%88%AA%E6%AD%A2%E4%B8%8E%E9%A5%B1%E5%92%8C%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF.png" alt="三极管截止与饱和状态下的等效电路"></p><p>晶体三极管在截止与饱和这两种稳态下的特性称为三极管的静态开关特性。</p><p>二、动态特性</p><p>晶体三极管在饱和与截止两种状态转换过程中具有的特性称为三极管的动态特性。<br>三极管的开关过程和二极管一样，管子内部也存在着电荷的建立与消失过程。因此，两种状态的转换也需要一定的时间才能完成。</p><p>1．开通时间（ $t_{on}$ ）<br>开通时间：三极管从截止状态到饱和状态所需要的时间。<br>时间$t_{on}$ =延迟时间$t_d$ +上升时间$t_r$<br>　　<br>2. 关闭时间（ $t_{off}$ ）<br>关闭时间 ：三极管从饱和状态到截止状态所需要的时间。<br>关闭时间$t_{off} $=存储时间$t_s$ +下降时间 $t_f$ </p><p>开通时间和关闭时间是影响电路工作速度的主要因素。（光/电惯性/机械惯性！）</p><p><img src="812c5abc/%E4%B8%89%E6%9E%81%E7%AE%A1%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7.png" alt="三极管的动态特性"></p><h4 id="MOS管的开关特性"><a href="#MOS管的开关特性" class="headerlink" title="MOS管的开关特性"></a>MOS管的开关特性</h4><p>一、静态特性<br>MOS管作为开关元件，同样是工作在截止或导通两种状态。MOS管是电压控制元件，主要由栅源电压$V_{GS}$决定其工作状态。</p><p>工作特性如下：<br>当$V_{GS}$＜开启电压$V_{TN}$时：MOS管工作在截止区，输出电压$V_{DS} ≈V_{DD}$，MOS管处于“断开”状态;</p><p>当$V_{DS}≥V_{GS}－V_{TN}$时：MOS管工作在导通区，输出电压$V_{DS}≈ 0V$，MOS管处于“接通”状态。</p><p>二、动态特性</p><p>MOS管本身导通和截止时电荷积累和消散的时间很小。<br>动态特性主要取决于电路中杂散电容充、放电所需的时间。</p><p>为了提高MOS器件的工作速度，引入了CMOS电路。<br>在CMOS电路中，由于充电电路和放电电路都是低阻电路，因此，其充、放电过程都比较快，从而使CMOS电路有较高的开关速度</p><h3 id="逻辑门电路"><a href="#逻辑门电路" class="headerlink" title="逻辑门电路"></a>逻辑门电路</h3><h4 id="简单的逻辑门电路"><a href="#简单的逻辑门电路" class="headerlink" title="简单的逻辑门电路"></a>简单的逻辑门电路</h4><ol><li><p>与门<br><img src="812c5abc/%E4%B8%8E%E9%97%A8.jpg" alt="与门"></p></li><li><p>或门<br><img src="812c5abc/%E6%88%96%E9%97%A8.jpg" alt="或门"></p></li><li><p>非门<br><img src="812c5abc/%E9%9D%9E%E9%97%A8.jpg" alt="非门"></p></li></ol><h4 id="TTL-集成逻辑门电路"><a href="#TTL-集成逻辑门电路" class="headerlink" title="TTL 集成逻辑门电路"></a>TTL 集成逻辑门电路</h4><p>TTL(Transistor Transistor Logic)电路是晶体管-晶体管逻辑电路的简称。<br>TTL电路的功耗大、线路较复杂，使其集成度受到一定的限制，故广泛应用于中小规模逻辑电路中。</p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是一种具有记忆功能的电子器件。</p><p>触发器的特点：</p><ul><li>有两个互补的输出端 $Q$ 和 $\overline{Q}$</li><li>有两个稳定状态。通常将 $Q=1$ 和 $\overline{Q}=0$ 称为“1”状态，而把 $Q=0$ 和 $\overline{Q}=1$ 称为“0” 状态。当输入信号不发生变化时，触发器状态稳定不变。</li><li>在一定输入信号作用下（触发），触发器可以从一个稳定状态转移到另一个稳定状态。</li></ul><p>现态与次态的概念：</p><p>现态:输入信号作用前的状态，记作 $Q^n$ 和 $\overline{Q^n}$ , 一般简记为 $Q$ 和 $\overline{Q}$ ；<br>次态:输入信号作用后的状态，记作 $Q^{n+1}$ 和 $\overline{Q^{n+1}}$ 。<br>显然，次态是现态和输入的函数。</p><h4 id="基本的-R-S-触发器"><a href="#基本的-R-S-触发器" class="headerlink" title="基本的$R-S$触发器"></a>基本的$R-S$触发器</h4><p>基本$R-S$触发器是直接复位、置位触发器的简称，由于它是构成各种功能触发器的基本部件，故称为基本$R-S$触发器。</p><p>一、 用与非门构成的基本$R-S$触发器</p><p>1.组成：由两个与非门交叉耦合构成，其逻辑图和逻辑符号分别如下图 (a)和(b)所示。</p><p><img src="812c5abc/%E4%B8%8E%E9%9D%9E%E9%97%A8%E6%9E%84%E6%88%90%E7%9A%84R-S%E8%A7%A6%E5%8F%91%E5%99%A8.png"></p><p>$R$(Reset)称为置0端或者复位端;<br>$S$(Set)称为置1端或置位端；<br>逻辑符号输入端加的小圆圈表示低电平或负脉冲有效。</p><ol start="2"><li>工作原理</li></ol><p>(1)若$R=1,S=1$，则触发器保持原来状态不变；<br>(2)若$R=1,S=0$,则触发器置为1状态；（$S$置1端）<br>(3)若$R=0,S=1$,则触发器置为0状态；（$R$置0端）<br>(4)不允许出现$R=0,S=0$。（约束条件！）</p><ol start="3"><li>逻辑功能及其描述</li></ol><p>由与非门构成的$R-S$触发器的逻辑功能如下表所示。</p><p><img src="812c5abc/%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%9F%BA%E6%9C%ACR-S%E8%A7%A6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E8%A1%A8.png" alt="与非门基本R-S触发器功能表"></p><p>表中”d”表示触发器次态不确定。该表又称为次态真值表。</p><p>状态表、状态转移图、激励表:</p><p><img src="812c5abc/%E7%8A%B6%E6%80%81%E8%A1%A8%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE%E6%BF%80%E5%8A%B1%E8%A1%A8.jpg"></p><p>用卡诺图化简后，可得到该触发器的次态方程</p><p>$$<br>Q^{n+1}=\overline{S}+RQ<br>$$</p><p>用卡诺图化简后，可得到该触发器的次态方程： $Q^{n+1}$ 。</p><p>因为R、S不允许同时为0，所以输入必须满足约束条件：$R+S=1$</p><p>二、用或非门构成的基本R-S触发器</p><ol><li>组成：由两个或非门交叉耦合组成，其逻辑图和逻辑符号分别如图(a)和图(b)所示。</li></ol><p><img src="812c5abc/%E6%88%96%E9%9D%9E%E9%97%A8%E6%9E%84%E6%88%90%E7%9A%84R-S%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="或非门构成的R-S触发器"></p><p>该电路的输入是正脉冲或高电平有效，故逻辑符号的输入端未加小圆圈。</p><ol start="2"><li>逻辑功能</li></ol><p><img src="812c5abc/%E6%88%96%E9%9D%9E%E9%97%A8%E5%9F%BA%E6%9C%ACR-S%E8%A7%A6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E8%A1%A8.png" alt="或非门基本R-S触发器功能表"></p><p>次态方程：<br>$$<br>Q^{n+1}=S+\overline{R}Q<br>$$<br>约束方程：<br>$$<br>R\cdot S=0<br>$$</p><p>基本R-S触发器的优点是结构简单。它不仅可作为记忆元件独立用，而且由于它具有直接复位、置位功能，因而被作为各种性能完善的触发器的基本组成部分。但由于R、S之间的约束关系，以及不能进行定时控制，使它的使用受到一定限制。</p><h4 id="几种常用的时钟控制触发器"><a href="#几种常用的时钟控制触发器" class="headerlink" title="几种常用的时钟控制触发器"></a>几种常用的时钟控制触发器</h4><p>具有时钟脉冲控制的触发器称为“时钟控制触发器”或者“定时触发器”。</p><p>时钟脉冲控制触发器的工作特点：</p><ul><li>由时钟脉冲确定状态转换的时刻 (即何时转换？) ；</li><li>由输入信号确定触发器状态转换的方向 (即如何转换？)。</li></ul><p>一、时钟控制R-S触发器</p><p>时钟控制R-S触发器的逻辑图和逻辑符号如图(a)、（b）所示。</p><p><img src="812c5abc/%E6%97%B6%E9%92%9F%E6%8E%A7%E5%88%B6R-S%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="时钟控制R-S触发器"></p><ol><li>组成：<br>　　由四个与非门构成。其中，与非门G1、G2构成基本R-S触发器；与非门G3、G4组成控制电路，通常称为控制门。</li></ol><p>2．工作原理 </p><ul><li><p>当时钟脉冲没有到来（即C=0）时，不管R、S端为何值，两个控制门的输出均为1，触发器状态保持不变。</p></li><li><p>当时钟脉冲到来（即C=1，注意C=1的意义！）时，输入端R、S的值 可以通过控制门作用于基本R-S触发器。</p></li></ul><p>具体如下：</p><ul><li>$R=0, S=0$：控制门G3、G4的输出均为1，触发器状态保持不变；</li><li>$R=0, S=1$：控制门G3、G4的输出分别为1和0，触发器状态置成1状态；</li><li>$R=1, S=0$：控制门G3、G4的输出分别为0和1，触发器状态置成0状态；</li><li>$R=1，S=1$：控制门G3、G4的输出均为0，触发器状态不确定，这是不允许的。</li></ul><p>由分析可知：时钟控制$R-S$触发器的工作过程是由时钟信号$C$和输入信号$R$、$S$共同作用的；时钟$C$控制转换时间，输入$R$和$S$确定转换后的状态。</p><p>3．逻辑功能<br>时钟控制$R-S$触发器的功能表、次态方程和约束条件与由或非门构成的$R-S$触发器相同。<br>在时钟控制触发器中，时钟信号$C$是一种固定的时间基准，通常不作为输入信号列入表中。对触发器功能进行描述时，均只考虑时钟作用$(C=1)$时的情况。</p><p>注意！时钟控制R-S触发器虽然解决了对触发器工作进行定时控制的问题，而且具有结构简单等优点，但依然存在如下不足：</p><ul><li>输入信号依然存在约束条件，即$R$、$S$不能同时为1；</li></ul><p><img src="812c5abc/%E9%92%9F%E6%8E%A7R-S%E8%A7%A6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E8%A1%A8%E7%8A%B6%E6%80%81%E8%A1%A8%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE%E6%BF%80%E5%8A%B1%E8%A1%A8.png"></p><p><img src="812c5abc/%E9%92%9F%E6%8E%A7R-S%E8%A7%A6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E8%A1%A8%E7%8A%B6%E6%80%81%E8%A1%A8%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE%E6%BF%80%E5%8A%B1%E8%A1%A82.png"></p><p>二、 D触发器</p><p>对时钟控制R-S触发器的控制电路稍加修改，使之变成如下图(a)所示的形式，这样便形成了只有一个输入端的D触发器。其逻辑符号如图 (b)所示。</p><p><img src="812c5abc/D%E8%A7%A6%E5%8F%91%E5%99%A8.png"></p><p>修改后，控制电路在时钟脉冲作用期间($C=1$时)，将输入信号D转换成一对互补信号送至基本$R-S$触发器的两个输入端，使基本R-S触发器的两个输入信号只可能是01或者10两种组合，从而消除了状态不确定现象，解决了对输入的约束问题。</p><p>工作原理如下：<br>当无时钟脉冲作用（即$C=0$）时，控制电路被封锁，无论D为何值，与非门G3、G4输出均为1，触发器状态保持不变。<br>当时钟脉冲作用（即$C=1$ ）时，若$D=0$，则门G4输出为1，门G3输出为0，触发器状态被置0；若D=1，则门G4输出为0，门G3输出为1，触发器状态被置1。</p><p>在时钟作用时，D触发器状态的变化仅取决于输入信号D，而与现态无关。其次态方程为<br>$$<br>Q^{n+1}=D<br>$$</p><p>三 、$J-K$触发器</p><p>在时钟控制$R-S$触发器中增加两条反馈线，将触发器的输出$Q$和$\overline{Q}$交叉反馈到两个控制门的输入端，并把原来的输入端S改成J，R改成K，即可改进成$J-K$触发器。$J-K$触发器的逻辑图和逻辑符号如下图所示。</p><p><img src="812c5abc/J-K%E8%A7%A6%E5%8F%91%E5%99%A8.png"></p><p>该触发器利用触发器两个输出端信号始终互补的特点，有效地解决了时钟控制$R-S$触发器在时钟脉冲作用期间两个输入同时为1将导致触发器状态不确定的问题。</p><p>四、$T$触发器</p><p>$T$触发器又称为计数触发器。如果把$J-K$触发器的两个输入端$J$和$K$连接起来，并把连接在一起的输入端用符号$T$表示，就构成了$T$触发器。相应的逻辑图和逻辑符号分别如图(a)和图(b)所示。</p><p><img src="812c5abc/T%E8%A7%A6%E5%8F%91%E5%99%A8.png"></p><p>T触发器的逻辑功能可直接由$J-K$触发器的次态方程导出。$J-K$触发器的次态方程为<br>$$<br>Q^{n+1}=J\overline{Q}+\overline{K}Q<br>$$<br>将该方程中的$J$和$K$均用$T$代替后，即可得到$T$触发器的次态方程：<br>$$<br>Q^{n+1}=T\overline{Q}+\overline{T}Q<br>$$</p><p><img src="812c5abc/T%E8%A7%A6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E8%A1%A8.png"></p><p>功能：</p><ul><li>当T=0时，触发器状态保持不变；</li><li>当T=1时，在时钟脉冲作用下状态翻转，相当于一位二进制计数器。</li></ul><p>上述由四个逻辑门构成的触发器存在空翻问题，所谓“空翻”是指在同一个时钟脉冲作用期间触发器状态发生两次或两次以上变化的现象。</p><p>引起空翻的原因：因为在时钟脉冲作用期间，输入信号直接控制着触发器状态的变化。即当时钟C为1时，输入信号R、S发生变化，触发器状态会跟着变化，从而使得一个时钟脉冲作用期间引起多次翻转。</p><p>为了克服“空翻”现象，实际数字电路中使用的集成T触发器通常采用主从式结构或者维持阻塞结构。它们除了在性能方面的改进外，逻辑功能与上述触发器完全相同。</p><p>思路：缩短开门时间，提高抗扰性。<br>(1) 主从钟控触发器<br>    主从$R-S$ 触发器（P86-87）<br>    主从$J-K$ 触发器（P88-89）<br>(2) 维持-阻塞钟控触发器（P89-91）</p><h4 id="不同类型触发器之间的转换"><a href="#不同类型触发器之间的转换" class="headerlink" title="不同类型触发器之间的转换"></a>不同类型触发器之间的转换</h4><p>略</p><h2 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>若逻辑电路在任何时刻产生的稳定输出值仅仅取决于该时刻各输入值的组合，而与过去的输入值无关，则称为组合逻辑电路。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="812c5abc/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF.png" alt="组合逻辑电路"></p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>可用一组逻辑函数表达式进行描述其逻辑功能，函数表达式可表示为 $F_i=f_i(X_1,X_2,\cdots,X_n)$ 。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>组合电路具有两个特点：</p><ul><li>由逻辑门电路组成，不包含任何记忆元件；</li><li>信号是单向传输的，不存在反馈回路。</li></ul><h3 id="组合逻辑电路分析"><a href="#组合逻辑电路分析" class="headerlink" title="组合逻辑电路分析"></a>组合逻辑电路分析</h3><h4 id="分析的一般步骤"><a href="#分析的一般步骤" class="headerlink" title="分析的一般步骤"></a>分析的一般步骤</h4><ol><li>根据逻辑电路图写出输出函数表达式</li><li>化简输出函数表达式</li><li>列出输出函数真值表</li><li>功能评述与评价</li></ol><h3 id="组合逻辑电路的设计"><a href="#组合逻辑电路的设计" class="headerlink" title="组合逻辑电路的设计"></a>组合逻辑电路的设计</h3><p>设计的一般过程：(与工程实现或实施之间还存在距离！）</p><ol><li>建立给定问题的逻辑描述<br>这一步的关键是弄清楚电路的输入和输出，建立输入和输出之间的逻辑关系，得到描述给定问题的逻辑表达式。求逻辑表达式有两种常用方法，即真值表法和分析法。</li><li>求出逻辑函数的最简表达式<br>为了使逻辑电路中包含的逻辑门最少且连线最少，要对逻辑表达式进行化简，求出描述设计问题的最简表达式 。</li><li>选择逻辑门类型并将逻辑函数变换成相应形式<br>根据简化后的逻辑表达式及问题的具体要求，选择合适的逻辑门，并将逻辑表达式变换成与所选逻辑门对应的形式。</li><li>画出逻辑电路图根据实际问题的难易程度和设计者熟练程度，有时可跳过其中的某些步骤。设计过程可视具体情况灵活掌握。</li></ol><p>一、 包含无关条件的组合逻辑电路设计</p><p>无关最小项的概念：由于输入变量之间存在的相互制约或问题的某种特殊限定，使输出函数与某些变量取值无关，这些输入取值组合对应的最小项称为无关最小项，简称为无关项或者任意项。<br>当采用“最小项之和”表达式描述一个包含无关条件的逻辑问题时，函数表达式中是否包含无关项，以及对无关项是令其值为1还是为0，并不影响函数的实际逻辑功能。<br>注意：在化简这类逻辑函数时，利用无关项的随意性往往可以使逻辑函数得到更好地简化，从而使设计的电路达到更简！</p><p>二 、多输出函数的组合逻辑电路设计</p><p>实际问题中，大量存在着由同一组输入变量产生多个输出函数的问题，实现这类问题的组合逻辑电路称为多输出函数的组合逻辑电路。</p><p>多输出组合电路达到最简的关键是在函数化简时找出各输出函数的公用项，使之在逻辑电路中实现对逻辑门的“共享”，从而达到电路整体结构最简。</p><p>三 、 无反变量提供的组合逻辑电路设计</p><p>在某些问题的设计中，为了减少各部件之间的连线，在逻辑电路的输入端只提供原变量，不提供反变量。</p><p>设计这类电路时，若直截用非门将原变量转换成相应的反变量，则处理结果往往是不经济的。因此，通常进行适当的变换，以便尽可能减少非门数量。</p><h3 id="组合逻辑电路的险象"><a href="#组合逻辑电路的险象" class="headerlink" title="组合逻辑电路的险象"></a>组合逻辑电路的险象</h3><h4 id="竞争现象与险象的产生"><a href="#竞争现象与险象的产生" class="headerlink" title="竞争现象与险象的产生"></a>竞争现象与险象的产生</h4><p>逻辑电路中各路径上延迟时间的长短与信号经过的门的级数有关，与具体逻辑门的时延大小有关，还与导线的长短有关，因此，输入信号经过不同路径到达输出端的时间有先有后，这种现象称为竞争现象 。</p><p>竞争：由于延迟时间的影响，使得输入信号经过不同路径到达输出端的时间有先有后，这一现象称为竞争。</p><p>竟争的类型：<br>非临界竞争——-不产生错误输出的竞争称为非临界竞争。<br>临界竞争——–导致错误输出的竞争称为临界竞争。</p><p>险象：由竞争导至的错误输出信号。</p><p>注意！组合电路中的险象是一种瞬态现象，它表现为在输出端产生不应有的尖脉冲，暂时地破坏正常逻辑关系。一旦瞬态过程结束，即可恢复正常逻辑关系。</p><h4 id="险象的分类"><a href="#险象的分类" class="headerlink" title="险象的分类"></a>险象的分类</h4><p>组合电路中的险象可分为静态险象和动态险象。<br>静态险象：如果在输入变化而输出不应发生变化的情况下，输出端产生了短暂的错误输出，则称为静态险象。<br>动态险象：如果在输入变化而输出应该发生变化的情况下，输出在变化过程中产生了短暂的错误输出，则称为动态险象。</p><p>按错误输出脉冲信号的极性可分为“0”型险象与“1”型险象。</p><ul><li>“0”型险象：错误输出信号为负脉冲。</li><li>“1”型险象：错误输出信号为正脉冲。</li></ul><h4 id="险象的判断"><a href="#险象的判断" class="headerlink" title="险象的判断"></a>险象的判断</h4><p>判断电路是否可能产生险象的方法有代数法和卡诺图法。</p><p>代数法：</p><ul><li>检查函数表达式中是否存在具备竞争条件的变量，即<br>是否有某个变量$X$同时以原变量和反变量的形式出现在函数表达式中。</li><li>若存在具备竞争条件的变量$X$，则消去函数式中的其<br>他变量,看函数表达式是否会变为 $X+\overline{X}$ 或者 $X\cdot \overline{X}$ 的形式。若会，则说明对应的逻辑电路可能产生险象。</li></ul><p>卡诺图法：作出函数卡诺图，并画出和函数表达式中各“与”项对应的卡诺圈。若卡诺圈之间存在“相切”关系，即两卡诺圈之间存在不被同一卡诺圈包含的相邻最小项，则该电路可能产生险象。</p><h4 id="险象的消除"><a href="#险象的消除" class="headerlink" title="险象的消除"></a>险象的消除</h4><p>一、 用增加冗余项的方法消除险象</p><p>增加冗余项的方法是，通过在函数表达式中“或”上冗余的“与”项或者“与”上冗余的“或”项，消除可能产生的险象。<br>冗余项的选择可以采用代数法或者卡诺图法确定。</p><p>二、  增加惯性延时环节</p><p>三、 选通法</p><h2 id="同步时序逻辑电路"><a href="#同步时序逻辑电路" class="headerlink" title="同步时序逻辑电路"></a>同步时序逻辑电路</h2><p>略</p><h2 id="异步时序逻辑电路"><a href="#异步时序逻辑电路" class="headerlink" title="异步时序逻辑电路"></a>异步时序逻辑电路</h2><p>略</p><hr><p>$$<br>\mathscr{THE} \quad \mathscr{END}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率论</title>
    <link href="/archives/155618b9.html"/>
    <url>/archives/155618b9.html</url>
    
    <content type="html"><![CDATA[<p>概率论的重要性就不用说了吧。</p><span id="more"></span><h1 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h1><h2 id="概率论的基本概念"><a href="#概率论的基本概念" class="headerlink" title="概率论的基本概念"></a>概率论的基本概念</h2><h3 id="随机试验，样本空间，随机事件"><a href="#随机试验，样本空间，随机事件" class="headerlink" title="随机试验，样本空间，随机事件"></a>随机试验，样本空间，随机事件</h3><p>随机试验：满足相同条件下可重复，能事先明确试验所有可能结果，在一次试验前无法确定哪一个结果出现的试验称为随机试验。</p><p>样本空间：将随机试验 $E$ 的所有可能结果组成的集合称为 $E$ 的样本空间。 $E$ 的每个结果称为样本点。</p><p>随机事件：称试验 $E$ 的样本空间 $S$ 的子集为 $E$ 的随机事件。</p><p>和事件，积事件，差时间，互斥事件与对立事件</p><p>交换律，结合律，分配律，德摩根律</p><h3 id="频率与概率"><a href="#频率与概率" class="headerlink" title="频率与概率"></a>频率与概率</h3><p>频率：相同条件下，进行了 $n$ 次试验，事件 $A$ 发生的次数 $n_A$ 称为事件 $A$ 发生的频数，比值 $\frac{n_A}{n}$ 称为事件 $A$ 发生的频率，记为 $f_{n}(A)$ 。</p><p>概率：设 $E$ 是随机事件， $S$ 是它的样本空间。对于 $E$ 的每一个事件 $A$ 赋予一个实数，记为 $P(A)$ ，称为事件 $A$ 的概率，如果集合函数 $P(\cdot)$ 满足以下条件：</p><p>（1）非负性：对于每个事件 $A$ ，有 $P(A)\geq 0$ 。</p><p>（2）规范性：对于必然事件 $S$ ，有 $P(S)=1$ 。</p><p>（3）可列可加性：设 $A_1,A_2,\cdots$ 是两两不相容的事件，即对于 $A_{i}A_{j}=\emptyset ,i\neq j,i,j=1,2,\cdots$ ，有<br>$$<br>P(A_1\cup A_2\cup \cdots)=P(A_1)+P(A_2)+\cdots<br>$$</p><p>加法公式：对于任意两事件 $A,B$ 有</p><p>$$<br>P(A\cup B)=P(A)+P(B)-P(AB)<br>$$</p><h3 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h3><p>当随机试验满足样本空间内只有有限个元素，且每个基本事件发生的可能性相同，则称为等可能概型，又称古典概型。</p><p>超几何分布</p><h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p>条件概率：设 $A,B$ 是两个事件，且 $P(A)&gt;0$ ，称</p><p>$$<br>P(B|A)=\dfrac{P(AB)}{P(A)}<br>$$</p><p>为在事件 $A$ 发生的条件下事件 $B$ 发生的条件概率。</p><p>乘法定理：设 $P(A)&gt;0$ ，则有 $P(AB)=P(B|A)P(A)$ 。</p><p>乘法定理可以推广到多个事件的积事件的情况。</p><p>全概率公式：设试验 $E$ 的样本空间为 $S$ ， $A$ 为 $E$ 的事件， $B_1,B_2,\cdots ,B_n$ 为 $S$ 的一个划分，且 $P(B_i)&gt;0\quad (i=1,2,\cdots ,n)$ ，则</p><p>$$<br>P(A) = P(A|B_1)P(B_1)+P(A|B_2)P(B_2) + \cdots + P(A|B_n)P(B_n)<br>$$</p><p>贝叶斯公式：设试验 $E$ 的样本空间为 $S$ ， $A$ 为 $E$ 的事件， $B_1,B_2,\cdots ,B_n$ 为 $S$ 的一个划分，且 $P(A)&gt;0,P(B_i)&gt;0\quad (i=1,2,\cdots ,n)$ ，则</p><p>$$<br>P(B_i|A)=\dfrac{P(A|B_i)P(B_i)}{\displaystyle\sum_{j=1}^{n}{P(A|B_j)P(B_j)}},i=1,2,\cdots,n<br>$$</p><p>其中 $P(B_i)$ 称为先验概率， $P(B_i|A)$ 称为后验概率， $P(A|B_i)$ 称为似然概率。</p><h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><p>独立：设 $A,B$ 是两事件，如果满足等式 $P(AB)=P(A)P(B)$ ，则称事件 $A,B$ 相互独立。简称 $A,B$ 独立。</p><p>设 $A,B$ 是两事件，且 $P(A)&gt;0$ 。若 $A,B$ 相互独立，则 $P(B|A)=P(B)$ 。反之亦然。</p><p>若事件 $A$ 与 $B$ 相互独立，则下边各对事件也相互独立：</p><p>$$<br>A\text{与} \overline{B} \quad \overline{A}\text{与} {B} \quad \overline{A}\text{与} \overline{B}<br>$$</p><p>一般的，设 $A_1,A_2,\cdots,A_n$ 是 $n$ 个事件，如果对于其中任意2个，任意3个，···，任意 $n$ 个事件的积事件的概率，都等于各事件概率之积，则称事件 $A_1,A_2,\cdots,A_n$ 相互独立。</p><h2 id="随机变量及其分布"><a href="#随机变量及其分布" class="headerlink" title="随机变量及其分布"></a>随机变量及其分布</h2><h3 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h3><p>随机变量：设随机试验的样本空间为 $S=\{ e \}$ 。 $X=X(e)$ 是定义在样本空间 $S$ 上的实值单值函数。称 $X=X(e)$ 为随机变量。</p><h3 id="离散型随机变量及其分布律"><a href="#离散型随机变量及其分布律" class="headerlink" title="离散型随机变量及其分布律"></a>离散型随机变量及其分布律</h3><p>离散型随机变量：有些随机变量，它全部可能取到的值为有限个或可列的无限多个，这种随机变量称为离散型随机变量。</p><p>离散型随机变量的分布律</p><p>一：两点分布</p><p>设随机变量 $X$ 只可能取0与1两个值，它的分布律是</p><p>$$<br>P\{X=k\}=p^k(1-p)^{1-k},k=0,1 (0&lt;p&lt;1)<br>$$</p><p>则称 $X$ 服从以 $p$ 为参数的 $(0-1)$ 分布或两点分布。</p><p>二：二项分布</p><p>设试验 $E$ 只有两个可能结果： $A$ 和 $\overline{A}$ ，则称 $E$ 为伯努利试验。设 $P(A)=p(0&lt;p&lt;1)$ ，此时 $P(\overline{A})=1-p$ 。将 $E$ 独立重复地进行 $n$ 次，称这串试验为 $n$ 重伯努利试验。</p><p>以 $X$ 表示 $n$ 重伯努利试验中事件 $A$ 发生的次数， $X$ 是一个随机变量，分布律为</p><p>$$<br>P\{ X=k \}=\binom{n}{k}p^k(1-p)^{n-k},k=0,1,2,\cdots,n<br>$$</p><p>称随机变量 $X$ 服从参数为 $n,p$ 的二项分布，记为 $X\sim b(n,p)$ 。</p><p>三：泊松分布</p><p>设随机变量 $X$ 所有可能取的值为 $0,1,2,\cdots$ ，而取各个值的概率为</p><p>其中 $\lambda &gt;0$ 是常数。则称 $X$ 服从参数 $\lambda$ 的泊松分布，记为 $X\sim \pi(\lambda)$ 。</p><p>泊松定理：设 $\lambda &gt;0$ 是一个常数， $n$ 是任意正整数，设 $np_{n}=\lambda$ ，则对于任一固定的非负整数 $k$ ，有</p><p>$$<br>\lim_{n\to \infty}{\binom {n}{k}p^{k}_{n}(1-p_n)^{n-k}=\dfrac{\lambda^ke^{-\lambda}}{k!}}<br>$$</p><h3 id="随机变量的分布函数"><a href="#随机变量的分布函数" class="headerlink" title="随机变量的分布函数"></a>随机变量的分布函数</h3><p>分布函数：设 $X$ 是一个随机变量， $x$ 是任意实数，函数<br>$$F(x)=P\{x\leq x\},-\infty&lt;x&lt;\infty$$<br>称为 $X$ 的分布函数。</p><h3 id="连续型随机变量及其概率密度"><a href="#连续型随机变量及其概率密度" class="headerlink" title="连续型随机变量及其概率密度"></a>连续型随机变量及其概率密度</h3><p>连续型随机变量：如果对于随机变量 $X$ 的分布函数 $F(x)$ ，存在非负可积函数 $f(x)$ ，使对于任意实数 $x$ 有</p><p>$$<br>F(x)=\int_{-\infty}^{x}f(t)\mathrm{d}t<br>$$</p><p>则称 $X$ 为连续型随机变量， $f(x)$ 称为 $X$ 的概率密度函数，简称概率密度。</p><p>一：均匀分布</p><p>若连续型随机变量 $X$ 具有概率密度<br>$$f(x)=\begin{cases}\dfrac{1}{b-a},a&lt;x&lt;b\\ 0,\text{其他}\end{cases}$$<br>则称 $X$ 在区间 $(a,b)$ 上服从均匀分布，记为 $X\sim U(a,b)$ 。</p><p>二：指数分布</p><p>若连续型随机变量 $X$ 的概率密度为<br>$$f(x)=\begin{cases}\dfrac{1}{\theta}e^{-\frac{x}{\theta}},x&gt;0<br>\\ 0,\text{其他}\end{cases}$$<br>其中 $\theta&gt;0$ 为常数，则称 $X$ 服从参数为 $\theta$ 指数分布。</p><p>指数分布具有无记忆性。</p><p>三：正态分布</p><p>若连续型随机变量 $X$ 的概率密度为<br>$$f(x)=\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\dfrac{(x-\mu)^2}{2\sigma^2}},-\infty&lt;x&lt;+\infty$$<br>其中 $\mu ,\sigma$ 为常数，则称 $X$ 服从参数为 $\mu ,\sigma$ 的正态分布或高斯分布，记为 $X\sim N(\mu,\sigma)$ 。</p><ol><li>曲线关于 $x=\mu$ 对称，这表明对于任意 $h&gt;0$ 有<br>$$P\{ \mu -h&lt;X\leq \mu \}=P\{ \mu&lt;X\leq \mu +h \}$$</li><li>当 $x=\mu $ 时取到最大值<br>$$f(\mu)=\dfrac{1}{\sqrt{2\pi}\sigma}$$</li></ol><p>特别的，当 $\mu =0,\sigma =1$ 时，称随机变量 $X$ 服从标准正态分布。其概率密度和分布密度分别用 $\varphi ,\varPhi$ 表示，即有<br>$$\varphi(x)=\dfrac{1}{\sqrt{2\pi}}\mathrm{e}^{-\frac{x^2}{2}}$$<br>$$<br>\varPhi(x)=\dfrac{1}{\sqrt{2\pi}}\int_{-\infty}^{x}\mathrm{e}^{-\frac{t^2}{2}}\mathrm{d}t<br>$$</p><p>易知 $\varPhi(-x)=1-\varPhi(x)$ 。</p><p>引理：若 $X\sim N(\mu,\sigma ^2)$ ，则 $Z=\dfrac{X-\mu}{\sigma}\sim N(0,1)$ 。</p><h3 id="随机变量的函数的分布"><a href="#随机变量的函数的分布" class="headerlink" title="随机变量的函数的分布"></a>随机变量的函数的分布</h3><p>定理：设随机变量 $X$ 具有概率密度 $f_X(x),-\infty &lt; x&lt;\infty $ ，又设函数 $g(x)$ 处处可导且恒有 $g^{\prime}(x)&gt;0$ （或恒有 $g^{\prime}(x)&lt;0$ ），则 $Y=g(X)$ 是连续型随机变量，其概率密度为<br>$$<br>f_Y(y)=\begin{cases}<br>f_X[h(y)]|h^{\prime}(y)|,\alpha&lt;y&lt;\beta \\ 0,\text{其他}<br>\end{cases}<br>$$<br>其中 $\alpha =\min\{ g(-\infty),g(\infty) \}$ ， $\beta =\max\{ g(-\infty),g(\infty) \}$ ， $h(y)$ 是 $g(x)$ 的反函数。</p><h2 id="多维随机变量及其分布"><a href="#多维随机变量及其分布" class="headerlink" title="多维随机变量及其分布"></a>多维随机变量及其分布</h2><h3 id="二维随机变量"><a href="#二维随机变量" class="headerlink" title="二维随机变量"></a>二维随机变量</h3><p>二维随机变量：一般的，设 $E$ 是一个随机试验，它的样本空间是 $S=\{ e \}$ ，设 $X=X(e)$ 和 $Y=Y(e)$ 是定义在 $S$ 上的随机变量，由它们构成的一个向量 $(X,Y)$ ，叫做二维随机向量或二维随机变量。</p><p>定义：设 $(X,Y)$ 是二维随机变量，对于任意实数 $x,y$ ，二元函数：<br>$$<br>F(x,y)=P\{ (X\leq x)\cap (Y \leq y) \}=P\{ X\leq x,Y\leq y \}<br>$$<br>称为二维随机变量 $(X,Y)$ 的分布函数，或称为随机变量 $X$ 和 $Y$ 的联合分布函数。</p><p>分布函数 $F(x,y)$ 具有以下基本性质：</p><ol><li> $F(x,y)$ 是变量 $x$ 和 $y$ 的不减函数，即对于任意固定的 $y$ ，当 $x_2&gt;x_1$ 时 $F(x_2,y)\geq F(x_1,y)$ ；对于任意固定的 $x$ ，当 $y_2&gt;y_1$ 时 $F(x,y_2)\geq F(x,y_1)$ 。</li><li> $0\leq F(x,y)\leq 1$ ，且对于任意固定的 $y$ ， $F(-\infty ,y)=0$ 。对于任意固定的 $x$ ， $F(x,-\infty)=0$ 。 $F(-\infty,-\infty)=0$ ， $F(\infty ,\infty)=1$ 。</li><li> $F(x+0,y)=F(x,y)$ ， $F(x,y+0)=F(x,y)$ ，即 $F(x,y)$ 关于 $x$ 右连续，关于 $y$ 也右连续。</li><li>对于任意 $(x_1,y_1)$ ， $(x_2,y_2)$ ， $x_1&lt;x_2$ ， $y_1&lt;y_2$ ，下述不等式成立：<br>$$F(x_2,y_2)-F(x_2,y_1)+F(x_1,y_1)-F(x_1,y_2)\geq 0$$</li></ol><p>如果二维随机变量 $(X,Y)$ 全部可能取到的值是有限对或可列无限多对，则称 $(X,Y)$ 是离散型的随机变量。</p><p>分布律：设二维随机变量 $(X,Y)$ 所有可能取的值为 $(x_i,y_j),i,j=1,2.\cdots$ ，记 $P\{ X=x_i,Y=y_i \}=p_{ij},i,j=1,2,\cdots$ ，则由概率的定义有<br>$$<br>p_{ij}\geq 0,\sum_{i=1}^{\infty}\sum_{j=1}^{\infty}p_{ij}=1<br>$$<br>我们称 $P\{ X=x_i,Y=y_i \}=p_{ij},i,j=1,2,\cdots$ 为二维离散型随机变量 $(X,Y)$ 的分布律，或称为随机变量 $X$ 和 $Y$ 的联合分布律。</p><p>将 $(X,Y)$ 看成一个随机点的坐标，离散型随机变量 $X$ 和 $Y$ 的联合分布函数为<br>$$<br>F(x,y)=\sum_{x_i\leq x}\sum_{y_i\leq y}p_{ij}<br>$$<br>其中和式是对一切满足 $x_i\leq x,y_i\leq y$ 的 $i,j$ 来求和的。</p><p>对于二维随机变量 $(X,Y)$ 的分布函数 $F(x,y)$ ，如果存在非负的可积函数 $f(x,y)$ 使对于任意 $x,y$ 有<br>$$<br>F(x,y)=\int_{-\infty}^{y}\int_{-\infty}^{x}f(u,v)\mathrm{d}u\mathrm{d}v<br>$$<br>则称 $(X,Y)$ 是连续型的二维随机变量，函数 $f(x,y)$ 称为二维随机变量 $(X,Y)$ 的概率密度，或称为随机变量 $X$ 和 $Y$ 的联合概率密度。</p><p>概率密度 $f(x,y)$ 有以下性质：</p><ol><li> $f(x,y)\geq 0$ 。</li><li> $\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}f(x,y)\mathrm{d}x\mathrm{d}y=F(\infty,\infty)=1$ 。</li><li>设 $G$ 是 $xOy$ 平面上的区域，点 $(X,Y)$ 落在 $G$ 内的概率为：<br>$$<br>P\{ (X,Y)\in G \}=\iint_{G}f(x,y)\mathrm{d}x\mathrm{d}y<br>$$</li><li>若 $f(x,y)$ 在点 $(x,y)$ 连续，则有：<br>$$<br>\frac{\partial^2 F(x,y)}{\partial x\partial y}=f(x,y)<br>$$</li></ol><p>一般，设 $E$ 是一个随机试验，它的样本空间是 $S=\{ e \}$ ，设 $X_1=X_1(e),\cdots,X_n=X_n(e)$ 是定义在 $S$ 上的随机变量，由它们构成的一个 $n$ 维向量 $(X_1,\cdots,X_n)$ 叫做 $n$ 维随机变量。</p><p>对于任意 $n$ 个实数 $x_1,\cdots,x_n$ ， $n$ 元函数<br>$$<br>F(x_1,\cdots,x_n)=P\{ X_1\leq x_1,\cdots,X_n\leq x_n \}<br>$$<br>称为 $n$ 维随机变量 $(X_1,\cdots,X_n)$ 的分布函数或随机变量 $X_1,\cdots,X_n$ 的联合分布函数。</p><h3 id="边缘分布"><a href="#边缘分布" class="headerlink" title="边缘分布"></a>边缘分布</h3><p>边缘分布律：对于离散型随机变量 $(X,Y)$ ，记</p><p>$$<br>p_{i \cdot} =P\{X=x_i\}=\sum_{j=1}^{\infty}p_{ij} ,i = 1,2,\cdots<br>$$</p><p>$$<br>p_{\cdot j} =P\{X=x_j\}=\sum_{i=1}^{\infty}p_{ij} ,i = 1,2,\cdots<br>$$</p><p>分别称 $p_{i \cdot}$ 和 $p_{\cdot j}$ 为 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的边缘分布律。</p><p>边缘概率密度：对于连续型随机变量 $(X,Y)$ ，设它的概率密度为 $f(x,y)$ ，由于<br>$$<br>F_X(x)=F(x,\infty)=\int_{-\infty}^{x}[\int_{-\infty}^{\infty}f(x,y)\mathrm{d}y]\mathrm{d}y<br>$$<br> $X$ 是一个连续型随机变量，且其概率密度为<br>$$<br>f_X(x)=\int_{-\infty}^{\infty}f(x,y)\mathrm{d}y<br>$$</p><p> $Y$ 是一个连续型随机变量，且其概率密度为<br>$$<br>f_Y(y)=\int_{-\infty}^{\infty}f(x,y)\mathrm{d}x<br>$$</p><p> $f_X(x)$ 分别为 $f_Y(y)$ 为 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的边缘概率密度。</p><p>二维正态分布：设二维随机变量 $(X,Y)$ 的概率密度为<br>$$<br>f(x,y)=\dfrac{1}{2\pi \sigma_1 \sigma_2 \sqrt{1-\rho^2}} \exp\{ \dfrac{-1}{2(1-\rho^2)}[\dfrac{(x-\mu_1)^2}{\sigma_1 ^2}-2\rho \dfrac{(x-\mu_1)(y-\mu_2)}{\sigma_1 \sigma_2}+\dfrac{(y-\mu_2)^2}{\sigma_2 ^2}] \}<br>$$<br>其中 $\mu_1,\mu_2,\sigma_1,\sigma_2,\rho$ 都是常数，且 $\sigma_1 &gt;0,\sigma_2&gt;0,-1&lt;\rho&lt;1$ ，我们称 $(X,Y)$ 为服从参数为 $\mu_1,\mu_2,\sigma_1,\sigma_2,\rho$ 的二维正态分布，记为 $(X,Y)\sim N(\mu_1,\mu_2,\sigma_1,\sigma_2,\rho)$ 。</p><p>二维正态分布的两个边缘分布都是一维正态分布，并且都不依赖与参数 $\rho$ ，亦即对于给定的 $\mu_1,\mu_2,\sigma_1,\sigma_2$ ，不同的 $\rho$ 对于不同的二维正态分布，他们的边缘分布是一样的。</p><h3 id="条件分布"><a href="#条件分布" class="headerlink" title="条件分布"></a>条件分布</h3><p>条件分布律：设 $(X,Y)$ 是二维离散型随机变量，对于固定的 $j$ ，若 $P\{ Y=y_j \}&gt;0$ 则称<br>$$<br>P\{ X=x_i|Y=y_j \}=\dfrac{P\{ X=x_i,Y=y_j \}}{P\{ Y=y_j \}}=\dfrac{p_{ij}}{p_{\cdot j}}<br>$$<br>为在 $Y=y_i$ 条件下随机变量 $X$ 的条件分布律。</p><p>同样的，对于固定的 $i$ ，若 $P\{ X=x_i \}$ ，则称<br>$$<br>P\{ Y=y_j|X=x_i \}=\dfrac{P\{ X=x_i,Y=y_j \}}{P\{ X=x_i \}}=\dfrac{p_{ij}}{p_{i \cdot}}<br>$$<br>为在 $X=x_i$ 条件下随机变量 $Y$ 的条件分布律。</p><p>条件概率密度：设二维随机变量 $(X,Y)$ 的概率密度为 $f(x,y)$ ， $(X,Y)$ 关于 $Y$ 的边缘概率密度为 $f_Y(y)$ 。若对于固定的 $y,f_Y(y)&gt;0$ ，则称 $\dfrac{f(x,y)}{f_Y(y)}$ 为在 $Y=y$ 的条件下 $X$ 的条件概率密度，记为<br>$$<br>f_{X|Y}(x|y)=\dfrac{f(x,y)}{f_Y(y)}<br>$$<br>称 $\int_{-\infty}^{x}f_{X|Y}(x|y)\mathrm{d}x=\int_{-\infty}^{x}\dfrac{f(x,y)}{f_Y(y)}\mathrm{d}x$ 为在 $Y=y$ 的条件下 $X$ 的条件分布函数，记为 $P\{ X\leq x| Y=y \}$ 或 $F_{X|Y}(x|y)$ ，即</p><p>$$<br>F_{X|Y}(x|y)=P\{ X\leq x|Y=y \} = \int_{-\infty}^{x}\dfrac{f(x,y)}{f_Y(y)}\mathrm{d}x<br>$$</p><p>类似的，可以定义 $f_{Y|X}(y|x)=\dfrac{f(x,y)}{f_Y(x)}$ 和 $F_{Y|X}(y|x)=\int_{-\infty}^{y}\dfrac{f(x,y)}{f_X(x)}$ 。</p><h3 id="相互独立的随机变量"><a href="#相互独立的随机变量" class="headerlink" title="相互独立的随机变量"></a>相互独立的随机变量</h3><p>独立：设 $F(x,y)$ 及 $F_X(x)$ ， $F_Y(y)$ 分别是二维随机变量 $(X,Y)$ 的分布函数及边缘分布函数，若对于所有的 $x,y$ 有<br>$$<br>P\{ X\leq x,Y\leq y \}=P\{ X\leq x \}P\{ Y\leq y \}<br>$$<br>即， $F(x,y)=F_X(x)F_Y(y)$ 。<br>则称随机变量 $X$ 和 $Y$ 是相互独立的。</p><p>设 $(X,Y)$ 是连续型随机变量， $f(x,y)$ ， $f_X(x)$ ， $F_Y(y)$ 分别为 $(X,Y)$ 的概率密度和边缘概率密度，则 $X$ 和 $Y$ 相互独立的条件等价于：等式<br>$$<br>f(x,y)=f_X(x)f_Y(y)<br>$$<br>在平面上几乎处处成立（指平面上除去“面积”为零的集合）。</p><p>当 $(X,Y)$ 是离散型随机变量时， $X$ 和 $Y$ 相互独立的条件等价于：对于 $(X,Y)$ 的所有可能取的值 $(x_i,y_j)$ 有，</p><p>$$<br>P\{X=x_i,Y=y_j\}=P\{ X=x_i \}P\{ Y=y_j \}<br>$$</p><p>对于二维正态随机变量 $(X,Y)$ ， $X$ 和 $Y$ 相互独立的充要条件是参数 $\rho = 0$ 。</p><p>二维随机变量相互独立可以推广到多维形式，这里不做赘述。</p><p>定理：设 $(X_1,X_2,\cdots,X_m)$ 和 $(Y_1,Y_2,\cdots,Y_n)$ 相互独立，则 $X_i,(i=1,2,\cdots,m)$ 和 $Y_i,(j=1,2,\cdots,n)$ 相互独立。又若 $h,g$ 是连续函数，则 $h(X_1,X_2,\cdots,X_m)$ 和 $g(Y_1,Y_2,\cdots,Y_n)$ 相互独立。</p><h3 id="两个随机变量的函数分布"><a href="#两个随机变量的函数分布" class="headerlink" title="两个随机变量的函数分布"></a>两个随机变量的函数分布</h3><p>一： $Z=X+Y$ 的分布</p><p>设 $(X,Y)$ 是二维连续型随机变量，它具有概率密度 $f(x,y)$ 。则 $Z=X+Y$ 仍为连续型随机变量，其概率密度为<br>$$<br>f_{X+Y}(z)=\int_{-\infty}^{\infty}f(z-y,y)\mathrm{d}y<br>$$<br>或<br>$$<br>f_{X+Y}(z)=\int_{-\infty}^{\infty}f(x,z-x)\mathrm{d}x<br>$$<br>又若 $X$ 和 $Y$ 相互独立，设 $(X,Y)$ 关于 $X,Y$ 的边缘密度分别为 $f_X(x),f_Y(y)$ ，则<br>$$<br>f_{X+Y}(z)=\int_{-\infty}^{\infty}f_X(z-y)f_Y(y)\mathrm{d}y<br>$$<br>和<br>$$<br>f_{X+Y}(z)=\int_{-\infty}^{\infty}f_X(x)f_Y(z-x)\mathrm{d}x<br>$$<br>这两个公式称为 $f_X$ 和 $f_Y$ 的卷积公式，记为 $f_X\ast f_Y$ 。即<br>$$<br>f_X\ast f_Y=\int_{-\infty}^{\infty}f_X(z-y)f_Y(y)\mathrm{d}y=\int_{-\infty}^{\infty}f_X(x)f_Y(z-x)\mathrm{d}x<br>$$<br>若 $X_i\sim N(\mu_i,\sigma_i^2),(i=1,\cdots,n)$ ，且它们相互独立，则它们的和 $Z=X_1+\cdots+X_n$ 仍然服从正态分布，且有 $Z\sim N(\mu_1+\cdots+\mu_n,\sigma_1^2+\cdots+\sigma_n^2)$ 。</p><p>更一般的，可以证明有限个相互独立的正态随机变量的线性组合仍然服从正态分布。</p><p>二： $Z=\dfrac{Y}{X}$ 的分布， $Z=XY$ 的分布</p><p>设 $(X,Y)$ 是二维连续型随机变量，它具有概率密度 $f(x,y)$ ，则 $Z=\dfrac{Y}{X}$ ， $Z=XY$ 仍然为连续型随机变量，其概率密度为<br>$$<br>f_{\frac{Y}{X}}(z)=\int_{-\infty}^{\infty} |x| f(x,xz)\mathrm{d}x<br>$$<br>$$<br>f_{XY}(z)=\int_{-\infty}^{\infty} \frac{1}{|x|} f(x,\frac{z}{x})\mathrm{d}x<br>$$<br>又若 $X$ 和 $Y$ 相互独立，设 $(X,Y)$ 关于 $X,Y$ 的边缘密度分别为 $f_X(x),f_Y(y)$ ，则<br>$$<br>f_{\frac{Y}{X}}(z)=\int_{-\infty}^{\infty} |x| f_X(x)f_Y(xz)\mathrm{d}x<br>$$<br>$$<br>f_{XY}(z)=\int_{-\infty}^{\infty} \frac{1}{|x|} f_X(x)f_Y(\frac{z}{x})\mathrm{d}x<br>$$<br>三： $M=\max \{ X,Y \}$ 及 $N = \min \{ X,Y \}$ 的分布</p><p>设 $(X,Y)$ 是两个相互独立的随机变量，它们的分布函数分别为 $F_X(x)$ 和 $F_Y(y)$ 。现在来求 $M=\max \{ X,Y \}$ 及 $N = \min \{ X,Y \}$ 的分布函数。<br>由于 $M=\max \{ X,Y \}$ 不大于 $z$ 等价于 $X$ 和 $Y$ 都不大于 $z$ ，故有<br>$$<br>P\{ M\leq z \}=P\{ X\leq z,Y\leq z \}<br>$$<br>又由于 $X$ 和 $Y$ 相互独立，得到 $M=\max \{ X,Y \}$ 的分布函数为<br>$$<br>F_{\max}(z)=P\{ M\leq z \}=P\{ X\leq z,Y\leq z \}=P\{ X\leq z \} P\{ Y\leq z \}<br>$$<br>即有 $F_{\max}(z)=F_X(z)F_Y(z)$ 。</p><p>类似的，可得 $N = \min \{ X,Y \}$ 的分布函数为<br>$$<br>F_{\min}(z)=P\{ N\leq z \} = 1-P\{ N&gt;z \}=1-P\{ X&gt;z,Y&gt;z \}=1-P\{ X&gt;z \}P\{ Y&gt;z \}<br>$$<br>即 $F_{\min}(z)=1-[1-F_X(z)][1-F_Y(z)]$ 。</p><p>设 $X_1\cdots,X_n$ 是 $n$ 个相互独立的随机变量，它们的分布函数分别为 $F_{X_i}(x_i),(i=1,\cdots,n)$ ，则 $M=\max \{ X,Y \}$ 及 $N = \min \{ X,Y \}$ 的分布函数分别为<br>$$<br>F_{\max}(z)=F_{X_1}(z)\cdots F_{X_n}(z)<br>$$</p><p>$$<br>F_{\min}(z)=1-[1-F_{X_1}(z)]\cdots [1-F_{X_n}(z)]<br>$$<br>特别的，当 $X_1\cdots,X_n$ 相互独立且具有相同的分布函数 $F(x)$ 时有<br>$$<br>F_{\max}(z)=[F(z)]^n<br>$$</p><p>$$<br>F_{\min}(z)=1-[1-F(z)]^n<br>$$</p><h2 id="随机变量的数字特征"><a href="#随机变量的数字特征" class="headerlink" title="随机变量的数字特征"></a>随机变量的数字特征</h2><h3 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h3><p>数学期望：设离散型随机变量 $X$ 的分布律为 $P\{ X=x_k \}=p_k,k=1,2,\cdots$ 。若级数 $\sum_{k=1}^{\infty}x_kp_k$ 绝对收敛，则称级数 $\sum_{k=1}^{\infty}x_kp_k$ 的和为随机变量 $X$ 的数学期望，记为 $E(X)$ ，即 $E(X)=\sum_{k=1}^{\infty}x_kp_k$ 。<br>设连续型随机变量 $X$ 的概率密度为 $f(x)$ ，若积分 $\int_{-\infty}^{\infty}xf(x)\mathrm{d}x$ 绝对收敛，则称积分 $\int_{-\infty}^{\infty}xf(x)\mathrm{d}x$ 的值为随机变量 $X$ 的数学期望，记为 $E(X)$ ，即 $E(X)=\int_{-\infty}^{\infty}xf(x)\mathrm{d}x$ 。<br>数学期望简称期望，又称为均值。</p><p>定理：设 $Y$ 是随机变量 $X$ 的函数： $Y=g(X)$ （ $g$ 是连续函数）。</p><ol><li>如果 $X$ 是离散型随机变量，它的分布律为 $P\{ X=x_k \}=p_k,k=1,2,\cdots$ 。若 $\sum_{k=1}^{\infty}g(x_k)p_k$ 绝对收敛，则有<br>$$<br>E(Y)=E[g(X)]=\sum_{k=1}^{\infty}g(x_k)p_k<br>$$</li><li>如果 $X$ 是连续型随机变量，它的概率密度为 $f(x)$ ，若 $\int_{-\infty}^{\infty}f(x)\mathrm{d}x$ 绝对收敛，则有<br>$$<br>E(Y)=E[g(X)]=\int_{-\infty}^{\infty}g(x)f(x)\mathrm{d}x<br>$$</li></ol><p>定理：设 $Z$ 是随机变量 $X,Y$ 的函数 $Z=g(X,Y)$ （ $g$ 是连续函数），那么， $Z$ 是一个一维随机变量。若二维随机变量 $(X,Y)$ 的概率密度为 $f(x,y)$ ，则有<br>$$<br>E(Z)=E[g(X,Y)]=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}g(x,y)f(x,y)\mathrm{d}x\mathrm{d}y<br>$$<br>这里设上式右边的积分绝对收敛，又若 $(X,Y)$ 为离散型随机变量，其分布律为 $P\{ X=x_i,Y=y_i \}=p_{ij},i,j=1,2,\cdots$ ，则有<br>$$<br>E(Z)=E[g(X,Y)]=\sum_{j=1}^{\infty}\sum_{i=1}^{\infty}g(x_i,y_i)p_{ij}<br>$$<br>这里设上式右边的级数绝对收敛。</p><p>数学期望的几个重要性质：</p><ol><li>设 $C$ 是常数，则有 $E(C)=C$ 。</li><li>设 $X$ 是一个随机变量， $C$ 是常数，则有 $E(CX)=cE(X)$ 。</li><li>设 $X,Y$ 是两个随机变量，则有 $E(X+Y)=E(X)+E(Y)$ 。</li><li>设 $X,Y$ 是相互独立的随机变量，则有 $E(XY)=E(x)E(Y)$ 。</li></ol><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p>方差：设 $X$ 是一个随机变量，若 $E\{ [X-E(X)]^2 \}$ 存在，则称 $E\{ [X-E(X)]^2 \}$ 为 $X$ 的方差，记为 $D(X)$ 或 $\mathrm{Var}(X)$ ，即<br>$$<br>D(X)=\mathrm{Var}(X)=E\{[X-E(X)]^2\}<br>$$<br>在应用上还引入量 $\sqrt{D(X)}$ ，记为 $\sigma(X)$ ，称为标准差或均方差。</p><p>对于离散型随机变量，有<br>$$<br>D(X)=\sum_{k=1}^{\infty}[x_k-E(X)]^2p_k<br>$$<br>其中 $P\{ X=x_k \}=p_k,k=1,2,\cdots $ 是 $X$ 的分布律。</p><p>对于连续型随机变量，有<br>$$<br>D(X)=\int_{-\infty}^{\infty}[x-E(X)]^2f(x)\mathrm{d}x<br>$$<br>其中 $f(x)$ 是 $X$ 的概率密度。</p><p>随机变量的方差可按下列公式计算<br>$$<br>D(X)=E(X^2)-[E(X)]^2<br>$$<br>设随机变量 $X$ 具有数学期望 $E(X)=\mu$ ，方差 $D(X)=\sigma^2\neq 0$ 。记<br>$$<br>X^*=\dfrac{X-\mu}{\sigma}<br>$$<br>则<br>$$<br>E(X^*)=\dfrac{1}{\sigma}E(X-\mu)=\dfrac{1}{\sigma}[E(X)-\mu]=0<br>$$</p><p>$$<br>D(X^*)=E(X^*)-[E(X^*)]^2=E[(\dfrac{X-\mu}{\sigma})^2]=\dfrac{1}{\sigma^2}E[(X-\mu)^2]=1<br>$$<br>即 $X^*$ 的数学期望为0，方差为1. $X^*$ 称为 $X$ 的标准化变量。</p><p>方差的几个重要性质：</p><ol><li><p>设 $C$ 是常数，则 $D(C)$ 。</p></li><li><p>设 $X$ 是随机变量， $C$ 是常数，则有<br>$D(CX)=C^2D(X),D(X+c)=D(X)$  </p></li><li><p>设 $X,Y$ 是两个随机变量，则有<br>$$<br>D(X+Y)=D(X)+D(Y)+2E\{ (X-E(X))(Y-E(Y)) \}<br>$$<br>特别的，若 $X,Y$ 相互独立，则有<br>$$<br>D(X+Y)=D(X)+D(Y)<br>$$<br>这一性质可以推广到任意有限多个相互独立的随机变量之和的情况。</p></li><li><p>$D(X)=0$ 的充要条件设 $X$ 以概率1取常数 $E(X)$ ，即<br>$$<br>P\{ X=E(X) \}=1<br>$$</p></li></ol><p>切比雪夫不等式：设随机变量 $X$ 具有数学期望 $E(X)=\mu$ ，方差 $D(X)=\sigma^2$ ，则对于任意正数 $\varepsilon$ ，不等式 $P\{ |X-\mu|\geq \varepsilon \}\leq \frac{\sigma^2}{\varepsilon^2}$ 成立。</p><p>常见的概率分布：</p><table><thead><tr><th>分布</th><th>参数</th><th>分布律或概率密度</th><th>数学期望</th><th>方差</th></tr></thead><tbody><tr><td>$(0-1)$分布</td><td>$0&lt;p&lt;1$</td><td>$P\{  X=k\}=p^k(1-p)^k,k=0,1$</td><td>$p$</td><td>$p(1-p)$</td></tr><tr><td>二项分布</td><td>$n\geq 1,0&lt;p&lt;1$</td><td>$P\{ X=k \}= {n\choose k}p^k(1-p)^{n-k},k=0,1,\cdots,$</td><td>$np$</td><td>$np(1-p)$</td></tr><tr><td>帕斯卡分布</td><td>$r\geq 1,0&lt;p&lt;1$</td><td>$P\{ X=k \}={k-1\choose r-1}p^r(1-p)^{k-r},k=r,r+1,\cdots$</td><td>$\frac{1}{p}$</td><td>$\frac{1-p}{p^2}$</td></tr><tr><td>泊松分布</td><td>$\lambda&gt;0$</td><td>$P\{ X=k \}=\frac{\lambda^k\mathrm{e}^{-\lambda}}{k!},k=0,1,2,\cdots$</td><td>$\lambda$</td><td>$\lambda$</td></tr><tr><td>均匀分布</td><td>$a&lt;b$</td><td>$f(x)=\begin{cases} \frac{1}{b-a},a&lt;x&lt;b \\ 0,\text{其他}\end{cases}$</td><td>$\frac{a+b}{2}$</td><td>$\frac{(b-a)^2}{12}$</td></tr><tr><td>正态分布</td><td>$\mu , \sigma(\sigma&gt;0)$</td><td>$f(x)=\frac{1}{\sqrt{2\pi}\sigma}\mathrm{e}^{-(x-\mu)^2/(2\sigma^2)}$</td><td>$\mu$</td><td>$\sigma^2$</td></tr><tr><td>$\Gamma$分布</td><td>$\alpha,\beta&gt;0$</td><td>$f(x)=\begin{cases} \frac{1}{\beta^{\alpha}\Gamma(\alpha)}x^{\alpha-1}\mathrm{e}^{-x/\beta},x&gt;0 \\ 0,\text{其他} \end{cases}$</td><td>$\alpha \beta$</td><td>$\alpha \beta^2$</td></tr><tr><td>超几何分布</td><td>$N,M,n,(M\leq N),(n\leq N)$</td><td>$\frac{C_M^kC_{N-M}^{n-k}}{C_N^k},k\in \mathbb{Z},\mathrm{max} \{ 0,n-N+M \}\leq k\leq \mathrm{min} \{ n,M \}$</td><td>$\frac{nM}{N}$</td><td>$\frac{nM}{N}(1-\frac{M}{N})(\frac{N-n}{N-1})$</td></tr><tr><td>几何分布</td><td>$0&lt;p&lt;1$</td><td>$P\{ X=k \}=(1-p)^{k-1}p,k=1,2,\cdots$</td><td>$\frac{1}{p}$</td><td>$\frac{1-p}{p^2}$</td></tr><tr><td>指数分布</td><td>$\theta&gt;0$</td><td>$f(x)=\begin{cases} \frac{1}{\theta}\mathrm{e}^{-x/\theta},x&gt;0 \\ 0,\text{其他} \end{cases}$</td><td>$\theta$</td><td>$\theta^2$</td></tr><tr><td>$\chi^2$分布</td><td>$n\geq 1$</td><td>$f(x)=\begin{cases} \frac{1}{2^{n/2}\Gamma(n/2)}x^{n/2-1}\mathrm{e}^{-x/2},x&gt;0 \\ 0,\text{其他}\end{cases}$</td><td>$n$</td><td>$2n$</td></tr><tr><td>韦布尔分布</td><td>$\eta&gt;0,\beta&gt;0$</td><td>$f(x)=\begin{cases} \frac{\beta}{\eta}(\frac{x}{\eta})^{\beta -1}\mathrm{e}^{-(\frac{x}{\eta})^\beta},x&gt;0\\ 0,\text{其他} \end{cases}$</td><td>$\eta \Gamma(\frac{1}{\beta}+1)$</td><td>$\eta^2\{ \Gamma(\frac{2}{\beta}+1)-[\Gamma(\frac{1}{\beta}+1)]^2 \}$</td></tr><tr><td>瑞利分布</td><td>$\sigma&gt;0$</td><td>$f(x)=\begin{cases} \frac{x}{\sigma^2}\mathrm{e}^{-x^2/(2\sigma^2)},x&gt;0 \\ 0,\text{其他} \end{cases}$</td><td>$\sqrt{\frac{\pi}{2}}\sigma$</td><td>$\frac{4-\pi}{2}\sigma^2$</td></tr><tr><td>$\beta$分布</td><td>$\alpha&gt;0,\beta&gt;0$</td><td>$f(x)=\begin{cases} \frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)}x^{\alpha-1}(1-x)^{\beta-1},0&lt;x&lt;1 \\ 0,\text{其他} \end{cases}$</td><td>$\frac{\alpha}{\alpha+\beta}$</td><td>$\frac{\alpha\beta}{(\alpha+\beta)^2(\alpha+\beta+1)}$</td></tr><tr><td>对数正态分布</td><td>$\mu,\sigma(\sigma&gt;0)$</td><td>$f(x)=\begin{cases} \frac{1}{\sqrt{2\pi}\sigma x}\mathrm{e}^{-(\ln x-\mu)^2/(2\sigma^2)},x&gt;0 \\ 0,\text{其他} \end{cases}$</td><td>$\mathrm{e}^{\mu+\frac{\sigma^2}{2}}$</td><td>$\mathrm{e}^{2\mu^2+\sigma^2}(\mathrm{e}^{\sigma^2}-1)$</td></tr><tr><td>柯西分布</td><td>$a,\lambda(\lambda&gt;0)$</td><td>$f(x)=\frac{1}{\pi}\frac{\lambda}{\lambda^2+(x-a)^2}$</td><td>不存在</td><td>不存在</td></tr><tr><td>$t$分布</td><td>$n\geq 1$</td><td>$f(x)=\frac{\Gamma(\frac{n+1}{2})}{\sqrt{n\pi}\Gamma(n/2)}(1+\frac{x^2}{n})^{-(n+1)/2}$</td><td>$0,n&gt;1$</td><td>$\frac{n}{n-2},n&gt;2$</td></tr><tr><td>$F$分布</td><td>$n_1,n_2$</td><td>$f(x)=\begin{cases} \frac{\Gamma[(n_1+n_2)/2]}{\Gamma(n_1/2)\Gamma(n_2/2)}(\frac{n_1}{n_2})(\frac{n_1}{n_2}x)^{n_1/2-1}\times (1+\frac{n_1}{n_2}x)^{-(n_1+n_2)/2},x&gt;0 \\ 0.\text{其他} \end{cases}$</td><td>$\frac{n_2}{n_2-2},n&gt;2$</td><td>$\frac{2n_2^2(n_1+n_2-2)}{n_1(n_2-2)^2(n_2-4)},n_2&gt;4$</td></tr></tbody></table><h3 id="协方差及相关系数"><a href="#协方差及相关系数" class="headerlink" title="协方差及相关系数"></a>协方差及相关系数</h3><p>协方差与相关系数：量 $E\{ [X-E(X)][Y-E(Y)] \}$ 称为随机变量 $X$ 与 $Y$ 的协方差。记为 $\mathrm{Cov}(X,Y)$ ，即<br>$$<br>\mathrm{Cov}(X,Y)=E\{ [X-E(X)][Y-E(Y)] \}<br>$$<br>而<br>$$<br>\rho_{XY}=\frac{\mathrm{Cov}(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}<br>$$<br>称为随机变量 $X$ 与 $Y$ 的相关系数。</p><p>由定义，可以知道：<br>$$<br>\mathrm{Cov}(X,Y)=\mathrm{Cov}(Y,X),\mathrm{Cov}(X,X)=D(X)<br>$$<br>对于任意两个随机变量 $X$ 和 $Y$ ，下列等式成立：<br>$$<br>D(X+Y)=D(X)+D(Y)+2\mathrm{Cov}(X,Y)<br>$$<br>将 $\mathrm{Cov}(X,Y)$ 的定义式展开，易得<br>$$<br>\mathrm{Cov}(X,Y)=E(XY)-E(X)E(Y)<br>$$<br>这一式子常常用于计算协方差。</p><p>协方差的性质：</p><ol><li> $\mathrm{Cov}(aX,bY)=ab\mathrm{Cov}(X,Y)$ ， $a,b$ 是常数。</li><li>$$\mathrm{Cov}(X_1+X_2,Y)=\mathrm{Cov}(X_1,Y)+\mathrm{Cov}(X_2,Y)$$</li></ol><p>考虑以 $X$ 的线性函数 $a+bX$ 来近似表示 $Y$ ，我们以均方误差<br>$$<br>e=E[(Y-(a+bX))^2]=E(Y^2)+b^2E(X^2)+a^2-2bE(XY)+2abE(X)-2aE(Y)<br>$$<br>来衡量以 $a+bX$ 近似表达 $Y$ 的好坏程度。 $e$ 的值越小表示 $a+bX$ 与 $Y$ 的近似程度越好。这样，我们就取 $a,b$ 使 $e$ 取到最小，将 $e$ 分别关于 $a,b$ 求偏导数，并令它们等于零，得<br>$$<br>\begin{cases} \dfrac{\partial e}{\partial a}=2a+2bE(X)-2E(Y)=0 \\  \dfrac{\partial e}{\partial b}=2bE(X^2)-2E(XY)+2aE(X)=0  \end{cases}<br>$$<br>解得<br>$$<br>b_0=\dfrac{\mathrm{Cov}(X,Y)}{D(X)},a_0=E(Y)-b_0E(X)=E(Y)-E(X)\dfrac{\mathrm{Cov}(X,Y)}{D(X)}<br>$$<br>将 $A_0,b_0$ 代入 $e$ 的定义式中，有<br>$$<br>\min E\{ [Y-(a+bX)]^2 \}=(1-\rho_{XY}^2)D(Y)<br>$$</p><p>定理： $|\rho_{XY}|\leq 1$ 。</p><p>定理： $|\rho_{XY}|=1$ 的充要条件是，存在常数 $a,b$ 使 $P\{ Y=a+bX \}=1$ 。</p><p>当 $|\rho_{XY}|$ 较大时，称 $X,Y$ 线性相关的程度较好，当 $|\rho_{XY}|$ 较小时， $X,Y$ 线性相关的程度较差。当 $|\rho_{XY}|=1$ 时，称 $X$ 与 $Y$ 不相关。</p><p>当 $X,Y$ 服从二维正态分布时， $X$ 和 $Y$ 不相关与 $X$ 和 $Y$ 相互独立是等价的。</p><h3 id="矩，协方差矩阵"><a href="#矩，协方差矩阵" class="headerlink" title="矩，协方差矩阵"></a>矩，协方差矩阵</h3><p>原点矩：设 $X$ 和 $Y$ 是随机变量，若<br>$$<br>E(X^k),k=1,2,\cdots<br>$$<br>存在，称它为 $X$ 的 $k$ 阶原点矩，简称 $k$ 阶矩。</p><p>中心矩：若<br>$$<br>E\{ [X-E(X)]^k \},k=1,2,3,\cdots<br>$$<br>存在，称它为 $X$ 的 $k$ 阶中心矩。</p><p>混合矩：若<br>$$<br>E(X^kY^l),k,l=1,2,\cdots<br>$$</p><p>存在，称它为 $X$ 和 $Y$ 的 $k+l$ 阶混合矩。</p><p>混合中心矩：若<br>$$<br>E\{ [X-E(X)]^k[Y-E(Y)]^l \},k,l=1,2,\cdots<br>$$<br>存在，称它为 $X$ 和 $Y$ 的 $k+l$ 阶混合中心矩。</p><p>协方差矩阵：设 $n$ 维随机变量 $(X_1,\cdots,X_n)$ 的二阶混合中心矩<br>$$<br>c_{ij}=\mathrm{Cov}(X_i,X_j)=E\{ [X_i-E(X_i)][X_j-E(X_j)] \}<br>$$<br>都存在，则称矩阵<br>$$<br>C=\begin{pmatrix}c_{11}&amp;c_{12}&amp;\cdots &amp;c_{1n} \\ c_{21}&amp;c_{22}&amp;\cdots &amp;c_{2n} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ c_{n1}&amp;c_{n2}&amp;\cdots &amp;c_{nn}\end{pmatrix}<br>$$<br>为 $n$ 维随机变量 $(X_1,\cdots,X_n)$ 的协方差矩阵。</p><h2 id="大数定律及中心极限定理"><a href="#大数定律及中心极限定理" class="headerlink" title="大数定律及中心极限定理"></a>大数定律及中心极限定理</h2><h3 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h3><p>弱大数定理（辛钦大数定理）：设 $X_1,X_2,\cdots$ 是相互独立的，服从同一分布的随机变量序列，且具有数学期望 $E(X_k)=\mu (k=1,2,\cdots)$ 。作前 $n$ 个变量的算术平均 $\frac{1}{n}\sum_{k=1}^nX_k$ ，则对于任意 $\varepsilon&gt;0 $ ，有<br>$$<br>\lim_{n\to \infty}P\{ |\frac{1}{n}\sum_{k=1}^nX_k-\mu| &lt;\varepsilon \}=1<br>$$</p><p>设 $Y_1,Y_2,\cdots$ 是一个随机变量序列， $a$ 是一个常数。若对于任意正数 $\varepsilon$ ，有<br>$$<br>\lim_{n\to \infty}P\{ |Y_n-a|&lt; \varepsilon \}=1<br>$$<br>则称序列 $Y_1,Y_2,\cdots$ 依概率收敛于 $a$ ，记为<br>$$<br>Y_n\stackrel{P}{\longrightarrow} a<br>$$<br>依概率收敛的序列具有以下性质：</p><p>设 $X_n\stackrel{P}{\longrightarrow} a$ ， $Y_n\stackrel{P}{\longrightarrow} b$ ，又设函数 $g(x,y)$ 在点 $(a,b)$ 连续，则<br>$$<br>g(X_n,Y_n)\stackrel{P}{\longrightarrow} g(a,b)<br>$$<br>弱大数定理（辛钦大数定理）：设随机变量 $X_1,X_2,\cdots$ ，相互独立，服从同一分布且具有数学期望 $E(X_k)=\mu (k=1,2,\cdots)$ ，则序列 $\overline{X}=\frac{1}{n}\sum_{k=1}^nX_k$ 依概率收敛于 $\mu $ ，即 $\overline{X} \stackrel{P}{\longrightarrow} \mu $ 。</p><p>伯努利大数定理：设 $f_A$ 是 $n$ 次独立重复试验中事件 $A$ 发生的次数， $p$ 是事件 $A$ 在每次试验中发生的概率，则对于任意正数 $\varepsilon &gt;0$ ，有<br>$$<br>\lim_{n\to \infty}P\{ |\frac{f_A}{n}-p|&lt;\varepsilon \}=1<br>$$<br>或<br>$$<br>\lim_{n\to \infty}P\{ |\frac{f_A}{n}-p|\geq \varepsilon \}=0<br>$$</p><h3 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h3><p>独立同分布的中心极限定理：设随机变量 $X_1,X_2,\cdots$ 相互独立，且服从同一分布，且具有数学期望和方差： $E(X_k)=\mu $ ， $D(X_k)=\sigma^2&gt;0$ ， $(k=1,2,\cdots)$ ，则随机变量之和 $\sum_{k=1}^nX_k$ 的标准化变量<br>$$<br>Y_n=\dfrac{\sum_{k=1}^nX_k-E(\sum_{k=1}^nX_k)}{\sqrt{D(\sum_{k=1}^nX_k)}}<br>$$<br>的分布函数 $F_{n}(x)$ 对于任意 $x$ 满足<br>$$<br>\lim_{n\to \infty}F_n(x)=\lim_{n\to \infty}P\{ \frac{\sum_{k=1}X_k-n\mu}{\sqrt{n}\sigma} \}<br>$$<br>李雅普诺夫定理：设随机变量 $X_1,X_2,\cdots$ 相互独立，它们具有数学期望和方差<br>$$<br>E(X_k)=\mu_k,D(X_k)=\sigma_k^2&gt;0,k=1,2,\cdots<br>$$<br>记<br>$$<br>B_n^2=\sum_{k=1}^n\sigma_k^2<br>$$<br>若存在正数 $\delta$ ，使得当 $n\rightarrow \infty$ 时，<br>$$<br>\frac{1}{B_{n}^{2+\delta}}\sum_{k=1}^nE\{ |X_k-\mu_k|^{2+\delta} \}\rightarrow 0<br>$$<br>则随机变量之和 $\sum_{k=1}^nX_k$ 的标准化变量<br>$$<br>Z_n=\dfrac{\sum_{k=1}^nX_k-\sum_{k=1}^n\mu_k}{B_n}<br>$$<br>的分布函数 $F_n(x)$ 对于任意 $x$ ，满足<br>$$<br>\lim_{n\to \infty}F_n{x}=\lim_{n\to \infty}=\lim_{n\to \infty}P\{ \dfrac{\sum_{k=1}^nX_k-\sum_{k=1}^n\mu_k}{B_n}\leq x \}=\int_{-\infty}^{x}\dfrac{1}{\sqrt{2\pi}}\mathrm{e}^{-t^2/2}\mathrm{d}t=\varPhi(x)<br>$$</p><p>棣莫弗——拉普拉斯定理：设随机变量 $\eta$ 服从参数为 $n,p(0&lt;p&lt;1)$ 的二项分布，则对于任意 $x$ ，有</p><p>$$<br>\lim_{n\to \infty}P\{ \dfrac{\eta_n-np}{\sqrt{np(1-p)}}\leq x \}=\int_{-\infty}^{x}\dfrac{1}{\sqrt{2\pi}}\mathrm{e}^{-t^2/2}\mathrm{d}t=\varPhi(x)<br>$$</p><hr><p>$$<br>\mathscr{THE} \quad \mathscr{END}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>应用数学</category>
      
      <category>概率统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合论</title>
    <link href="/archives/ea132d69.html"/>
    <url>/archives/ea132d69.html</url>
    
    <content type="html"><![CDATA[<p>数学是各个学科的基础，集合论是数学的基础。这不是别人说的，这是我说的。</p><span id="more"></span><h1 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h1><h2 id="集合的基本概念"><a href="#集合的基本概念" class="headerlink" title="集合的基本概念"></a>集合的基本概念</h2><h3 id="集合的定义与表示"><a href="#集合的定义与表示" class="headerlink" title="集合的定义与表示"></a>集合的定义与表示</h3><p>集合：没有精确的数学定义，可以理解为一些离散个体组成的全体，组成集合的个体称为它的元素或成员</p><p>集合的表示</p><ul><li>列元素法 $A={ a, b, c, d }$</li><li>谓词表示法  $B=\{ x | P(x) \}$,$B$ 由使得 $P(x)$ 为真的 $x$ 构成。</li></ul><p>常用数集：<br>$\mathbb{N}, \mathbb{Z}, \mathbb{Q}, \mathbb{R}, \mathbb{C}$ 分别表示自然数、整数、有理数、实数和复数集合，注意 0 是自然数. </p><h3 id="集合与元素"><a href="#集合与元素" class="headerlink" title="集合与元素"></a>集合与元素</h3><p>元素与集合的关系：隶属关系</p><p>属于 $\in$ ，不属于 $\notin$ </p><h3 id="集合之间的关系"><a href="#集合之间的关系" class="headerlink" title="集合之间的关系"></a>集合之间的关系</h3><p>包含（子集）： $A\subseteq B\Leftrightarrow \forall x(x\in A \rightarrow x\in B)$<br>不包含： $A\not \subseteq B\Leftrightarrow \exists x(x\in A\wedge x\notin B)$<br>相等： $A=B\Leftrightarrow A\subseteq B \wedge B\subseteq A$<br>不相等： $A\neq B$<br>真包含： $A\subset B\Leftrightarrow A\subseteq B\wedge A\neq B$<br>不真包含：$A\not\subset B$ </p><h3 id="空集"><a href="#空集" class="headerlink" title="空集"></a>空集</h3><p>空集：不含任何元素的集合。$\varnothing$</p><p>空集是任何集合的子集。</p><p>空集是唯一的。</p><h3 id="全集"><a href="#全集" class="headerlink" title="全集"></a>全集</h3><p>全集：在给定问题中，全集包含任何集合，即 $\forall A(A\subseteq E)$ 。</p><p>相对性</p><h3 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h3><p>幂集： $P(A)=\{ x|x\subseteq A \}$ 。<br>计数：如果 $|A|=n$ ，则 $|P(A)|=2^n$ 。</p><h3 id="集合的基本运算"><a href="#集合的基本运算" class="headerlink" title="集合的基本运算"></a>集合的基本运算</h3><h4 id="集合基本运算的定义"><a href="#集合基本运算的定义" class="headerlink" title="集合基本运算的定义"></a>集合基本运算的定义</h4><p>并： $A\cup B =\{ x|x\in A\vee x\in B \}$<br>交： $A\cap B =\{ x|x\in A\wedge x\in B \}$<br>相对补： $A-B=\{ x|x\in A\wedge x\notin B \}$<br>对称差： $A\oplus B=(A-B)\cup(B-A)$ $=$ $(A\cup B)-(A\cap B)$<br>绝对补： $\sim A=E-A$</p><p>运算顺序： $\sim $ 和幂集优先，其他由括号决定。</p><p>并和交运算可以推广到有穷个集合上，即<br>$$<br>A_1\cup A_2\cup \cdots A_n=\{ x|x\in A_1\vee x\in A_2\vee<br>\cdots \vee x\in A_n \}<br>$$<br>$$<br>A_1\cap A_2\cap \cdots A_n=\{ x|x\in A_1\wedge x\in A_2\wedge \cdots \wedge x\in A_n \}<br>$$<br>一些结果：<br>$$<br>\varnothing \subseteq A-B \subseteq A<br>$$<br>$$<br>A\subseteq B\Leftrightarrow A-B=\varnothing<br>$$<br>$$<br>A\cap B=\varnothing \Leftrightarrow A-B=A<br>$$</p><h4 id="文氏图"><a href="#文氏图" class="headerlink" title="文氏图"></a>文氏图</h4><p><img src="ea132d69/%E6%96%87%E6%B0%8F%E5%9B%BE.jpg" alt="文氏图"></p><h4 id="集合运算的算律"><a href="#集合运算的算律" class="headerlink" title="集合运算的算律"></a>集合运算的算律</h4><table><thead><tr><th>运算律</th><th>$\cup$</th><th>$\cap$</th><th>$\oplus$</th></tr></thead><tbody><tr><td>交换</td><td>$A\cup B =B\cup A$</td><td>$A\cap B =B\cap A$</td><td>$A\oplus B=B\oplus A$</td></tr><tr><td>结合</td><td>$(A\cup B)\cup C=A\cup (B\cup C)$</td><td>$(A\cap B)\cap C=A\cap (B\cap C)$</td><td>$(A\oplus B)\oplus C=A\oplus (B\oplus C)$</td></tr><tr><td>幂等</td><td>$A\cup A=A$</td><td>$A\cap A=A$</td><td></td></tr></tbody></table><table><thead><tr><th>运算律</th><th>$\cup $ 与 $\cap $</th><th>$\cap $ 与 $\oplus$</th></tr></thead><tbody><tr><td>分配</td><td>$A\cup(B\cap C)=(A\cup B)\cap (A\cup C)$,$A\cap (B\cup C)=(A\cap B)\cup (A\cap C)$</td><td>$A\cap(B\oplus C)=(A\cap B)\oplus(A\cap C)$</td></tr><tr><td>吸收</td><td>$A\cup (A\cap B)=A$,$A\cap (A\cup B)=A$</td><td></td></tr></tbody></table><table><thead><tr><th>运算律</th><th>$-$</th><th>$\sim$</th></tr></thead><tbody><tr><td>D.M律</td><td>$A-(B\cup C)=(A-B)\cap (A-C)$,$A-(B\cap C)=(A-B)\cup (A-C)$</td><td>$\sim (B\cup C)=\sim B\cap \sim C$,$\sim(B\cap C)=\sim B\cup \sim C$</td></tr><tr><td>双重否定</td><td></td><td>$\sim \sim A=A$</td></tr></tbody></table><table><thead><tr><th>运算律</th><th>$\varnothing$</th><th>$E$</th></tr></thead><tbody><tr><td>补元律</td><td>$A\cap \sim A = \varnothing$</td><td>$A\cup \sim A = E$</td></tr><tr><td>零律</td><td>$A\cap \varnothing = \varnothing$</td><td>$A\cup E =E$</td></tr><tr><td>同一律</td><td>$A\cup \varnothing =A$</td><td>$A\cap E =A$</td></tr><tr><td>否定</td><td>$\sim \varnothing =E$</td><td>$\sim E=\varnothing$</td></tr></tbody></table><h4 id="集合包含或恒等式的证明"><a href="#集合包含或恒等式的证明" class="headerlink" title="集合包含或恒等式的证明"></a>集合包含或恒等式的证明</h4><p>（1）证明 $X\subseteq Y$</p><ul><li>命题演算法</li><li>包含传递法</li><li>等价条件法</li><li>反证法</li><li>并交运算法</li></ul><p>（2）证明 $X=Y$</p><ul><li>命题演算法</li><li>等式代入法</li><li>反证法</li><li>运算法</li></ul><h3 id="集合中元素的计数"><a href="#集合中元素的计数" class="headerlink" title="集合中元素的计数"></a>集合中元素的计数</h3><h3 id="集合的基数与有穷集合"><a href="#集合的基数与有穷集合" class="headerlink" title="集合的基数与有穷集合"></a>集合的基数与有穷集合</h3><p>集合 $A$ 的基数：集合 $A$ 中的元素数，记作 $\mathrm{card}A$<br>有穷集 $A$： $\mathrm{card}A=|A|=n$，$n$ 为自然数.</p><h3 id="包含排斥原理-容斥原理"><a href="#包含排斥原理-容斥原理" class="headerlink" title="包含排斥原理(容斥原理)"></a>包含排斥原理(容斥原理)</h3><p>容斥原理：设 $S$ 为有穷集，$P_1, P_2,\cdots, P_m$ 是 $m$ 种性质， $A_i$ 是 $S$ 中具有性质 $P_i$ 的元素构成的子集，$i=1, 2,\cdots , m$ 。则 $S$ 中不具有性质 $P_1, P_2,\cdots, P_m$ 的元素数为<br>$$<br>|\overline{A_1}\cap \cdots\cap \overline{A_m}|=|S|-\sum_{i=1}^m|A_i|+\sum_{1\leq i&lt;j\leq m}|A_i\cap A_j|-\sum_{1\leq i&lt;j&lt;k\leq m}|A_i\cap A_j \cap A_k|+\cdots+(-1)^m|A_1\cap A_2\cap \cdots \cap A_m|<br>$$</p><p>推论： $S$ 中至少具有一条性质的元素数为<br>$$<br>|A_1\cup A_2\cup \cdots \cup A_m|=\sum_{i=1}^{m}|A_i|-\sum_{1 \leq i&lt;j\leq m}|A_i\cap A_j\cap A_k|+\cdots+(-1)^{m-1}|A_1\cap A_2\cap \cdots \cap A_m|<br>$$</p><h3 id="有穷集的计数"><a href="#有穷集的计数" class="headerlink" title="有穷集的计数"></a>有穷集的计数</h3><h2 id="集合的笛卡儿积和二元关系"><a href="#集合的笛卡儿积和二元关系" class="headerlink" title="集合的笛卡儿积和二元关系"></a>集合的笛卡儿积和二元关系</h2><h3 id="有序对"><a href="#有序对" class="headerlink" title="有序对"></a>有序对</h3><p>有序对：由两个元素 $x$ 和 $y$，按照一定的顺序组成的二元组称为有序对（也称序偶），记作$&lt;x,y&gt;$</p><p>有序对性质<br>有序性:$&lt;x,y&gt;\neq &lt;y,x&gt;$ （当$x\neq  y$时）$&lt;x,y&gt;$ 与 $&lt;u,v&gt;$ 相等的充分必要条件是$&lt;x,y&gt;=&lt;u,v&gt; \Leftrightarrow x=u \wedge y=v$</p><p>有序 $n$ 元组：一个有序 $n (n\leq 3)$ 元组 $&lt;x_1, x_2, …, x_n&gt;$ 是一个有序对，其中第一个元素是一个有序 $n-1$元组，即$$&lt;x_1, x_2, …, x_n&gt; = &lt; &lt;x_1, x_2, …, x_{n-1}&gt;, x_n&gt;$$<br>当 $n=1$时, $ &lt; x &gt; $ 形式上可以看成有序 1 元组。</p><h3 id="笛卡尔积及其性质"><a href="#笛卡尔积及其性质" class="headerlink" title="笛卡尔积及其性质"></a>笛卡尔积及其性质</h3><p>笛卡尔积：设$A,B$为集合，$A$与$B$ 的笛卡儿积记作$A\times B$， 定义为 $A\times B =\{ &lt;x,y&gt; | x\in A \wedge y\in B \}$</p><p>笛卡尔积的性质：</p><ul><li>若 $A$ 或 $B$ 中有一个为空集，则 $A\times B$ 就是空集。</li><li>不适合交换律。</li><li>不适合结合律。</li><li>对于并或交运算满足分配律</li><li>若$|A|=m, |B|=n$, 则 $|A\times B|=mn $</li></ul><h3 id="二元关系的定义"><a href="#二元关系的定义" class="headerlink" title="二元关系的定义"></a>二元关系的定义</h3><p>二元关系：如果一个集合满足以下条件之一：<br>（1）集合非空, 且它的元素都是有序对<br>（2）集合是空集<br>则称该集合为一个二元关系, 简称为关系，记作$R$。<br>如$&lt;x,y&gt;\in R$, 可记作 $xRy$。</p><p>从$A$到$B$的关系与$A$上的关系：设$A,B$为集合, $A\times B$的任何子集所定义的二元关系叫做从$A$到$B$的二元关系, 当$A=B$时则叫做$A$上的二元关系.</p><p>$A$上重要关系：</p><p>设 $A$ 为任意集合，<br> $\varnothing$ 是 $A$ 上的关系，称为空关系<br>$E_A, I_A$ 分别称为全域关系与恒等关系，定义如下：<br>$$E_A={&lt;x,y&gt;|x\in A\wedge y\in A}=A\times A \\  I_A={&lt;x,x&gt;|x\in A}$$</p><p>小于等于关系 $L_A$, 整除关系$D_A$, 包含关系$R_{\subseteq}$定义：<br>$L_A=\{&lt;x,y&gt;| x,y\in A\wedge x\leq y\}$, 这里$A\subseteq R$，$R$为实数集合。<br>$D_B=\{&lt;x,y&gt;| x,y\in B\wedge x|y\}$, 这里$B\subseteq Z^*$, $Z^*$为非0整数集。<br>$R_{\subseteq}=\{&lt;x,y&gt;| x,y\in A\wedge x\subseteq y\}$, 这里$A$是集合族.<br>类似的还可以定义大于等于关系, 小于关系, 大于关系, 真包含关系等等。</p><h3 id="二元关系的表示"><a href="#二元关系的表示" class="headerlink" title="二元关系的表示"></a>二元关系的表示</h3><p>表示方式：关系的集合表达式、关系矩阵、关系图。</p><p>关系图：若$A= {x_1, x_2, \cdots, x_m}$，$R$是$A$上的关系，$R$的关系图是$G_R=&lt;V, E&gt;$, 其中$V=A$为顶点集，$E$为边集.如果$&lt;x_i,x_j&gt;$属于关系R，在图中就有一条从 $x_i$ 到 $x_j$ 的有向边。</p><p>注意：$A, B$为有穷集，关系矩阵适于表示从$A$到$B$的关系或者$A$上的关系，关系图适于表示$A$上的关系。</p><h3 id="关系的运算"><a href="#关系的运算" class="headerlink" title="关系的运算"></a>关系的运算</h3><h4 id="基本运算定义"><a href="#基本运算定义" class="headerlink" title="基本运算定义"></a>基本运算定义</h4><p>定义域：$\mathrm{dom}R=\{ x|\exists y(&lt;x,y&gt;\in R) \}$<br>值域：$\mathrm{ran}R=\{ y|\exists x(&lt;x,y&gt;\in R) \}$<br>域：$\mathrm{fld}R=\mathrm{dom}R\cup \mathrm{ran}R$<br>逆：$R^{-1}=\{ &lt;y,x&gt;|&lt;x,y&gt;\in R \}$<br>合成：$$R\circ S=\{ &lt;x,z&gt;| \exists y(&lt;x,y&gt;\in R\wedge &lt;y,z&gt;\in S)\}$$</p><p>合成运算的图示方法: 利用图示（不是关系图）方法求合成。</p><p>限制：$F$ 在 $A$ 上的限制 $F\upharpoonright A = \{&lt;x,y&gt; | xFy \wedge x\in A\}$<br>像：$A$ 在 $F$ 下的像，$F[A] = \mathrm{ran}(F\upharpoonright A)$</p><p>注意： $F\upharpoonright A\subseteq F,F[A]\subseteq \mathrm{ran} F$</p><h4 id="基本运算的性质"><a href="#基本运算的性质" class="headerlink" title="基本运算的性质"></a>基本运算的性质</h4><p>定理：设$F$是任意的关系, 则<br>(1) $(F^{-1})^{-1}=F$<br>(2) $\mathrm{dom}F^{-1}=\mathrm{ran}F^{-1}, \mathrm{ran}F^{-1}=\mathrm{dom}F$</p><p>令 $R,S\subseteq A\times B$ 则有<br>性质1：<br>$$<br>\mathrm{dom}(R\cup S)=\mathrm{dom}R\cup \mathrm{dom}S<br>$$<br>$$ \mathrm{ran}(R\cup S)=\mathrm{ran}R\cup \mathrm{ran}S<br>$$<br>$$ \mathrm{dom}(R\cap S)=\mathrm{dom}R\cap \mathrm{dom}S<br>$$<br>$$ \mathrm{ran}(R\cap S)=\mathrm{ran}R\cap \mathrm{ran}S<br>$$</p><p>性质2：<br>$$<br>(R\cup S)^{-1}=R^{-1}\cup S^{-1}<br>$$</p><p>$$<br>(R\cap S)^{-1}=R^{-1}\cap S^{-1}<br>$$</p><p>$$<br>(R - S)^{-1}=R^{-1} - S^{-1}<br>$$</p><p>$$<br>R\subseteq S\Rightarrow R^{-1}\subseteq S^{-1}<br>$$</p><p>定理：设 $F,G,H$ 是任意关系，则<br>(1)$(F\circ G)\circ H=F\circ (G\circ H)$<br>(2)$(F\circ G)^{-1}=G^{-1}\circ F^{-1}$</p><p>$$<br>F\circ (G\cup H)=(F\circ G)\cup (F\circ H)<br>$$<br>$$<br>F\circ (G\cap H) \subseteq (F\circ G)\cap (F\circ H)<br>$$</p><h4 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h4><p>幂：设$R$为$A$上的关系, $n$为自然数, 则 $R$ 的 $n$次幂定义为：<br>(1) $R_0=\{&lt;x,x&gt; | x\in A \}=I_A$<br>(2) $R^{n+1} = R^n\circ R$</p><p>注意：<br>对于$A$上的任何关系$R_1$和$R_2$都有 $R_1^0 = R_2^0 = I_A$<br>对于$A$上的任何关系 $R$ 都有 $R^1 = R$ </p><p>幂的求法：对于集合表示的关系$R$，计算 $R^n$ 就是$n$个$R$右复合。矩阵表示就是$n$个矩阵相乘, 其中相加采用逻辑加。 </p><p>定理：设$A$为$n$元集, $R$是$A$上的关系, 则存在自然数$ s$ 和 $t$,使得$R^s = R^t$。</p><p>定理：设 $R$ 是 $A$ 上的关系, $m, n\in N$, 则<br>(1)  $R^m\circ R^n=R^{m+n}$<br>(2)  $(R^m)^n=R^{mn}$  </p><p>定理：设$R$ 是$A$上的关系, 若存在自然数 $s, t (s&lt;t)$ 使得 $R^s = R^t$, 则<br>(1) 对任何 $k\in N$ 有 $R^{s+k} = R^{t+k}$<br>(2) 对任何 $k, i\in N$ 有$R^{s+kp+i} = R^{s+i}$, 其中$p = t-s$<br>(3) 令$S=\{R^0,R^1,\cdots, R^{t-1}\}$, 则对于任意的 $q\in N$有 $R^q\in S$</p><h2 id="二元关系的性质"><a href="#二元关系的性质" class="headerlink" title="二元关系的性质"></a>二元关系的性质</h2><h3 id="自反性与反自反性"><a href="#自反性与反自反性" class="headerlink" title="自反性与反自反性"></a>自反性与反自反性</h3><p>自反性：设 $R$ 为 $A$ 上的关系，若 $$\forall x(x\in A\rightarrow &lt; x,x &gt;\in R)$$ ，则称 $R$ 在 $A$ 上是自反的。<br>反自反性：设 $R$ 为 $A$ 上的关系，若 $$\forall x(x\in A\rightarrow &lt; x,x &gt;\notin R)$$ ，则称 $R$ 在 $A$ 上是反自反的。</p><h3 id="对称性与反对称性"><a href="#对称性与反对称性" class="headerlink" title="对称性与反对称性"></a>对称性与反对称性</h3><p>对称性：设 $R$ 为 $A$ 上的关系，若 $$\forall x\forall y(x,y\in A\wedge &lt; x,y &gt;\in R\rightarrow &lt; y,x &gt;\in R)$$ ，则称 $R$ 为 $A$ 上对称的关系。</p><p>反对称性：设 $R$ 为 $A$ 上的关系，若 $$\forall x\forall y(x,y\in A\wedge &lt; x,y &gt;\in R\wedge &lt; y,x &gt;\in R\rightarrow x=y)$$ ，则称 $R$ 为 $A$ 上反对称的关系。</p><h3 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h3><p>传递性：设 $R$ 为 $A$ 上的关系, 若 $$\forall x\forall y\forall z(x,y,z\in A\wedge &lt; x,y &gt;\in R\wedge &lt; y,z &gt;\in R\rightarrow &lt; x,z &gt;\in R)$$ ，则称 $R$ 是 $A$ 上的传递关系。</p><h3 id="关系性质的充要条件"><a href="#关系性质的充要条件" class="headerlink" title="关系性质的充要条件"></a>关系性质的充要条件</h3><p>设 $R$ 为 $A$ 上的关系，则</p><ol><li>$R$ 在 $A$ 上自反当且仅当 $I_A \subseteq R$ 。</li><li>$R$ 在 $A$ 上反自反当且仅当 $R\cap A=\varnothing$ 。</li><li>$R$ 在 $A$ 上对称当且仅当 $R=R^{-1}$ 。</li><li>$R$ 在 $A$ 上反对称当且仅当 $R\cap R^{-1}\subseteq I_A$ 。</li><li>$R$ 在 $A$ 上传递当且仅当 $R\circ R\subseteq R$ 。</li></ol><h3 id="关系性质判别"><a href="#关系性质判别" class="headerlink" title="关系性质判别"></a>关系性质判别</h3><table><thead><tr><th></th><th>自反</th><th>反自反</th><th>对称</th><th>反对称</th><th>传递</th></tr></thead><tbody><tr><td>表达式</td><td>$I_A \subseteq R$</td><td>$R\cap A=\varnothing$</td><td>$R=R^{-1}$</td><td>$R\cap R^{-1}\subseteq I_A$</td><td>$R\circ R\subseteq R$</td></tr><tr><td>关系矩阵</td><td>主对角线元素全是1</td><td>主对角线元素全是0</td><td>矩阵是对称矩阵</td><td>若 $r_{ij}=1$ , 且 $i\neq j$ , 则 $r_{ji}=0$</td><td>对 $M^2$ 中1所在位置, $M$ 中相应位置都是1</td></tr><tr><td>关系图</td><td>每个顶点都有环</td><td>每个顶点都没有环</td><td>如果两个顶点之间有边, 是一对方向相反的边(无单边)</td><td>如果两点之间有边, 是一条有向边(无双向边)</td><td>如果顶点 $x_i$ 连通到 $x_k$ , 则从 $x_i$ 到 $x_k$ 有边</td></tr></tbody></table><h3 id="运算与性质的关系"><a href="#运算与性质的关系" class="headerlink" title="运算与性质的关系"></a>运算与性质的关系</h3><table><thead><tr><th></th><th>自反性</th><th>反自反性</th><th>对称性</th><th>反对称性</th><th>传递性</th></tr></thead><tbody><tr><td>$R_1^{-1}$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td></tr><tr><td>$R_1 \cap R_2$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td></tr><tr><td>$R_1 \cup R_2$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\times$</td><td>$\times$</td></tr><tr><td>$R_1- R_2$</td><td>$\times$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\times$</td></tr><tr><td>$R_1 \circ R_2$</td><td>$\checkmark$</td><td>$\times$</td><td>$\times$</td><td>$\times$</td><td>$\times $</td></tr></tbody></table><h3 id="关系的闭包"><a href="#关系的闭包" class="headerlink" title="关系的闭包"></a>关系的闭包</h3><h4 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h4><p>闭包：设$R$是非空集合$A$上的关系, $R$的自反（对称或传递）闭包是$A$上的关系$R^{\prime}$, 使得$R^{\prime}$满足以下条件：<br>（1）$R^{\prime}$是自反的（对称的或传递的）。<br>（2）$R\subseteq R^{\prime}$<br>（3）对$A$上任何包含$R$的自反（对称或传递）关系 $R^{\prime \prime}$ 有 $R^{\prime}\subseteq R^{\prime \prime} $。</p><p>一般将 $R$ 的自反闭包记作 $r(R)$, 对称闭包记作 $s(R)$, 传递闭包记作 $t(R)$。</p><p>定理(不动点)：若 $R\subseteq A\times A$ ，则</p><ol><li>$R$是自反的当且仅当 $r(R)=R$</li><li>$R$是对称的当且仅当 $s(R)=R$</li><li>$R$是传递的当且仅当 $t(R)=R$</li></ol><p>定理(单调性)：若 $R,S\subseteq A\times A$ ，且 $R\subseteq S$ ，则</p><ol><li>$r(R)\subseteq r(S)$</li><li>$s(R)\subseteq s(S)$</li><li>$t(R)\subseteq t(S)$</li></ol><h4 id="闭包的构造方法"><a href="#闭包的构造方法" class="headerlink" title="闭包的构造方法"></a>闭包的构造方法</h4><p>定理：设 $R$ 为 $A$ 上的关系, 则有</p><ol><li>$r(R)=R\cup R^0$</li><li>$s(R)=R\cup R^{-1}$</li><li>$t(R)=R\cup R^2\cup \cdots$</li></ol><p>对于有穷集合 $A (|A|=n)$ 上的关系, (3)中的并最多不超过 $R^n$ 。</p><h4 id="闭包运算与性质的关系"><a href="#闭包运算与性质的关系" class="headerlink" title="闭包运算与性质的关系"></a>闭包运算与性质的关系</h4><table><thead><tr><th></th><th>自反性</th><th>对称性</th><th>传递性</th></tr></thead><tbody><tr><td>$r(R)$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td></tr><tr><td>$s(R)$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\times$</td></tr><tr><td>$t(R)$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td></tr></tbody></table><p>定理：若 $R\subseteq A\times A$ ，则</p><ol><li>$rs(R)=sr(R)$</li><li>$rt(R)=tr(R)$</li><li>$st(R)\subseteq ts(R)$</li></ol><p>设关系 $R,r(R),s(R),t(R)$ 的关系矩阵分别为 $M, M_r, M_s$ 和 $M_t$ , 则<br>$$M_r = M + E$$<br>$$M_s = M + M^{\prime}$$<br>$$M_t = M + M^2 + M^3 + \cdots$$<br>$E$ 是和 $M$ 同阶的单位矩阵, $M^{\prime}$是 $M$ 的转置矩阵。<br>注意在上述等式中矩阵的元素相加时使用逻辑加。</p><p>设关系$R, r(R), s(R), t(R)$的关系图分别记为$G, G_r, G_s, G_t$ , 则$G_r, G_s, G_t$ 的顶点集与 $G$ 的顶点集相等. 除了 $G$ 的边以外, 以下述方法添加新边：<br>考察$G$的每个顶点, 如果没有环就加上一个环，最终得到$G_r$ 。考察$G$的每条边, 如果有一条 $x_i$ 到 $x_j$ 的单向边, $i\neq j$, 则在$G$中加一条 $x_j$ 到 $x_i$ 的反方向边，最终得到$G_s$。考察$G$的每个顶点 $x_i$, 找从 $x_i$ 出发的每一条路径，如果从 $x_i$ 到路径中任何结点 $x_j$ 没有边，就加上这条边。当检查完所有的顶点后就得到图$G_t$。</p><h4 id="传递闭包的计算——Warshall算法"><a href="#传递闭包的计算——Warshall算法" class="headerlink" title="传递闭包的计算——Warshall算法"></a>传递闭包的计算——Warshall算法</h4><p>算法思路：<br>考虑 $n+1$个矩阵的序列$M_0, M_1,\cdots , M_n$, 将矩阵 $M_k$ 的 $i$ 行$ j$<br>列的元素记作$M_k[i,j]$. 对于$k=0,1\cdots,n, M_k[i,j]=1$当且仅当在$R$ 的关系图中存在一条从 $x_i$ 到 $x_j$ 的路径，并且这条路径除端点外中间只经过 $\{x_1, x_2,\cdots, x_k\}$ 中的顶点。不难证明 $M_0$ 就是 $R$ 的关系矩阵，而 $M_n$ 就对应了 $R$ 的传递闭包。</p><p>Warshall算法：<br>从$M_0$开始，顺序计算 $M_1, M_2,\cdots,$ 直到 $M_n$ 为止。</p><h2 id="等价关系与偏序关系"><a href="#等价关系与偏序关系" class="headerlink" title="等价关系与偏序关系"></a>等价关系与偏序关系</h2><h3 id="等价关系的定义"><a href="#等价关系的定义" class="headerlink" title="等价关系的定义"></a>等价关系的定义</h3><p>等价关系：设 $R$ 为非空集合上的关系. 如果 $R$ 是自反的、<br>对称的和传递的, 则称 $R$ 为 $A$ 上的等价关系. 设 $R$<br>是一个等价关系, 若 $&lt;x,y&gt;\in R$, 称 $x$ 等价于$y$, 记做<br>$x\sim y$</p><h3 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h3><p>等价类：设$R$为非空集合A上的等价关系, $\forall x\in A$，令<br>$[x]_R = \{ y | y\in A\wedge xRy \}$<br>称 $[x]_R$ 为 $x$ 关于 $R$ 的等价类, 简称为 $x$ 的等价类, 简记为 $[x]$ 。</p><h3 id="等价类的性质"><a href="#等价类的性质" class="headerlink" title="等价类的性质"></a>等价类的性质</h3><p>定理：设$R$是非空集合$A$上的等价关系, 则<br>(1) $\forall x\in A, [x]$ 是A的非空子集.<br>(2) $\forall x, y\in A,$ 如果 $x R y$, 则 $[x]=[y]$。<br>(3) $∀x, y\in A$, 如果 $x \not Ry$, 则 $[x]$与$[y]$不交.<br>(4) $\cup \{ [x] | x\in A\}=A$，即所有等价类的并集就<br>是 $A$。</p><h3 id="商集"><a href="#商集" class="headerlink" title="商集"></a>商集</h3><p>商集：设$R$为非空集合$A$上的等价关系, 以$R$的所有等价类作为元素的集合称为$A$关于$R$的商集, 记做$A/R$, $A/R = \{ [x]R | x∈A \}$</p><h3 id="集合的划分"><a href="#集合的划分" class="headerlink" title="集合的划分"></a>集合的划分</h3><p>集合的划分：设$A$为非空集合, 若$A$的子集族$\pi (\pi \subseteq P(A))$<br>满足下面条件：<br>(1) $$\varnothing \notin \pi$$<br>(2) $$\forall x\forall y(x,y\in \pi \wedge x\neq y\rightarrow x\cap y=\varnothing)$$<br>(3) $$\cup \pi =A$$<br>则称$\pi $是$A$的一个划分, 称$\pi $中的元素为$A$的划分<br>块。</p><h3 id="等价关系与划分的一一对应"><a href="#等价关系与划分的一一对应" class="headerlink" title="等价关系与划分的一一对应"></a>等价关系与划分的一一对应</h3><p>商集 $A/R$ 就是 $A$ 的一个划分<br>不同的商集对应于不同的划分<br>任给 $A$ 的一个划分$\pi $, 如下定义 $A$ 上的关系 $$R:R = {&lt;x,y&gt; | x,y\in A\wedge x 与 y \text{在}\pi \text{的同一划分块中}}$$ 则 $R$ 为 $A$ 上的等价关系, 且该等价关系确定的商集就是 $\pi $。</p><h3 id="等价关系的计数"><a href="#等价关系的计数" class="headerlink" title="等价关系的计数"></a>等价关系的计数</h3><p>$A$ 上的等价关系计数<br>$$<br>\sum_{m=1}^n\begin{Bmatrix} n \\ m \end{Bmatrix}<br>$$<br>这里$m$表示分成$m$个等价类。 $|A|=n$。</p><p>第二类Stirling数的定义：$n$ 个不同的球恰好放到 $r$ 个相同的盒子里的方法数称为第二类 Stirling 数，记作<br>$$<br>\begin{Bmatrix} n \\ m \end{Bmatrix}<br>$$<br>递推方程：<br>$$<br>\begin{Bmatrix} n \\ r \end{Bmatrix}=r \begin{Bmatrix} n-1 \\ r \end{Bmatrix}+\begin{Bmatrix} n-1 \\ r-1 \end{Bmatrix},\begin{Bmatrix} n \\ 0 \end{Bmatrix}=0,\begin{Bmatrix} n \\ 1 \end{Bmatrix}=1<br>$$</p><p>$$<br>\begin{Bmatrix} n \\ 2 \end{Bmatrix}=2^{n-1}-1,\begin{Bmatrix} n \\ n-1 \end{Bmatrix}=\begin{Bmatrix} n \\ 2 \end{Bmatrix}<br>$$</p><h3 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h3><p>偏序关系：非空集合$A$上的自反、反对称和传递的关系，称为$A$上的偏序关系，记作$\preccurlyeq $。 设$\preccurlyeq $为偏序关系, 如<br>果$&lt;x, y&gt;\in \preccurlyeq $, 则记作 $x\preccurlyeq y$, 读作 $x$“小于或等于”$y$。</p><p>$x$与 $y$ 可比：设$R$为非空集合$A$上的偏序关系,<br>$x,y\in A,$ $x$与$y$可比 $\Leftrightarrow  x\preccurlyeq y \vee y\preccurlyeq x$。</p><p>全序关系：$R$为非空集合$A$上的偏序, $\forall x,y\in A$, $x$与 $y$ 都是可比的，则称 $R$ 为全序（或 线序）。</p><p>覆盖：设$R$为非空集合A上的偏序关系, $x, y\in A$, 如<br>果 $x \preccurlyeq y$且不存在 $z\in A$ 使得 $x \preccurlyeq  z \preccurlyeq  y$, 则称 $y$ 覆盖 $x$ 。</p><h3 id="偏序集与哈斯图"><a href="#偏序集与哈斯图" class="headerlink" title="偏序集与哈斯图"></a>偏序集与哈斯图</h3><p>偏序集：集合$A$和$A$上的偏序关系$\preccurlyeq $一起叫做偏序集, 记作 $&lt;A,\preccurlyeq &gt;$。</p><p>哈斯图：利用偏序自反、反对称、传递性简化的关系图。</p><h3 id="偏序集的特定元素"><a href="#偏序集的特定元素" class="headerlink" title="偏序集的特定元素"></a>偏序集的特定元素</h3><p>定义 设$&lt;A,\preccurlyeq &gt;$为偏序集, $B\subseteq A, y\in B$。<br>(1) 若$\forall x(x\in B\rightarrow y\preccurlyeq x)$ 成立, 则称 $y$ 为 $B$ 的最小元。<br>(2) 若$\forall x(x\in B→x\preccurlyeq y)$ 成立, 则称 $y$ 为 $B$ 的最大元。<br>(3) 若$\neg \exists x (x\in B\wedge x&lt; y) $成立, 则称 $y$ 为$B$的极小元。<br>(4) 若$\neg \exists x (x\in B\wedge y&lt;x)$ 成立, 则称 $y$ 为$B$的极大元。</p><p>定义 设$&lt;A, \leq&gt;$为偏序集, $B\subseteq A$, $y\in A$。<br>(1) 若$\forall x(x\in B\rightarrow x\preccurlyeq y)$ 成立, 则称 $y$ 为 $B$ 的上界。<br>(2) 若$\forall x(x\in B\rightarrow y\preccurlyeq x)$ 成立, 则称 $y$ 为 $B$ 的下界。<br>(3) 令 $C＝\{y | y\text{为}B\text{的上界}\}$ , 则称$C$的最小元为$B$的最小上界或上确界。<br>(4) 令 $D＝\{y | y\text{为}B\text{的下界}\}$, 则称$D$的最大元为$B$的最大下界或下确界。</p><h3 id="特殊元素的性质"><a href="#特殊元素的性质" class="headerlink" title="特殊元素的性质"></a>特殊元素的性质</h3><ul><li>对于有穷集，极小元和极大元必存在，可能存在多个。</li><li>最小元和最大元不一定存在，如果存在一定惟一。</li><li>最小元一定是极小元；最大元一定是极大元。</li><li>孤立结点既是极小元，也是极大元。</li><li>下界、上界、下确界、上确界不一定存在。</li><li>下界、上界存在不一定惟一。</li><li>下确界、上确界如果存在，则惟一。</li><li>集合的最小元就是它的下确界，最大元就是它的上确界；反之不对。</li></ul><h3 id="偏序集的特殊子集"><a href="#偏序集的特殊子集" class="headerlink" title="偏序集的特殊子集"></a>偏序集的特殊子集</h3><p>定义：设$&lt;A,\preccurlyeq &gt;$为偏序集, $B\subseteq A$。<br>(1) 如果$\forall x,y\in B$，$x$与$y$都是可比的，则称$B$是$A$中的一条链，$B$中的元素个数称为链的长度；<br>(2) 如果$\forall x,y\in B$，$x\neq y$，$x$与$y$都是不可比的，则称$B$是$A$中的一条反链，$B$中的元素个数称为反链的长度。</p><h3 id="分解为反链"><a href="#分解为反链" class="headerlink" title="分解为反链"></a>分解为反链</h3><p>定理：设$&lt;A,\preccurlyeq &gt;$为偏序集，如果$A$中最长的链长度为$n$, 则<br>$A$中存在极大元，且该偏序集可以分解为 $n$ 条不相交的反链。</p><p>定理：设$&lt;A,\preccurlyeq &gt;$为含$mn+1$个元素的偏序集，则$A$中存在长<br>度为$m+1$的反链, 或长度为$n+1$的链。</p><h3 id="拟序关系"><a href="#拟序关系" class="headerlink" title="拟序关系"></a>拟序关系</h3><p>拟序关系：设 $A\neq \varnothing$ ， $R\subseteq A\times A$ 。若 $R$ 是反自反，传递的，就称 $R$ 为 $A$ 上的拟序关系，常用 $\prec$ 表示拟序关系，称 $&lt;A,\prec&gt;$ 为拟序集。</p><h3 id="拟序和偏序"><a href="#拟序和偏序" class="headerlink" title="拟序和偏序"></a>拟序和偏序</h3><p>定理：设 $\preccurlyeq$ 是非空集合 $A$ 上的偏序关系， $\prec $ 是 $A$ 上的拟序关系，则</p><ol><li>$\prec $ 是反对称的。</li><li>$\preccurlyeq -I_A$ 是 $A$ 上的拟序关系。</li><li>$\prec \cup I_A$ 是 $$ 上的偏序关系。</li></ol><h3 id="三歧性，拟线序"><a href="#三歧性，拟线序" class="headerlink" title="三歧性，拟线序"></a>三歧性，拟线序</h3><p>三歧性：设 $A\neq \varnothing$ ， $\prec $ 是 $A$ 上拟序关系，若<br>$$<br>x\prec y,x=y,y\prec x<br>$$<br>中有且仅有一式成立，则称 $\prec $ 具有三歧性。同时称 $\prec $ 为 $A$ 上的拟线序关系（拟全序关系），称 $&lt;A,\prec &gt;$ 为拟线序集。</p><h3 id="良序关系"><a href="#良序关系" class="headerlink" title="良序关系"></a>良序关系</h3><p>良序集：设 $&lt;A,\prec &gt;$ 为（拟）全序集，若 $A$ 任何非空子集 $B$ 均有最小元，则称 $\prec $ 为 $A$ 上的良序关系，称 $&lt;A,\prec &gt;$ 为良序集。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>函数：设 $F$ 为二元关系, 若 $x\in \mathrm{dom}F$ 都存在唯一 $y\in \mathrm{ran}F$ 使 $xFy$ 成立, 则称 $F$ 为函数。对于函数 $F$ , 如果有 $xFy$ , 则记作 $y=F(x)$, 并称 $y$ 为 $F$ 在 $x$ 的值。</p><p>函数相等:设$F, G$为函数, 则 $F=G\Leftrightarrow F\subseteq G\vee G\subseteq F$<br>如果两个函数 $F$ 和 $G$ 相等, 一定满足下面两个条件：<br>(1) $\mathrm{dom}F = \mathrm{dom}G$<br>(2) $\forall x\in \mathrm{dom}F=\mathrm{dom}G$ 都有 $F(x) = G(x)$。</p><p>从 $A$ 到 $B$ 的函数：设$A, B$为集合, 如果 $f$ 为函数 $\mathrm{dom}f = A$ ，$\mathrm{ran}f = B$, 则称 $f$ 为从$A$到$B$的函数, 记作 $f：A\rightarrow B$</p><p>$B$上$A$：所有从 $A$ 到 $B$ 的函数的集合记作 $B^A$, 读作“$B$上$A$”，符号化表示为 $B^A=\{ f|f:A\rightarrow B \}$</p><p>函数的像：设函数 $f：A\rightarrow B,A_1\subseteq A$在 $f$ 下的像： $f(A_1) = \{ f(x) | x\in A_1 \}$ 函数的像 $f(A)$。</p><h3 id="函数的性质"><a href="#函数的性质" class="headerlink" title="函数的性质"></a>函数的性质</h3><p>定义：设 $f:A\rightarrow B$ ，</p><ol><li>若 $\mathrm{ran}f=B$ ，则称 $f:A\rightarrow B$ 是满射。</li><li>若 $\forall y\in \mathrm{ran}f$ 都存在唯一的 $x\in A$ 使得 $f(x)=y$ ，则称 $f:A\rightarrow B$ 是单射的。</li><li>若 $f:A\rightarrow B$ 既是满射又是单射的，则称 $f:A\rightarrow B$ 是双射的。</li></ol><p> $f$ 满射意味着： $\forall y \in B$ ，都存在 $x\in A$ 使得 $f(x)=y$ 。<br> $f$ 单射意味着： $f(x_1)=f(x_2)\Rightarrow x_1=x_2$ 。</p><p>常函数：设 $f:A\rightarrow B$ ，若存在 $c\in B$ 使得 $\forall x\in A$ 都有 $f(x)=c$ ，则称 $f:A\rightarrow B$ 是常函数。</p><p>恒等函数：称 $A$ 上的恒等关系 $I_A$ 为 $A$ 上的恒等函数，对于所有的 $x\in A$ 都有 $I_A(x)=x$ 。</p><p>单调性：设 $f:R\rightarrow$ ，如果对于任意的 $x_1,x_2\in R$ ， $x_1&lt;x_2$ ，就有 $f(x_1)\leq f(x_2)$ ，则称 $f$ 为单调递增的；如果对于任意的 $x_1,x_2\in R$ ， $x_1&lt;x_2$ ，就有 $f(x_1)&lt; f(x_2)$ ，则称 $f$ 为严格单调递增的。类似的可以定义单调递减和严格单调递减的函数。</p><p>集合的特征函数：设 $A$ 为集合， $\forall A^{\prime}\subseteq A$ ， $A^{\prime}$ 的特征函数 $\chi_{A^{\prime}}:A\rightarrow \{ 0,1 \}$ 定义为<br>$$<br>\chi_{A^{\prime}}(a)=\begin{cases} 1,a\in A^{\prime} \\ 0,a\in A-A^{\prime} \end{cases}<br>$$</p><p>自然映射：设 $R$ 是 $A$ 上的等价关系，令<br>$$<br>g:A\rightarrow A/R \quad g(\alpha)=[\alpha],\forall \alpha \in A<br>$$<br>称 $g$ 是从 $A$ 到商集 $A/R$ 的自然映射。</p><h3 id="函数的复合与反函数"><a href="#函数的复合与反函数" class="headerlink" title="函数的复合与反函数"></a>函数的复合与反函数</h3><p>定理：设 $F,G$ 是函数，则 $F\circ G$ 也是函数，且满足<br> (1) $$\mathrm{dom}(F\circ G)={ x | x\in \marthm{dom}F \wedge F(x)\in \mathrm{dom} G}$$<br> (2) $\forall x\in \mathrm{dom}(F\circ G)$ 有 $F\circ G(x) = G(F(x))$</p><p>推论：设 $F,G,H$ 为函数，则 $(F\circ G)\circ H$ 和 $F\circ (G\circ H)$ 都是函数，且 $(F\circ G)\circ H=F\circ (G\circ H)$ 。</p><p>推论：设 $f:A\rightarrow B$ ， $g:B\rightarrow C$ ，则 $f\circ g:A\rightarrow C$ ，且 $\forall x\in A$ 都有 $f\circ g(x)=g(f(x))$ 。</p><p>定理：设 $f:A\rightarrow B$ ， $g:B\rightarrow C$</p><ol><li>如果 $f:A\rightarrow B$ ， $g:B\rightarrow C$ 都是满射的，则 $f\circ g:A\rightarrow C$ 也是满射的。</li><li>如果 $f:A\rightarrow B$ ， $g:B\rightarrow C$ 都是单射的，则 $f\circ g:A\rightarrow C$ 也是单射的。</li><li>如果 $f:A\rightarrow B$ ， $g:B\rightarrow C$ 都是双射的，则 $f\circ g:A\rightarrow C$ 也是双射的。</li></ol><p>定理：设 $f:A\rightarrow B$ 是双射的，则 $f^{-1}:B\rightarrow A$ 也是双射的。</p><p>反函数：对于双射函数 $f:A\rightarrow B$ ，称 $f^{-1}:B\rightarrow A$ 是它的反函数。</p><p>定理：设 $f:A\rightarrow B$ 是双射的，则<br>$$<br>f^{-1}\circ f=I_B,f\circ f^{-1}=I_A<br>$$<br>定理：设 $f:A\rightarrow B$ ， $g:B\rightarrow C$</p><ol><li>如果 $f\circ g$ 是满射的，则 $g$ 是满射的。</li><li>如果 $f\circ g$ 是单射的，则 $f$ 是单射的。</li><li>如果 $f\circ g$ 是双射的，则 $g$ 是满射的， $f$ 是单射的。</li></ol><p>左逆右逆：设 $f:A\rightarrow B$ ， $g:B\rightarrow A$ ，若 $f\circ g=I_A$ ，则称 $g$ 为 $f$ 的右逆函数， $f$ 为 $g$ 的左逆函数。</p><p>定理：</p><p>设 $f:A\rightarrow B$,<br>(1) $f$有右逆函数，当且仅当$f$是单射的。<br>(2) $f$有左逆函数，当且仅当$f$是满射的。<br>(3) $f$有左逆和右逆函数，当且仅当$f$是双射的。<br>(4) 如果$f$是双射函数，则$f$的左逆和右逆函数相等。</p><hr><p>$$<br>\mathscr{THE} \quad \mathscr{END}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>纯数学</category>
      
      <category>数学基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数理逻辑</title>
    <link href="/archives/70bba3ec.html"/>
    <url>/archives/70bba3ec.html</url>
    
    <content type="html"><![CDATA[<p>说真的，作为离散数学的一部分的数理逻辑其实内容不是很多，深度也不够。今后想深入学习时再补充吧！</p><span id="more"></span><h1 id="数理逻辑"><a href="#数理逻辑" class="headerlink" title="数理逻辑"></a>数理逻辑</h1><h2 id="数理逻辑的简介"><a href="#数理逻辑的简介" class="headerlink" title="数理逻辑的简介"></a>数理逻辑的简介</h2><p>逻辑学是探索阐述和确立有效推理原则的学科，最早由亚里士多德创立。</p><p>三段论：一个包括有大前提，小前提和结论的论证。</p><ul><li>大前提： $S$ 中的所有元有 $R$ 性质</li><li>小前提： $a$ 没有 $R$ 性质</li><li>结论： $a$ 不是 $S$ 中的元</li></ul><p>用数学的方法研究关于推理、证明等问题的学科就叫做数理逻辑。</p><p>数理逻辑的四个分支：</p><ul><li>公理集合论</li><li>证明论</li><li>递归论</li><li>模型论</li></ul><p>命题演算与谓词演算</p><h2 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h2><h3 id="命题逻辑基本概念"><a href="#命题逻辑基本概念" class="headerlink" title="命题逻辑基本概念"></a>命题逻辑基本概念</h3><h4 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h4><p>命题：能判断真假的陈述句叫命题。</p><p>悖论（自我指谓）、疑问句、祈使句、感叹句，无确定真值的句子都不是命题。</p><p>一般用 $p,q,r,s,\cdots$ 表示命题，1为真，0为假。</p><h4 id="联结词"><a href="#联结词" class="headerlink" title="联结词"></a>联结词</h4><p>联结词的种类：</p><ul><li>否定联结词： $\neg$ ，例如： $\neg p$ ，真假与 $p$ 相反</li><li>合取联结词： $\wedge$ ，例如： $p \wedge q$ ，一假即假</li><li>析取联结词： $\vee$ ，例如： $p \vee q$ ，一真即真</li><li>蕴涵联结词： $\rightarrow$ ，例如： $p \rightarrow q$ ， $p \rightarrow q$ 为假当且仅当 $p$ 为真且 $q$ 为假。</li><li>等价联结词： $\leftrightarrow$ ，例如： $p \leftrightarrow q$ ，当且仅当 $p,q$ 真值相同时， $p \leftrightarrow q$ 为真。</li><li>除此之外还有： $\uparrow, \downarrow$ 等。</li></ul><p>简单命题与复合命题</p><h3 id="命题逻辑等值演算"><a href="#命题逻辑等值演算" class="headerlink" title="命题逻辑等值演算"></a>命题逻辑等值演算</h3><h4 id="等值式"><a href="#等值式" class="headerlink" title="等值式"></a>等值式</h4><p>等值：设 $A,B$ 是两个命题公式，若 $A,B$ 构成的等价式 $A\leftrightarrow B$ 为重言式，则称A与B是等值的，记为 $A\Leftrightarrow B$ 。</p><p>基本等值式：</p><ol><li>双重否定律<br>$$A\Leftrightarrow \neg \neg A$$</li><li>幂等律<br>$$A\Leftrightarrow A\vee A,A\Leftrightarrow A\wedge A$$</li><li>交换律<br>$$A\vee B\Leftrightarrow B\vee A,A\wedge B\Leftrightarrow B\wedge A$$</li><li>结合律<br>$$(A\vee B)\vee C\Leftrightarrow A\vee (B\vee C),(A\wedge B)\wedge C\Leftrightarrow A\wedge (B\wedge C)$$</li><li>分配律<br>$$A\vee (B\wedge C)\Leftrightarrow (A\vee B)\wedge (A\vee C),A\wedge (B\vee C)\Leftrightarrow (A\wedge B)\vee (A\wedge C)$$</li><li>德摩根律<br>$$\neg (A\vee B)\Leftrightarrow \neg A\wedge \neg B,\neg (A\wedge B)\Leftrightarrow \neg A\vee \neg B$$</li><li>吸收律<br>$$A\vee (A\wedge B)\Leftrightarrow A,A\wedge (A\vee B)\Leftrightarrow A$$</li><li>零律<br>$$A\vee 1\Leftrightarrow 1,A\wedge 0\Leftrightarrow 0$$</li><li>同一律<br> $$A\vee 0\Leftrightarrow A,A\wedge 1\Leftrightarrow A$$</li><li>排中律<br>$$A\vee \neg A\Leftrightarrow 1$$</li><li>矛盾律<br>$$A\wedge \neg A\Leftrightarrow 0$$</li><li>蕴涵等值式<br>$$A\rightarrow B\Leftrightarrow \neg A\vee B$$</li><li>等价等值式<br>$$A\leftrightarrow B\Leftrightarrow (A\rightarrow B)\wedge(B\rightarrow A)$$</li><li>假言易位<br>$$A\rightarrow B\Leftrightarrow \neg B\rightarrow \neg A$$</li><li>等价否定等值式<br>$$A\leftrightarrow B\Leftrightarrow \neg A\leftrightarrow\neg B$$</li><li>归谬论<br>$$(A\rightarrow B)\wedge (A\rightarrow \neg B)\Leftrightarrow \neg A$$</li></ol><p>对偶原理：一个逻辑等值式，如果只含有 $\neg ,\vee,\wedge,0,1$ 那么同时把 $\vee$ 和 $\wedge$ 互换，把0和1互换得到的还是等值式。</p><h4 id="析取范式与合取范式"><a href="#析取范式与合取范式" class="headerlink" title="析取范式与合取范式"></a>析取范式与合取范式</h4><p>命题变项及其否定统称作文字（letters）。</p><p>仅由有限个文字构成的析取式称作简单析取式。</p><p>仅由有限个文字构成的合取式称作简单合取式。</p><p>设 $A_i$ 是含 $n$ 个文字的简单析取式，若 $A_i$ 中既含某个命题变项 $p_j$ ，又含它的否定式 $\neg p_j$ ， 即含 $p_j\vee \neg p_j$ ，则 $A_i$ 为重言式。</p><p>一个简单析取式是重言式当且仅当它同时含有某个命题变项及它的否定式。一个简单合取式是矛盾式当且仅当它同时含有某个命题变项及它的否定式。</p><p>范式：由有限个简单合取式构成的析取式称为析取范式（disjunctive normal form）。<br>由有限个简单析取式构成的合取式称为合取范式（conjunctive normal form）。<br>析取范式与合取范式统称为范式。</p><p>范式存在定理：任一命题公式都存在与之逻辑等价的析取范式与合取范式。</p><p>一个析取范式是矛盾式当且仅当它的每个简单合取式都是矛盾式。一个合取范式是重言式当且仅当它的每个简单析取式都是重言式。</p><p>极小项（极大项）：在含有 $n$ 个命题变元的简单合取式（简单析取式），若每个命题变元和它的否定式不同时出现，而二者之一必出现且仅出现一次，且第 $i$ 个命题变元或它的否定式出现在从左算起的第 $i$ 位，则称这样的简单合取式（简单析取式）为极小项（极大项）。</p><p>设 $m_i$ 和 $M_i$ 是命题变元 $P_1,P_2,\cdots ,P_n$ 形成的极小项和极大项，则：</p><p>$$<br>\neg m_{i} \Leftrightarrow M_{i} \quad \neg M_{i} \Leftrightarrow m_{i}<br>$$</p><p>主范式：由有限个极小项构成的析取式称为主析取范式。<br>由有限个极大项构成的合取式称为主合取范式。<br>主析取范式和主合取范式统称主范式。</p><p>范式定理：任何命题公式都存在着与之逻辑等价的主析取范式和主合取范式，并且是唯一的。</p><h4 id="真值函数"><a href="#真值函数" class="headerlink" title="真值函数"></a>真值函数</h4><p>真值函数：称定义域为$\{ 00···0,00···1,···,11···1 \}$，值域为$\{ 0,1 \}$的函数是 $n$ 元真值函数，定义域中的元素是长为 $n$ 的0,1串。常用 $F:\{ 0,1 \}^n \rightarrow \{ 0,1 \}$ 表示 $F$ 是 $n$ 元真值函数。</p><p>共有 $2^{2^n}$ 个 $n$ 元真值函数。</p><p>对于任意一个含 $n$ 个命题变项的命题公式 $A$ ，都存在唯一的一个 $n$ 元真值函数 $F$ 为 $A$ 的真值表。</p><h4 id="联结词功能完备集"><a href="#联结词功能完备集" class="headerlink" title="联结词功能完备集"></a>联结词功能完备集</h4><p>联结词全功能集：设 $S$ 是一个联结词集合，如果任何 $n(n\geq 1)$ 元真值函数都可以由仅含 $S$ 中的联结词构成的公式表示，则称 $S$ 是联结词全功能集。</p><p>若 $S$ 是联结词全功能集，则任何命题公式都可用 $S$ 中的联结词表示。</p><p>定理： $\{  \neg,\wedge,\vee  \} , \{  \neg,\wedge  \} , \{  \neg,\vee  \} , \{  \neg,\rightarrow  \}$ 都是联结词全功能集。</p><p>其他联结词：</p><p>与非式：</p><p>$$<br>p \uparrow q \Leftrightarrow \neg(p\wedge q)<br>$$</p><p>或非式：</p><p>$$<br>p \downarrow q \Leftrightarrow \neg(p\vee q)<br>$$</p><p>定理： $\{  \uparrow  \} , \{  \downarrow  \} $ 都是联结词全功能集。</p><h4 id="命题逻辑推理理论"><a href="#命题逻辑推理理论" class="headerlink" title="命题逻辑推理理论"></a>命题逻辑推理理论</h4><p>逻辑蕴涵关系：设 $A$ 和 $B$ 为两个命题公式，若 $A\rightarrow B$ 是一个重言式，则称 $A$ （逻辑）蕴涵 $B$ ，或称 $A$ 永真蕴涵 $B$ ，记作 $A\Rightarrow B$ 。即：若 $A\rightarrow B\Leftrightarrow 1$ ，则称 $A\Rightarrow B$ 。</p><p>蕴涵关系的性质：</p><ul><li>自反性：即对任意的公式 $A$ ，有 $A\Rightarrow A$ 。</li><li>反对称性：对任意的公式 $A$ 和 $B$ ，若 $A\Rightarrow B$ ，且 $B\Rightarrow A$ ，则有 $A\Leftrightarrow B$ 。</li><li>传递性：对任意的公式 $A,B,C$ ，若 $A\Rightarrow B$ ，且 $B\Rightarrow C$ ，则 $A\Rightarrow C$ 。</li></ul><p>蕴涵关系的证明：</p><ul><li>前真导后真法</li><li>后假导前假法</li></ul><p>推理的形式结构:若对于每组赋值，或者 $A_1\wedge A_2\wedge \cdots \wedge A_k$ 为假，或者当 $A_1\wedge A_2\wedge \cdots \wedge A_k$ 为真时， $B$ 也为真, 则称由 $A_1\wedge A_2\wedge \cdots \wedge A_k$ 推 $B$ 的推理正确, 否则推理不正确（错误）。</p><p>推理的形式结构： $A_1\wedge A_2\wedge \cdots \wedge A_k\rightarrow B$ 。</p><p>上述推理正确等价于： $A_1\wedge A_2\wedge \cdots \wedge A_k\Rightarrow B$ 。</p><p>判断推理是否正确：</p><ul><li>真值表法</li><li>等值演算法</li><li>主析取范式法</li><li>构造证明法</li></ul><p>推理定律：</p><ul><li>附加律<br>$$A\Rightarrow (A\vee B)$$</li><li>化简律<br>$$(A\wedge B)\Rightarrow A$$</li><li>假言推理<br>$$(A\rightarrow B)\wedge A\Rightarrow B$$</li><li>拒取式<br>$$(A\rightarrow B)\wedge \neg B\Rightarrow \neg A$$</li><li>析取三段论<br>$$(A\vee B)\wedge \neg B\Rightarrow A$$</li><li>假言三段论<br>$$(A\rightarrow B)\wedge (B\rightarrow C)\Rightarrow (A\rightarrow C)$$</li><li>等价三段论<br>$$(A\leftrightarrow B)\wedge (B\leftrightarrow C)\Rightarrow (A\leftrightarrow C)$$</li><li>构造性二难<br>$$(A\rightarrow B)\wedge (C\rightarrow D)\wedge (A\vee C)\Rightarrow (B\vee D)$$</li><li>构造性二难（特殊形式）<br>$$(A\rightarrow B)\wedge (\neg A\rightarrow \neg B)\Rightarrow B$$</li><li>破坏性二难<br>$$(A\rightarrow B)\wedge (C\rightarrow D)\wedge (\neg B\vee \neg D)\Rightarrow (\neg A\vee \neg C)$$</li></ul><p>推理规则：</p><ol><li>前提引入规则 $P$ 。</li><li>结论引入规则 $T$ 。</li><li>置换规则</li><li>假言推理规则</li><li>附加规则</li><li>化简规则</li><li>拒取式规则</li><li>假言三段论规则</li><li>析取三段论规则</li><li>构造性二难推理规则</li><li>破坏性二难推理规则</li><li>合取引入规则</li></ol><p>证明方法：</p><ul><li>直接证明法</li><li>附加前提证明法</li><li>归谬法（反证法）</li></ul><h2 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h2><h3 id="谓词的概念与表示法"><a href="#谓词的概念与表示法" class="headerlink" title="谓词的概念与表示法"></a>谓词的概念与表示法</h3><p>谓词：在反映判断的句子中，用以刻划客体的性质或关系的即是谓词。表示特定谓词，称为谓词常元，<br>表示不确定的谓词，称为谓词变元，都用大写英文字母，如 $P,Q,R,\cdots$ 来表示。</p><p>客体，是指可以独立存在的事物，它可以是具体的，也可以是抽象的，如张明，计算机，精神等。<br>表示特定的个体，称为客体常元，以 $a,b,c,\cdots$ 或带下标的 $a_i,b_i,c_i,\cdots$ 表示；<br>表示不确定的个体，称为客体变元，以 $x,y,z,\cdots$ 或$x_i,y_i,z_i,\cdots$表示。</p><h3 id="命题函数与量词"><a href="#命题函数与量词" class="headerlink" title="命题函数与量词"></a>命题函数与量词</h3><h4 id="命题函数"><a href="#命题函数" class="headerlink" title="命题函数"></a>命题函数</h4><p>命题函数：由一个谓词和一些客体变元组成的表达式，称为简单命题函数。 $n$ 元谓词，就是有 $n$ 个客体变元的命题函数。由一个或 $n$ 个简单命题函数以及逻辑联结词组成的表达式，称为复合命题函数。</p><p>个体域：在命题函数中，客体变元的取值范围（讨论范围）叫个体域或论述域。</p><p>全总个体域：把各种个体域综合在一起作为论述范围的域。</p><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><p>全称量词： $\forall$<br>存在量词： $\exists$<br>存在唯一量词： $\exists !$</p><h3 id="谓词公式与翻译"><a href="#谓词公式与翻译" class="headerlink" title="谓词公式与翻译"></a>谓词公式与翻译</h3><p>原子谓词公式：不出现命题联结词和量词的谓词表达式称为原子谓词公式，并用 $P(x_1,\cdots,x_n)$ 来表示。<br>其中： $P$ 称为 $n$ 元谓词， $x_1,\cdots,x_n$ 称为客体变元，当 $n=0$ 时称为零元谓词公式。</p><p>谓词公式的归纳法定义<br>（1）原子谓词公式是谓词公式；<br>（2）若 $A$ 是谓词公式，则 $\neg A$ 也是谓词公式；<br>（3）若 $A, B$ 都是谓词公式，则 $A\vee B,A\wedge B$， $A\rightarrow B,A\leftrightarrow B$ 都是谓词公式；<br>（4）若 $A$ 是谓词公式，x是任何变元，则 $(\forall x)A,(\exists x)A,$ 也都是谓词公式；<br>（5）只有按⑴-⑷所求得的那些公式才是谓词公式（谓词公式又简称“公式”）。</p><h3 id="变元的约束"><a href="#变元的约束" class="headerlink" title="变元的约束"></a>变元的约束</h3><p>指导变元：给定 $x$ 为一个谓词公式，其中一部分公式形式为 $(\forall x)P(x)$ 或 $(\exists x)P(x)$ ，这里的 $\forall$ ， $\exists$ 后面所跟的 $x$ 称为相应的量词的指导变元。</p><p>辖域： $P(x)$ 称为相应量词的作用域或辖域。（紧接在量词后面括号内的谓词公式。）</p><p>约束变元：在量词的辖域内，且与量词下标相同的变元。（在作用域中的 $x$ ）</p><p>自由变元：除去约束变元以外所出现的变元称作自由变元。（不受量词的约束的变元）。 </p><p>自由变元的代入:对公式中的自由变元的更改叫做代入。<br>规则：(a)对公式中出现该自由变元的每一处进行代入。(b)用以代入的变元与原公式中所有变元的名称不能相同。</p><p>(1)当个体域的元素有限时，客体变元的所有可能的取代是可枚举的。</p><p>(2)量词对变元的约束，往往与量词的次序有关。约定：多个量词时的读出顺序为从左到右，不能颠倒。</p><h3 id="谓词演算的等价式与蕴含式"><a href="#谓词演算的等价式与蕴含式" class="headerlink" title="谓词演算的等价式与蕴含式"></a>谓词演算的等价式与蕴含式</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>赋值：在谓词公式中，当客体变元由确定的客体所取代，谓词变元用确定的谓词所取代时，就称对谓词公式赋值。</p><p>等价：给定两个谓词公式 $\mathrm{wff} A$ 和 $\mathrm{wff} B$ ， $E$ 为它们共同个体域，若对 $A$ 和 $B$ 的变元的任意赋值，使得 $A$ 和 $B$ 的值相同，则称谓词公式 $A$ 和 $B$ 在 $E$ 上是互为等价的，记为 $A\Leftrightarrow$ .</p><p>给定任意 $\mathrm{wff} A$ ， $E$ 是 $A$ 的个体域。若给 $A$ 中客体变元指派 $E$ 中的每一个客体,  $\mathrm{wff} A$ 值均为真，则称 $A$ 在 $E$ 中是有效的（永真的）。</p><p>一个 $\mathrm{wff} A$ ，若在所有赋值下均为“F”，则称该 $\mathrm{wff} A$  为不可满足的。</p><p>给定 $\mathrm{wff} A$ ， $E$ 是 $A$ 的个体域。若至少一种赋值下为真，则称 $A$ 是可满足的。</p><h4 id="谓词演算的一些等价式与蕴含式"><a href="#谓词演算的一些等价式与蕴含式" class="headerlink" title="谓词演算的一些等价式与蕴含式"></a>谓词演算的一些等价式与蕴含式</h4><ol><li><p>命题公式的推广 谓词演算中的公式代替命题演算中的永真公式的变元时，所得的谓词公式即为永真式。</p></li><li><p>量词转换律 出现在量词之前的否定，不是否定该量词，而是否定被量化了的整个命题。</p></li><li><p>量词辖域的扩张及其收缩律</p></li><li><p>量词与命题联结词之间的一些等价式</p></li><li><p>量词与命题联结词之间的一些蕴含式</p></li><li><p>多个量词的使用</p></li></ol><p>（a）量词出现的次序直接关系到命题的含义<br>（b）在含有多个量词的谓词公式中,xy, xy的位置是可以改变的,且不影响命题的真值。<br>（c）量词转换律的推广应用:把¬深入到谓词公式前面去的方法。<br>（d）两个量词, 所组成的谓词公式的等价式和永真蕴含式（8个）</p><h3 id="前束范式"><a href="#前束范式" class="headerlink" title="前束范式"></a>前束范式</h3><h4 id="前束范式定义"><a href="#前束范式定义" class="headerlink" title="前束范式定义"></a>前束范式定义</h4><p>前束范式：一个公式，如果量词均非否定地在全式的开头，它们的作用域延伸到整个公式的末尾，则称此公式叫前束范式。</p><p>定理：任何一个谓词公式均和一个前束范式等价。</p><p>化前束范式的步骤：</p><p>（1）否定深入（量词转化式）<br>（2）量词前提（必要时需换名）</p><h4 id="前束合取范式"><a href="#前束合取范式" class="headerlink" title="前束合取范式"></a>前束合取范式</h4><p>前束合取范式：一个谓词公式若具有如下形式称为前束合取范式。</p><p>定理：每一个谓词公式都可以转化为与其等价的前束合取范式。</p><p>化前束合取范式的步骤：<br>（1）消多余量词<br>（2）换名<br>（3）消去条件联结词<br>（4）将 $\neg $ 深入<br>（5）将量词提出</p><h4 id="前束析取范式"><a href="#前束析取范式" class="headerlink" title="前束析取范式"></a>前束析取范式</h4><p>前束析取范式：一个谓词公式具有如下形式称为前束析取范式。</p><p>定理：每一个谓词公式都可以转化为与其等价的前束析取范式。</p><h3 id="谓词演算的推理理论"><a href="#谓词演算的推理理论" class="headerlink" title="谓词演算的推理理论"></a>谓词演算的推理理论</h3><h4 id="四个推理规则"><a href="#四个推理规则" class="headerlink" title="四个推理规则"></a>四个推理规则</h4><ol><li><p>全称指定规则（US规则）<br>如果对个体域中所有客体$x, P(x)$成立，则对个体域中某个任意客体$u，P(u) $成立。<br>该规则表示成： $(\forall x)P(x)\Rightarrow P(u)$</p></li><li><p>全称推广规则（UG规则）<br>如果能够证明对个体域中每一个客体$u$，命题$P(u)$ 都成立，则可得到结论$(\forall x)P(x)$成立。<br>该规则表示成：$P(u)\Rightarrow (\forall x)P(x)$</p></li><li><p>存在指定规则（ES规则）如果对于个体域中某些客体$P(x)$成立，则必有某个特定的客体$c$，使$P(c)$成立。<br>该规则表示成： $(\exists x)P(x)\Rightarrow P(c)$</p></li><li><p>存在推广规则（EG规则）<br>如果对个体域中某个特定客体$c$，有$P(c) $成立，则在个体域中，必存在$x$，使$P(x)$成立。<br>该规则表示成：$P(c)\Rightarrow (\exists x)P(x)$</p></li></ol><h4 id="推论规则及使用说明"><a href="#推论规则及使用说明" class="headerlink" title="推论规则及使用说明"></a>推论规则及使用说明</h4><p>命题逻辑中的$P，T，CP$规则和间接证明法，都可引用到谓词逻辑的推论规则中来，但要注意对量词做适当处理。<br>方法：用US，ES在推导中去掉量词；<br>用UG，EG使结论量化。</p><p>规则使用说明：<br>（1）在使用ES、US时，量词一定在最前面。<br>（2）推导中连续使用US规则，可用相同变元。<br>$$<br>(\forall x)P(x)\Rightarrow P(a) \\ (\forall x)Q(x)\Rightarrow Q(a)<br>$$<br>（3）推导中既用ES又用US时，必须先用ES后用US，方可取相同变元，反之不行。</p><p>$$<br>(\exists x)P(x)\Rightarrow P(a) \\ (\forall x)Q(x)\Rightarrow Q(a)<br>$$<br>注意：在推理中，不能在量词后面的辖域范围内进行蕴含推证或等价变换。必须消去量词后，才能对谓词公式进行蕴含或等价推证。</p><h2 id="非经典逻辑简介"><a href="#非经典逻辑简介" class="headerlink" title="非经典逻辑简介"></a>非经典逻辑简介</h2><h3 id="模态逻辑基础"><a href="#模态逻辑基础" class="headerlink" title="模态逻辑基础"></a>模态逻辑基础</h3><p>(1) 可能世界语义学</p><p>一个表达式的内涵是指该表达式的概念内容，而一个表达式的外延则是指该概念内容囊括的全体实例，内涵逻辑强调的是表达式在不同的语境可以有不同的指称（外延）。</p><p>(2) 模态逻辑的非形式讨论</p><p>必然：必然 $\Box$ ，记为 $\Box A$ ，即无论在什么场合（现实的场合或者可以想象到的非现实的场合）均有事实 $A$ 。<br>可能：可能 $\lozenge$ ，记为 $\lozenge A$ ，即对某些场合（也许只有一个，甚至只是想象到的某个场合）有事实 $A$ 。</p><p>根据以上定义，显然有以下的性质：<br> $\Box A\Leftrightarrow \neg \lozenge \neg A$ ，必然 $A$ 当且仅当不可能 $\neg A$ 。<br> $\lozenge A\Leftrightarrow \neg \Box \neg A$ ，可能 $A$ 当且仅当并非必然 $\neg A$ 。<br> $\lozenge A\vee \lozenge \neg A$ ，可能 $A$ 或者可能 $\neg A$ 。<br> $\neg(\Box A\wedge \Box \neg A)$ ，决不能既有必然 $A$ ，又有必然 $\neg A$ 。<br> $\Box (A\vee \neg A)$ ，必然地“ $A$ 成立或者不成立”。<br> $\neg \lozenge (A\wedge \neg A)$ ，不可能 $A$ 与 $\neg A$ 同时成立。<br> $\Box(A\wedge B)\Leftrightarrow(\Box A\wedge\Box B)$ ，必然有 $A$ 并且 $B$ 的充要条件为必然 $A$ 并且必然 $B$ 。<br> $(\Box A\vee\Box B)\rightarrow \Box(A\vee B)$ ，如果必然 $A$ 和必然 $B$ 有一为真，那么必然有“ $A$ 真或 $B$ 真”。<br> $\lozenge(A\vee B)\Leftrightarrow(\lozenge A\vee \lozenge B)$ ，可能“ $A$ 或者 $B$ ”当且仅当可能 $A$ 或者可能 $B$ 。<br> $\lozenge(A\wedge B)\rightarrow(\lozenge A\wedge \lozenge B)$ ，如果可能有“ $A$ 并且 $B$ ”，那么可能 $A$ 并且可能 $B$ 。<br> $\Box A\rightarrow A$ ，必然 $A$ 真则 $A$ 真。<br> $A\rightarrow\lozenge A$ ，若 $A$ 真则可能 $A$ 真。<br> $\Box A\rightarrow\lozenge A$ ，必然 $A$ 真则可能 $A$ 为真。</p><hr><p>$$<br>\mathscr{THE} \quad \mathscr{END}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>纯数学</category>
      
      <category>数学基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
