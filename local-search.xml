<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数理统计</title>
    <link href="/archives/df0b519f.html"/>
    <url>/archives/df0b519f.html</url>
    
    <content type="html"><![CDATA[<h1 id="数理统计"><a href="#数理统计" class="headerlink" title="数理统计"></a>数理统计</h1><h2 id="样本及抽样分布"><a href="#样本及抽样分布" class="headerlink" title="样本及抽样分布"></a>样本及抽样分布</h2><h3 id="随机样本"><a href="#随机样本" class="headerlink" title="随机样本"></a>随机样本</h3><p>随机样本：设 $X$ 是具有分布函数 $F$ 的随机变量，若 $X_1,\cdots,X_n$ 是具有分布函数 $F$ 的，相互独立的随机变量，则称 $X_1,X_2,\cdots,X_n$ 为从分布函数 $F$ （或总体 $F$ ，或总体 $X$ ）得到的容量为 $n$ 的简单随机样本，简称样本，它们的观察值 $x_1,\cdots,x_n$ 称为样本值，又称为 $X$ 的 $n$ 个独立的观察值。</p><h3 id="直方图和箱线图"><a href="#直方图和箱线图" class="headerlink" title="直方图和箱线图"></a>直方图和箱线图</h3>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>概统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象代数</title>
    <link href="/archives/9771975e.html"/>
    <url>/archives/9771975e.html</url>
    
    <content type="html"><![CDATA[<p>抽代好难啊！</p><span id="more"></span><h1 id="抽象代数"><a href="#抽象代数" class="headerlink" title="抽象代数"></a>抽象代数</h1><h2 id="集合与关系"><a href="#集合与关系" class="headerlink" title="集合与关系"></a>集合与关系</h2><h2 id="群和子群"><a href="#群和子群" class="headerlink" title="群和子群"></a>群和子群</h2><h3 id="引入与实例"><a href="#引入与实例" class="headerlink" title="引入与实例"></a>引入与实例</h3><h3 id="二元运算"><a href="#二元运算" class="headerlink" title="二元运算"></a>二元运算</h3><p>二元运算：一个在集合 $S$ 上的二元运算是一个从 $S\times S$ 到 $S$ 的函数。对于集合 $S\times S$ 中的任意一个元素 $(a,b)$ ，我们定义 $S$ 中的一个元素 $\star ((a,b))$ 为 $a\star b$ 。</p><p>封闭性：令 $\star $ 是集合 $S$ 上的一个二元运算且 $H$ 为集合 $S$ 的一个子集，当对任意的 $a,b\in H$ ，都有 $a\star b\in H$ ，则子集 $H$ 在 $\star $ 下封闭。</p><p>交换律：集合 $S$ 上的一个二元运算是可交换的当且仅当对任意的 $a,b\in S$ ， $a\star b= b\star a$ 。</p><p>结合律：集合 $S$ 上的一个二元运算是可结合的当且仅当对任意的 $a,b,c\in S$ ， $(a\star b)\star c=a\star (b\star c)$ 。</p><p>定理： $S$ 是一个集合， $f,g,h$ 是集合 $S$ 到 $S$ 的函数，则 $(f\circ g)\circ h=f\circ (g\circ h)$ 。</p><h3 id="同构二元结构"><a href="#同构二元结构" class="headerlink" title="同构二元结构"></a>同构二元结构</h3><p>同构：令 $&lt;S,\star &gt;$ 和 $&lt;S^{\prime},\circ &gt;$ 是二元代数结构， $S$ 和 $S^{\prime}$ 同构指的是存在一个从集合 $S$ 到集合 $S^{\prime}$ 一一对应的函数 $\varphi$ ，使得<br>$$<br>\varphi(x\star y)=\varphi(x)\circ \varphi(y)<br>$$<br>对任意的 $x,y\in S$ 都成立。如果这个映射 $\varphi$ 存在，则 $S$ 和 $S^{\prime}$ 是同构的二元结构，记为 $S\backsimeq S^{\prime}$ 。</p><p>单位元：令 $&lt;S,\star &gt;$ 是一个二元结构， $S$ 中的一个元素 $e$ 称为单位元当对任意 $s\in S$ 时， $e\star s=s\star e=s$ 。</p><p>单位元的唯一性：一个二元结构 $&lt;S,\star &gt;$ 有至多一个单位元，即如果有单位元，必然唯一。</p><p>定理：假设 $&lt;S,\star&gt;$ 有一个单位元 $e$ 。如果 $\varPhi$ 是 $S$ 到 $S^{\prime}$ 的一个同构，则 $\varPhi(e)$ 是一个在 $S^{\prime}$ 二元运算 $\circ $ 的一个单位元。</p><h3 id="群"><a href="#群" class="headerlink" title="群"></a>群</h3><p>群：群 $&lt;G,\star &gt;$ 是集合 $G$ 在一个在二元运算 $\star $ 下封闭，且满足以下条件</p><ol><li>对于任意的 $a,b,c\in G$ ，都有<br>$$<br>a\star (b\star c)=(a\star b)\star c<br>$$</li><li> $G$ 中存在一个元素 $e$ ，使得对任意<br>$$<br>e\star x=x\star e=x<br>$$</li><li>对于任意一个 $a\in G$ ，存在一个 $a^{\prime}\in G$ 使得<br>$$<br>a\star a^{\prime}=a^{\prime}\star a=e<br>$$</li></ol><p>定理：如果 $G$ 是一个群，二元运算为 $\star $ ，则 $G$ 满足消去律。即对于任意的 $a,b,c\in G$ ， $a\star b=a\star c$ 表明 $b=c$ ， $b\star a=c\star a$ 表明 $b=c$ 。</p><p>定理：如果 $G$ 是一个群，二元运算为 $\star $ ，则线性方程 $a\star x=b$ 和 $y\star a=b$ 在群 $G$ 中有唯一的解 $x$ 和 $y$ 。</p><p>定理：如果 $G$ 是一个群，二元运算为 $\star $ ，则 $G$ 中只有唯一的一个元素 $e$ 使得<br>$$<br>e\star x=x\star e=x<br>$$<br>对于任意 $x$ 成立。对于任意 $a\in G$ ， $G$ 中存在唯一的一个元素 $a^{\prime}$ 使得<br>$$<br>a^{\prime}\star a = a \star a^{\prime}=e<br>$$<br>总之，群的单位元和每个元素的逆元都是唯一的。</p><p>推论：令 $G$ 是一个群，对于所有的 $a,b\in G$ ，有 $(a\star b)^{\prime}=b^{\prime}\star a^{\prime}$ 。</p><p>此时，我们可以给群一个条件更弱的定义。</p><ol><li> $G$ 上的二元运算是可交换的。</li><li> $G$ 中存在一个左单位元 $e$ 使得对任意 $x\in G$ ， $e\star x=x$ 。</li><li>对于任意 $a\in G$ ， $G$ 中存在左逆元 $a^{\prime}$ 使得 $a^{\prime}\star a=e$ 。</li></ol><h3 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h3><p>子群：如果群 $G$ 的一个子集 $H$ 在群 $G$ 的二元运算 $\star $ 下封闭，且 $H$ 与 $G$ 的二元运算构成一个群，这个群称为 $G$ 的一个子群，记为 $H\leq G$ ，表示 $H$ 是 $G$ 的一个子群。记 $H&lt;G$ ，表示 $H$ 是 $G$ 的子群但是 $H\neq G$ 。</p><p>定义：如果 $G$ 是一个群，则包含 $G$ 自身的子群称为非真子群，其他的子群称为真子群。子群 $\{ e \}$ 是 $G$ 的平凡子群，其他的子群是  的非平凡子群。</p><p>定理：群 $G$ 的子集 $H$ 是 $G$ 的子群当且仅当</p><ol><li> $H$ 在 $G$ 的二元运算下封闭。</li><li> $G$ 的单位元 $e$ 在 $H$ 中。</li><li>对于任意的 $a\in H$ 则 $a^{\prime}\in H$ 。</li></ol><p>定理：令 $G$ 为一个群，令 $a\in G$ ，则<br>$$<br>H=\{ a^n | n\in \mathrm{Z} \}<br>$$<br>是 $G$ 的一个子群且是包含 $a$ 的 $G$ 的最小子群。即每一个包含 $a$ 的 $G$ 的子群包含 $H$ 。 $H$ 被称为由 $a$ 生成的 $G$ 的循环子群，记为 $&lt; a &gt;$ 。</p><h3 id="循环群"><a href="#循环群" class="headerlink" title="循环群"></a>循环群</h3><p>定理：每个循环群都是阿贝尔群。</p><p>定理：循环群的子群是循环群。</p><p>最大公因数：令 $r$ 和 $s$ 是两个正整数，循环群<br>$$<br>H=\{ nr+ms|n,m\in \mathbb{Z} \}<br>$$<br>在加法意义下的生成元 $d$ 是 $r$ 和 $s$ 的最大公因数，写成 $d=\gcd(r,s)$ 。</p><p>推论：如果 $r$ 和 $s$ 互素且如果 $r$ 整除 $sm$ ，则 $r$ 整除 $m$ 。</p><p>定理：设 $G$ 为由 $a$ 生成的循环群，如果 $G$ 的阶是无限的，则 $G$ 同构于 $&lt;\mathbb{Z},+&gt;$ 。如果 $G$ 有有限的阶 $n$ ，则 $G$ 同构于 $&lt;\mathbb{Z}_n,+_n&gt;$ 。</p><p>定理：令 $G$ 为由 $a$ 生成的 $n$ 阶循环群，令 $b\in G$ 且 $b=a^s$ ，则 $b$ 生成一个 $G$ 的有 $\frac{n}{d}$ 个元素的循环子群 $H$ ， $d$ 是 $n$ 和 $s$ 的最大公因数。同时， $&lt;a^t&gt;=&lt;a^s&gt;$ 当且仅当 $\gcd(s,n)=\gcd(t,n)$ 。</p><p>推论：如果 $a$ 是一个 $n$ 阶有限群 $G$ 的一个生成元，则 $G$ 的其他的生成元是 $a^r$ 的形式，其中 $r$ 和 $n$ 互质。</p><h3 id="生成元集和凯莱图"><a href="#生成元集和凯莱图" class="headerlink" title="生成元集和凯莱图"></a>生成元集和凯莱图</h3><p>定理：令 $\{ S_i|i\in I \}$ 是一个集族。集合 $\cap_{i\in I}S_i$ 的交集<br>$$<br>\cap_{i\in I}S_i=\{ x| \forall i \in I,x\in S_i \}<br>$$<br>如果 $I$ 是有限的， $I=\{ 1,2,\cdots ,n \}$ 可以将 $\cap_{i\in I}S_i$ 写成<br>$$<br>S_1\cap S_2\cap \cdots \cap S_n<br>$$</p><p>定理： $G$ 的一些子群 $H_i$ 的交集也是 $G$ 的子群。</p><p>定理：如果 $G$ 是一个群且对于 $i\in I$ 有 $a_i\in G$ 。则由 $\{a_i|i\in I}$ 生成的 $G$ 的子群 $H$ 有所有 $a_i$ 的整数次幂。</p><h2 id="置换陪集和直积"><a href="#置换陪集和直积" class="headerlink" title="置换陪集和直积"></a>置换陪集和直积</h2><p>置换：集合 $A$ 的一个置换是一个函数 $\varPhi:A\rightarrow A$ 且为一一对应。</p><h3 id="置换群"><a href="#置换群" class="headerlink" title="置换群"></a>置换群</h3><p>定理：令 $A$ 是一个非空的集合， $S_A$ 是 $A$ 所有置换的集合，则 $S_A$ 是在置换的合成意义下的群。</p><p>对称群：令 $A$ 为有限的集合 $\{ 1,2,\cdots ,n \}$ ， $A$ 所有置换组成的群称为 $n$ 次对称群，记为 $S_n$ ，显然， $S_n$ 有 $n!$ 个元素。</p><p>像：令 $f:A\rightarrow B$ 是一个函数， $H$ 为 $G$ 的子集， $H$ 在 $f$ 下的像是 $\{ f(h)|h\in H \}$ ，记为 $f[H]$ 。</p><p>引理：令 $G$ 和 $G^{\prime}$ 是群，令 $\phi:G\rightarrow G^{\prime}$ 是一个一一对应的函数使得对任意 $a,y\in G$ ， $\phi(xy)=\phi(x)\phi(y)$ 。则 $\phi[G]$ 是 $G^{\prime}$ 的一个子群且 $\phi $ 是 $G$ 和 $\phi [G]$ 的同构。</p><p>凯莱定理：每个群都同构于一个置换群。</p><h3 id="轨道，周期，交错群轨道"><a href="#轨道，周期，交错群轨道" class="headerlink" title="轨道，周期，交错群轨道"></a>轨道，周期，交错群轨道</h3><h2 id="同态和商群"><a href="#同态和商群" class="headerlink" title="同态和商群"></a>同态和商群</h2><h2 id="环和域"><a href="#环和域" class="headerlink" title="环和域"></a>环和域</h2><h2 id="理想和商环"><a href="#理想和商环" class="headerlink" title="理想和商环"></a>理想和商环</h2><h2 id="域的扩张"><a href="#域的扩张" class="headerlink" title="域的扩张"></a>域的扩张</h2><h2 id="群的进一步讨论"><a href="#群的进一步讨论" class="headerlink" title="群的进一步讨论"></a>群的进一步讨论</h2>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式问题</title>
    <link href="/archives/d63dd81.html"/>
    <url>/archives/d63dd81.html</url>
    
    <content type="html"><![CDATA[<p>LaTex与Markdown语法存在不兼容的情况，这里提供了例子与解决办法。</p><span id="more"></span><h1 id="格式问题"><a href="#格式问题" class="headerlink" title="格式问题"></a>格式问题</h1><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><p>代码；</p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>\&#123; hello,world \&#125;<span class="hljs-symbol">$</span><br></code></pre></div></td></tr></table></figure><p>显示：${ hello,world }$</p><p>解决方法：</p><p>代码：</p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>\\&#123; hello,world \\&#125;<span class="hljs-symbol">$</span><br></code></pre></div></td></tr></table></figure><p>显示：$\{ hello,world \}$</p><h2 id="行间公式换行"><a href="#行间公式换行" class="headerlink" title="行间公式换行"></a>行间公式换行</h2><p>代码；</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$$</span><br>\<span class="hljs-keyword">begin</span>&#123;cases&#125; hello \\ world \<span class="hljs-keyword">end</span>&#123;cases&#125;<br><span class="hljs-variable">$$</span><br></code></pre></div></td></tr></table></figure><p>显示：</p><p>$$<br>\begin{cases} hello \ world \end{cases}<br>$$</p><p>解决方法：</p><p>代码：</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir"><span class="hljs-variable">$$</span><br>\<span class="hljs-keyword">begin</span>&#123;cases&#125; hello \\\\ world \<span class="hljs-keyword">end</span>&#123;cases&#125;<br><span class="hljs-variable">$$</span><br></code></pre></div></td></tr></table></figure><p>显示：</p><p>$$<br>\begin{cases} hello \\ world \end{cases}<br>$$</p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>代码；</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">数乘：若 <span class="hljs-variable">$\</span><span class="hljs-built_in">lambda</span><span class="hljs-variable">$ </span>是一个数， <span class="hljs-variable">$A</span>=(a_&#123;ij&#125;)_&#123;m\times n&#125;<span class="hljs-variable">$ </span>是矩阵，则同型矩阵 <span class="hljs-variable">$(</span>\<span class="hljs-built_in">lambda</span> a_&#123;ij&#125;)_&#123;m\times n&#125;<span class="hljs-variable">$ </span>称为数 <span class="hljs-variable">$\</span><span class="hljs-built_in">lambda</span><span class="hljs-variable">$ </span>与矩阵 $A<span class="hljs-variable">$ </span>的乘积，记为 <span class="hljs-variable">$\</span><span class="hljs-built_in">lambda</span> A<span class="hljs-variable">$ </span>或 <span class="hljs-variable">$A</span>\<span class="hljs-built_in">lambda</span><span class="hljs-variable">$ </span>，即 <span class="hljs-variable">$\</span><span class="hljs-built_in">lambda</span> A=(\<span class="hljs-built_in">lambda</span> a_&#123;ij&#125;)_&#123;m\times n&#125;<span class="hljs-variable">$ </span>。<br></code></pre></div></td></tr></table></figure><p>显示：<br>数乘：若 $\lambda$ 是一个数， $A=(a_{ij})<em>{m\times n}$ 是矩阵，则同型矩阵 $(\lambda a</em>{ij})<em>{m\times n}$ 称为数 $\lambda$ 与矩阵 $A$ 的乘积，记为 $\lambda A$ 或 $A\lambda$ ，即 $\lambda A=(\lambda a</em>{ij})_{m\times n}$ 。</p><p>解决方法：</p><p>代码：</p><figure class="highlight ruby"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ruby">数乘：若 <span class="hljs-variable">$\</span><span class="hljs-built_in">lambda</span><span class="hljs-variable">$ </span>是一个数， <span class="hljs-variable">$A</span>=(a\_&#123;ij&#125;)\_&#123;m\times n&#125;<span class="hljs-variable">$ </span>是矩阵，则同型矩阵 <span class="hljs-variable">$(</span>\<span class="hljs-built_in">lambda</span> a\_&#123;ij&#125;)\_&#123;m\times n&#125;<span class="hljs-variable">$ </span>称为数 <span class="hljs-variable">$\</span><span class="hljs-built_in">lambda</span><span class="hljs-variable">$ </span>与矩阵 $A<span class="hljs-variable">$ </span>的乘积，记为 <span class="hljs-variable">$\</span><span class="hljs-built_in">lambda</span> A<span class="hljs-variable">$ </span>或 <span class="hljs-variable">$A</span>\<span class="hljs-built_in">lambda</span><span class="hljs-variable">$ </span>，即 <span class="hljs-variable">$\</span><span class="hljs-built_in">lambda</span> A=(\<span class="hljs-built_in">lambda</span> a\_&#123;ij&#125;)\_&#123;m\times n&#125;<span class="hljs-variable">$ </span>。<br></code></pre></div></td></tr></table></figure><p>显示：</p><p>数乘：若 $\lambda$ 是一个数， $A=(a_{ij})_{m\times n}$ 是矩阵，则同型矩阵 $(\lambda a_{ij})_{m\times n}$ 称为数 $\lambda$ 与矩阵 $A$ 的乘积，记为 $\lambda A$ 或 $A\lambda$ ，即 $\lambda A=(\lambda a_{ij})_{m\times n}$ 。</p><h2 id="变成链接"><a href="#变成链接" class="headerlink" title="!+[]+()变成链接"></a>!+[]+()变成链接</h2><p>代码；</p><figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml">$$</span><br><span class="xml">\begin</span><span class="hljs-template-variable">&#123;aligned&#125;</span><span class="xml"> N_m(x)=&amp;\frac</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="hljs-template-variable">&#123;\pi&#125;</span><span class="xml">J_m(x)\ln\frac</span><span class="hljs-template-variable">&#123;x&#125;</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="xml">-\frac</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="hljs-template-variable">&#123;\pi&#125;</span><span class="xml">\sum_</span><span class="hljs-template-variable">&#123;k=0&#125;</span><span class="xml">^</span><span class="hljs-template-variable">&#123;m-1&#125;</span><span class="xml">\frac</span><span class="hljs-template-variable">&#123;(m-k-1)&#125;</span><span class="hljs-template-variable">&#123;k!&#125;</span><span class="xml">(\frac</span><span class="hljs-template-variable">&#123;x&#125;</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="xml">)^</span><span class="hljs-template-variable">&#123;2k-m&#125;</span><span class="xml"> \\\\ &amp;-\frac</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="hljs-template-variable">&#123;\pi&#125;</span><span class="xml">\sum_</span><span class="hljs-template-variable">&#123;k=0&#125;</span><span class="xml">^</span><span class="hljs-template-variable">&#123;\infty&#125;</span><span class="xml">(-1)^k\frac</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="hljs-template-variable">&#123;k!(m+k)!&#125;</span><span class="xml">[\Phi(m+k+1)+\Phi(k+1)](\frac</span><span class="hljs-template-variable">&#123;x&#125;</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="xml">)^</span><span class="hljs-template-variable">&#123;2k+m&#125;</span><span class="xml"> \end</span><span class="hljs-template-variable">&#123;aligned&#125;</span><span class="xml"></span><br><span class="xml">$$</span><br></code></pre></div></td></tr></table></figure><p>显示：</p><p>$$<br>\begin{aligned} N_m(x)=&amp;\frac{2}{\pi}J_m(x)\ln\frac{x}{2}-\frac{1}{\pi}\sum_{k=0}^{m-1}\frac{(m-k-1)}{k!}(\frac{x}{2})^{2k-m} \\ &amp;-\frac{1}{\pi}\sum_{k=0}^{\infty}(-1)^k\frac{1}{k!(m+k)!}<a href="%5Cfrac%7Bx%7D%7B2%7D">\Phi(m+k+1)+\Phi(k+1)</a>^{2k+m} \end{aligned}<br>$$</p><p>解决方法：</p><p>代码：</p><figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml">\begin</span><span class="hljs-template-variable">&#123;aligned&#125;</span><span class="xml"> N_m(x)=&amp;\frac</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="hljs-template-variable">&#123;\pi&#125;</span><span class="xml">J_m(x)\ln\frac</span><span class="hljs-template-variable">&#123;x&#125;</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="xml">-\frac</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="hljs-template-variable">&#123;\pi&#125;</span><span class="xml">\sum_</span><span class="hljs-template-variable">&#123;k=0&#125;</span><span class="xml">^</span><span class="hljs-template-variable">&#123;m-1&#125;</span><span class="xml">\frac</span><span class="hljs-template-variable">&#123;(m-k-1)&#125;</span><span class="hljs-template-variable">&#123;k!&#125;</span><span class="xml">(\frac</span><span class="hljs-template-variable">&#123;x&#125;</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="xml">)^</span><span class="hljs-template-variable">&#123;2k-m&#125;</span><span class="xml"> \\\\ &amp;-\frac</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="hljs-template-variable">&#123;\pi&#125;</span><span class="xml">\sum_</span><span class="hljs-template-variable">&#123;k=0&#125;</span><span class="xml">^</span><span class="hljs-template-variable">&#123;\infty&#125;</span><span class="xml">(-1)^k\frac</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="hljs-template-variable">&#123;k!(m+k)!&#125;</span><span class="xml">\[\Phi(m+k+1)+\Phi(k+1)\](\frac</span><span class="hljs-template-variable">&#123;x&#125;</span><span class="hljs-template-variable">&#123;2&#125;</span><span class="xml">)^</span><span class="hljs-template-variable">&#123;2k+m&#125;</span><span class="xml"> \end</span><span class="hljs-template-variable">&#123;aligned&#125;</span><br></code></pre></div></td></tr></table></figure><p>显示：</p><p>$$<br>\begin{aligned} N_m(x)=&amp;\frac{2}{\pi}J_m(x)\ln\frac{x}{2}-\frac{1}{\pi}\sum_{k=0}^{m-1}\frac{(m-k-1)}{k!}(\frac{x}{2})^{2k-m} \\ &amp;-\frac{1}{\pi}\sum_{k=0}^{\infty}(-1)^k\frac{1}{k!(m+k)!}[\Phi(m+k+1)+\Phi(k+1)](\frac{x}{2})^{2k+m} \end{aligned}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等代数</title>
    <link href="/archives/37c0ce2.html"/>
    <url>/archives/37c0ce2.html</url>
    
    <content type="html"><![CDATA[<p>题目是高等代数，其实就是线性代数，线性代数大一已经考过了，这里整理一下备用，更新可能很慢。</p><span id="more"></span><h1 id="高等代数"><a href="#高等代数" class="headerlink" title="高等代数"></a>高等代数</h1><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="数域"><a href="#数域" class="headerlink" title="数域"></a>数域</h3><p>数域：设 $P$ 是由一些复数组成的集合，其中包括 0 与 1 。如果 $P$ 中任意两个数的和，差，积，商（除数不为0）仍然是 $P$ 中的数（封闭），那么 $P$ 就称为一个数域。</p><p>性质：所有的数域都包含有理数域作为它的一部分。</p><h3 id="一元多项式"><a href="#一元多项式" class="headerlink" title="一元多项式"></a>一元多项式</h3><p>一元多项式：设 $n$ 是一个非负整数，形式表达式<br>$$<br>a_nx^n+a_{n-1}x^{n-1}+\cdots +a_0<br>$$<br>其中 $a_0,\cdots,a_n$ 全属于数域 $P$ ，称为系数在数域 $P$ 中的一个一元多项式，或者简称为数域 $P$ 上的一元多项式。</p><p>相等：如果在多项式 $f(x)$ 与 $g(x)$ 中，除去系数为零的项外，同次项的系数全相等，那么 $f(x)$ 与 $g(x)$ 就称为相等，记为 $f(x)=g(x)$ 。<br>零多项式：系数全为零的多项式称为零多项式，记为0。</p><p>在多项式 $a_nx^n+a_{n-1}x^{n-1}+\cdots +a_0$ 中，如果 $a_n\neq 0$ ，那么 $a_nx^n$ 称为多项式的首项， $a_n$ 称为首项系数， $n$ 称为多项式的次数。零多项式是唯一不定义次数的多项式。多项式 $f(x)$ 的次数记为 $\partial(f(x))$ 。</p><p>设<br>$$<br>f(x)=\sum_{i=0}^na_ix^i \\ g(x)=\sum_{j=0}^mb_jx^j<br>$$</p><p>为数域 $P$ 上的两个多项式 $(n\geq m)$，则<br>$$<br>f(x)+g(x)=\sum_{i=0}^{n}(a_i+b_i)x^i \\ f(x)g(x)=\sum_{s=0}^{m+n}(\sum_{i+j=s}a_ib_j)x^s<br>$$<br>显然，数域 $P$ 上的两个多项式经过加，减，乘等运算后，所得结果仍然是数域 $P$ 上的多项式。</p><p>对于多项式的加法，有<br>$$<br>\partial(f(x)+g(x))\leq \max\{ \partial(f(x)),\partial(g(x)) \}<br>$$<br>对于多项式的乘法，如果 $f(x)\neq ,g(x)\neq 00$ ，那么 $f(x)g(x)\neq 0$ ，并且<br>$$<br>\partial(f(x)g(x))=\partial(f(x))+\partial(g(x))<br>$$<br>多项式乘积的首项系数就等于因子首项系数的乘积。</p><p>和代数运算一样，多项式的运算也满足加法交换律，加法结合律，乘法交换律，乘法结合律，乘法对加法的分配律，乘法消去律。</p><p>一元多项式环：所有系数在数域 $P$ 中的一元多项式的全体，称为数域 $P$ 上的一元多项式环，记为 $P[x]$ ， $P$ 称为 $P[x]$ 的系数域。</p><h3 id="整除的概念"><a href="#整除的概念" class="headerlink" title="整除的概念"></a>整除的概念</h3><p>带余除法：对于 $P[x]$ 中任意两个多项式 $f(x)$ 与 $g(x)$ ，其中 $g(x)\neq 0$ ，一定有 $P[x]$ 中的多项式 $q(x),r(x)$ 存在，使<br>$$<br>f(x)=q(x)g(x)+r(x)<br>$$<br>成立，其中 $\partial(r(x))&lt;\partial(g(x))$ 或者 $r(x)=0$ ，并且这样的 $q(x),r(x)$ 是唯一决定的。</p><p>带余除法中所得的 $q(x)$ 通常称为 $g(x)$ 除 $f(x)$ 的商式。 $r(x)$ 称为 $g(x)$ 除 $f(x)$ 的余式，简称商及余。</p><p>整除：数域 $P$ 上的多项式 $g(x)$ 称为整除 $f(x)$ ，如果有数域 $P$ 上的多项式 $h(x)$ 使等式<br>$$<br>f(x)=g(x)h(x)<br>$$<br>成立。我们用 $g(x)|f(x)$ 表示 $g(x)$ 整除 $f(x)$ ，用 $g(x)\not | f(x)$ 表示 $g(x)$ 不能整除 $f(x)$ 。<br>当 $g(x)|f(x)$ 时， $g(x)$ 就称为 $f(x)$ 的因式， $f(x)$ 称为 $g(x)$ 的倍式。</p><p>当 $g(x)\neq 0$ 时，带余除法给出了整除性的一个判别法。</p><p>定理：对于数域 $P$ 上的任意两个多项式 $f(x),g(x),g(x)\neq 0$ ， $g(x)|f(x)$ 的充分必要条件是 $g(x)$ 除 $f(x)$ 的余式为零。</p><p>整除的几个性质：</p><ol><li>如果 $f(x)|g(x),g(x)|f(x)$ ，那么 $f(x)=cg(x)$ ，其中 $c$ 为非零常数。</li><li>如果 $f(x)|g(x),g(x)|h(x)$ ，那么 $f(x)|h(x)$ 。</li><li>如果 $f(x)|g_i(x),i=1,2,\cdots,r$ ，那么 $f(x)|u_1(x)g_1(x)+\cdots+u_r(x)g_r(x)$ ，其中 $u_i(x)$ 是数域 $P$ 上的任意多项式。</li></ol><p>通常称 $u_1(x)g_1(x)+\cdots+u_r(x)g_r(x)$ 为多项式 $g_1(x)+\cdots+g_r(x)$ 的一个组合。</p><h3 id="最大公因式"><a href="#最大公因式" class="headerlink" title="最大公因式"></a>最大公因式</h3><p>最大公因式：设 $f(x),g(x)$ 是 $P[x]$ 中两个多项式。 $P[x]$ 中多项式 $d(x)$ 称为 $f(x),g(x)$ 的一个最大公因式，如果它满足下面两个条件：</p><ol><li> $d(x)$ 是 $f(x)$ 的公因式。</li><li> $f(x),g(x)$ 的公因式全是 $d(x)$ 的因式</li></ol><p>引理：如果有等式<br>$$<br>f(x)=q(x)g(x)+r(x)<br>$$<br>成立，那么 $f(x),g(x)$ 和 $g(x),r(x)$ 有相同的公因式。</p><p>定理：对于 $P[x]$ 中任意两个多项式 $f(x),g(x)$ ，在 $P[x]$ 中存在一个最大公因式 $d(x)$ ，且 $d(x)$ 可以表成 $f(x),g(x)$ 的一个组合，即有 $P[x]$ 中多项式 $u(x),v(x)$ 使<br>$$<br>d(x)=u(x)f(x)+v(x)g(x)<br>$$<br>互素： $P[x]$ 中两个多项式 $f(x),g(x)$  称为互素的，如果 $(f(x),g(x))=1$ 。</p><p>定理： $P[x]$ 中两个多项式 $f(x),g(x)$ 互素的充分必要条件是有 $P[x]$ 中的多项式 $u(x),v(x)$ 使<br>$$<br>u(x)f(x)+v(x)g(x)=1<br>$$<br>定理：如果 $(f(x),g(x))=1$ ，且 $f(x)|g(x)h(x)$ ，那么 $f(x)|h(x)$ 。</p><p>推论：如果 $f_1(x)|g(x),f_2(x)|g(x)$ ，且 $(f_1(x),f_2(x))=1$ ，那么 $f_1(x)f_2(x)|g(x)$ 。</p><h3 id="因式分解定理"><a href="#因式分解定理" class="headerlink" title="因式分解定理"></a>因式分解定理</h3><p>不可约多项式：数域 $P$ 上次数 $\geq 1$ 的多项式 $p(x)$ 称为域 $P$ 上的不可约多项式，如果它不能表成数域 $P$ 上的两个次数比 $p(x)$ 的次数低的多项式的乘积。</p><p>定理：如果 $p(x)$ 是一个不可约多项式，那么对于任意的两个多项式 $f(x),g(x)$ ，由 $p(x)|f(x)g(x)$ 一定推出 $p(x)|f(x)$ 或者 $p(x)|g(x)$ 。</p><p>因式分解及唯一性定理：数域 $P$ 上每一个次数 $\geq 1$ 的多项式 $f(x)$ 都可以唯一的分解成数域 $P$ 上一些不可约多项式的乘积，所谓唯一性是说，如果有两个分解式<br>$$<br>f(x)=p_1(x)p_2(x)\cdots p_s(x)=q_1(x)q_2(x)\cdots q_t(x)<br>$$<br>那么必有 $s=t$ ，并且适当排列后次序有<br>$$<br>p_i(x)=c_iq_i(x),i=1,2,\cdots,s<br>$$<br>其中 $c_i(i=1,2,\cdots,s)$ 是一些非零常数。</p><p>在多项式 $f(x)$ 的分解式中，可以把每一个不可约因式的首项系数提出来，使他们成为首项系数为1的多项式，再把相同的不可约因式合并，于是 $f(x)$ 的分解式成为<br>$$<br>f(x)=cp_1^{r_1}(x)p_2^{r_2}(x)\cdots p_s^{r_s}(x)<br>$$<br>其中 $c$ 是 $f(x)$ 的首项系数， $p_1(x),p_2(x),\cdots, p_s(x)$ 是不同的首项系数为1的不可约多项式，而 $r_1,r_2,\cdots,r_s$ 是正整数，这种分解式称为标准分解式。</p><h3 id="重因式"><a href="#重因式" class="headerlink" title="重因式"></a>重因式</h3><p>重因式：不可约多项式 $p(x)$ 称为多项式 $f(x)$ 的 $k$ 重因式，如果 $p^k(x)|f(x)$ ，而 $p^{k+1}(x)\not |f(x)$ 。</p><p>如果 $k=0$ ，那么 $p(x)$ 根本不是 $f(x)$ 的因式，如果 $k=1$ ，那么 $p(x)$ 称为 $f(x)$ 的单因式，如果 $k&gt;1$ ，那么 $p(x)$ 称为 $f(x)$ 的重因式。</p><p>定理：如果不可约多项式 $p(x)$ 是 $f(x)$ 的 $k$ 重因式 $k\geq 1$ ，那么它是微商 $f^{\prime}(x)$ 的 $k-1$ 重因式。</p><p>推论：如果不可约多项式 $p(x)$ 是 $f(x)$ 的 $k$ 重因式 $k\geq 1$ ，那么 $p(x)$ 是 $f(x),f^{\prime}(x),\cdots,f^{(k-1)}(x)$ 的因式，但不是 $f^{(k)}(x)$ 的因式。</p><p>推论：不可约多项式 $p(x)$ 是 $f(x)$ 的重因式的充分必要条件为 $p(x)$ 是 $f(x)$ 与 $f^{\prime}(x)$ 的公因式。</p><p>推论：多项式 $f(x)$ 没有重因式的充分必要条件是 $f(x)$ 与 $f^{\prime}(x)$ 互素。</p><h3 id="多项式函数"><a href="#多项式函数" class="headerlink" title="多项式函数"></a>多项式函数</h3><p>设<br>$$<br>f(x)=a_nx^n+\cdots+a_1x+a_0<br>$$<br>是 $P[x]$ 中的多项式， $\alpha$ 是 $P$ 中的数，代入有<br>$$<br>a_n\alpha^n+\cdots+a_1\alpha+a_0<br>$$<br>称为 $f(x)$ 当 $x=\alpha$ 时的值，记为 $f(\alpha)$ 。称这个函数为数域 $P$ 上的多项式函数。</p><p>余数定理：用一次多项式 $x-\alpha$ 去除多项式 $f(x)$ ，所得的余式是一个常数，这个常数等于函数值 $f(\alpha)$ 。</p><p>如果 $f(x)$ 在 $x=\alpha$ 时函数值 $f(\alpha)=0$ ，那么 $\alpha$ 就称为 $f(x)$ 的一个根或零点。</p><p>推论： $\alpha$ 是 $f(x)$ 的根的充分必要条件是 $(x-\alpha)|f(x)$ 。<br>由这个关系，我们可以定义重根的概念， $\alpha$ 称为 $f(x)$ 的 $k$ 重根，如果 $x-\alpha$ 是 $f(x)$ 的 $k$ 重因式。当 $k=1$ 时， $\alpha$ 称为单根，当 $k&gt;1$ 时， $\alpha$ 称为重根。</p><p>定理： $P[x]$ 中 $n$ 次多项式 $n\geq 0$ 在数域 $P$ 中的根不可能多于 $n$ 个，重根按重数计算。</p><p>定理：如果多项式 $f(x),g(x)$ 的次数都不超过 $n$ ，而它们对 $n+1$ 个不同的数 $\alpha_1,\cdots ,\alpha_{n+1}$ 有相同的值，即<br>$$<br>f(\alpha_i)=g(\alpha_i),i=1,1,\cdots,n+1,<br>$$<br>那么 $f(x)=g(x)$ 。</p><h3 id="复系数与实系数多项式的因式分解"><a href="#复系数与实系数多项式的因式分解" class="headerlink" title="复系数与实系数多项式的因式分解"></a>复系数与实系数多项式的因式分解</h3><p>代数基本定理：每个次数 $\geq 1$ 的复系数多项式在复数域中有一根。</p><p>复系数多项式因式分解定理：每个次数 $\geq 1$ 的复系数多项式在复数域上都可以唯一地分解成一次因式的乘积。<br>因此，复系数多项式具有标准分解式<br>$$<br>f(x)=a_n(x-\alpha_1)^{l_1}\cdots (x-\alpha_s)^{l_s}<br>$$<br>其中 $\alpha_1,\cdots,\alpha_s$ 是不同的复数， $l_1,\cdots l_s$ 是正整数。这说明每个 $n$ 次复系数多项式恰有 $n$ 个复根（重根按重数计算）。</p><p>对于实系数多项式，以下的事实是基本的，即，如果 $\alpha$ 是实系数多项式 $f(x)$ 的复根，那么 $\alpha$ 的共轭数 $\overline{\alpha}$ 也是 $f(x)$ 的根。因为设<br>$$<br>f(x)=a_nx^n+\cdots+a_0<br>$$<br>其中 $a_0,\cdots,a_n$ 是实数。由假设<br>$$<br>f(\alpha)=a_n\alpha^n+\cdots+a_0=0<br>$$<br>两边取共轭数，有<br>$$<br>0=\overline{f(\alpha)}=a_n\overline{\alpha}^n+\cdots +a_0=f(\overline{\alpha})<br>$$<br>这就是说 $f(\overline{\alpha})=0$ ， $\overline{\alpha}$ 也是 $f(x)$ 的根。</p><p>实系数多项式因式分解定理：每个次数 $\geq 1$ 的实系数多项式在实数域上都可以唯一地分解成一次因式与二次不可约因式的乘积。</p><h3 id="有理系数多项式"><a href="#有理系数多项式" class="headerlink" title="有理系数多项式"></a>有理系数多项式</h3><p>本原多项式：如果一个非零的整系数多项式 $g(x)=b_nx^n+\cdots+b_0$ 的系数 $b_n,\cdots,b_0$ 没有异于 $\pm 1$ 的公因子，也就是说，它们是互素的，它就称为一个本原多项式。</p><p>高斯引理：两个本原多项式的乘积还是本原多项式。</p><p>定理：如果一非零的整系数多项式能够分解成两个次数较低的有理系数多项式的乘积，那么它一定能分解成两个次数较低的整系数多项式的乘积。</p><p>推论：设 $f(x),g(x)$ 是整系数多项式，且 $g(x)$ 是本原的，如果 $f(x)=g(x)h(x)$ ，其中 $h(x)$ 是有理系数多项式，那么 $h(x)$ 一定是整系数的。</p><p>定理：设 $f(x)=a_nx^n+\cdots +a_0$ 是一个整系数多项式，而 $\frac{r}{s}$ 是它的一个有理根，其中 $r,s$ 互素，那么必有 $s|a_n,r|a_0$ 。特别的，如果 $f(x)$ 的首项系数 $a_n=1$ ，那么 $f(x)$ 的有理根都是整根，而且是 $a_0$ 的因子。</p><p>艾森斯坦判别法：设 $f(x)=a_nx^n+\cdots +a_0$ 是一个整系数多项式。如果有一个素数 $p$ ，使得</p><p>$$<br>\begin{equation*}<br>p\not |a_n;\quad<br>p|a_{n-1},a_{n-2},\cdots ,a_0; \quad<br>p^2\not |a_0<br>\end{equation*}<br>$$</p><p>那么 $f(x)$ 在有理数域上是不可约的。</p><h3 id="多元多项式"><a href="#多元多项式" class="headerlink" title="多元多项式"></a>多元多项式</h3><h3 id="对称多项式"><a href="#对称多项式" class="headerlink" title="对称多项式"></a>对称多项式</h3><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>求解线性方程组：<br>对于二元线性方程组<br>$$<br>\begin{cases} a_{11}x_1+a_{12}x_2=b_1 \\ a_{21}x_1+a_{22}x_2=b_2\end{cases}<br>$$</p><p>当 $a_{11}a_{22}-a_{12}a_{21}\neq 0$ 时，此方程有唯一解，即<br>$$<br>x_1=\dfrac{b_1a_{22}-a_{12}b_2}{a_{11}a_{22}-a_{12}a_{21}} ,<br>x_2=\dfrac{a_{11}b_2-a_{21}b_1}{a_{11}a_{22}-a_{12}a_{21}}<br>$$<br>我们称 $a_{11}a_{22}-a_{12}a_{21}$ 为二阶行列式，用符号表示为<br>$$<br>a_{11}a_{22}-a_{12}a_{21}=\begin{vmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{vmatrix}<br>$$<br>于是，当 $\begin{vmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{vmatrix}\neq 0$ 时，该方程有唯一解，解为<br>$$<br>x_1=\dfrac{\begin{vmatrix}b_1&amp;a_{12}\\b_2&amp;a_{22}\end{vmatrix}}{\begin{vmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{vmatrix}} ,<br>x_2=\dfrac{\begin{vmatrix}a_{11}&amp;b_1\\a_{21}&amp;b_2\end{vmatrix}}{\begin{vmatrix}a_{11}&amp;a_{12}\\a_{21}&amp;a_{22}\end{vmatrix}}<br>$$<br>同理，可以定义三阶行列式。</p><h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><p>排列：由 $1,2,3,\cdots,n$ 组成的一个有序数组称为一个 $n$ 级排列。</p><p>逆序数：在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么他们就称为一个逆序，一个排列中逆序的总数就称为这个排列的逆序数。排列 $j_1j_1\cdots j_n$ 的逆序数记为 $\tau(j_1j_1\cdots j_n)$ 。</p><p>偶排列与奇排列：逆序数为偶数的排列称为偶排列，逆序数为奇数的排列称为奇排列。</p><p>对换：把一个排列中某两个数的位置互换，其余数不动，这样一个变换称为对换。</p><p>定理：对换改变排列的奇偶性。</p><p>推论：在全部的 $n$ 级排列中，奇偶排列的个数相等，各有 $\frac{n!}{2}$ 个。</p><p>定理：任意一个 $n$ 级排列与排列 $12\cdots n$ 都可以经过一系列对换互变，并且所做对换的个数与这个排列有相同的奇偶性。</p><h3 id="n-阶行列式的定义"><a href="#n-阶行列式的定义" class="headerlink" title="$n$ 阶行列式的定义"></a>$n$ 阶行列式的定义</h3><p> $n$ 阶行列式：由 $n^2$ 个数 $a_{ij}$ （称为行列式的元）排成一个 $n$ 行 $n$ 列的表，并在两边各画一条竖线的记号<br>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\ a_{21}&amp;a_{22}&amp;\cdots &amp;a_{2n} \\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots \\ a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$<br>称为 $n$ 阶行列式。</p><p> $n$ 阶行列式表示的代数和的所有项，即<br>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;a_{13} \\ a_{21}&amp;a_{22}&amp;a_{23} \\ a_{31}&amp;a_{32}&amp;a_{33}\end{vmatrix}<br>$$</p><!-- 其中 $\sum\_{j\_1,j\_2}$ 表示对 $$ 的一切排列取和。用符号 $$ 或 $$ 表示以 $$ 为元的 $$ 阶行列式。 --><p>上三角行列式：当 $i&gt;j$ 时， $a_{ij}=0$ 。<br>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\ 0&amp;a_{22}&amp;\cdots &amp;a_{2n} \\ \vdots &amp;\vdots &amp;\ddots&amp;\vdots  \\  0&amp;0&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$<br>上三角行列式的值等于其主对角线上各元之积。</p><h3 id="n-阶行列式的性质"><a href="#n-阶行列式的性质" class="headerlink" title="$n$ 阶行列式的性质"></a>$n$ 阶行列式的性质</h3><p>性质1：行列式的行和列顺次互换，其值不变，即</p><p>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\ a_{21}&amp;a_{22}&amp;\cdots &amp;a_{2n} \\ \vdots &amp;\vdots &amp;\ddots&amp;\vdots  \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}=\begin{vmatrix}a_{11}&amp;a_{21}&amp;\cdots &amp;a_{n1} \\ a_{12}&amp;a_{22}&amp;\cdots &amp;a_{n2} \\ \vdots &amp;\vdots &amp;\ddots&amp;\vdots  \\  a_{1n}&amp;a_{2n}&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$</p><p>上述两个行列式互称转置行列式。</p><p>说明行列式中行与列的地位是对称的，平等的，因此行列式对行成立的性质，对列也同样成立。</p><p>性质2：互换行列式的两行（或两列），行列式变号。</p><p>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{t1}&amp;a_{t2}&amp;\cdots &amp;a_{tn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ a_{s1}&amp;a_{s2}&amp;\cdots &amp;a_{sn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}=-\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{s1}&amp;a_{s2}&amp;\cdots &amp;a_{sn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ a_{t1}&amp;a_{t2}&amp;\cdots &amp;a_{tn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$<br>推论：行列式中两行（列）完全相同，则行列式为0。</p><p>性质3：行列式中某行（列）的元有因子 $K$ ，则 $K$ 可提到行列式符号外边。<br>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ Ka_{t1}&amp;Ka_{t2}&amp;\cdots &amp;Ka_{tn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}=K\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{t1}&amp;a_{t2}&amp;\cdots &amp;a_{tn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$<br>若用 $K$ 乘某行列式的某行（列），则等于用 $K$ 乘该行列式。</p><p>性质4：若行列式中某行（列）的元均可表示为两项之和，例如第 $i$ 行<br>$$<br>a_{ij}=b_{ij}+c_{ij},(j=1,2,\cdots ,n)<br>$$<br>则此行列式等于两个行列式之和，这两个行列式除第 $i$ 行的元分别为 $b_{ij}$ 与 $c_{ij}$ 外，其余各行都与原行列式一样，即<br>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ b_{i1}+c_{i1}&amp;b_{i2}+c_{i2}&amp;\cdots &amp;b_{in}+c_{in} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}=\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ b_{i1}&amp;b_{i2}&amp;\cdots &amp;b_{in} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}+\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ c_{i1}&amp;c_{i2}&amp;\cdots &amp;c_{in} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$<br>性质5：</p><ol><li>行列式某行（列）的元全为零。</li><li>行列式的两行（列）完全相同。</li><li>行列式的两行（列）的元成比例。<br>若上述条件之一成立，该行列式的值为零。</li></ol><p>性质6：若把行列式的某行（列） $\lambda$ 倍后加到另一行（列）上，则行列式的值不变。</p><p>$$<br>\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{i1}+\lambda a_{j1}&amp;a_{i2}+\lambda a_{j2}&amp;\cdots &amp;a_{in}+\lambda a_{jn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ a_{j1}&amp;a_{j2}&amp;\cdots &amp;a_{jn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}=\begin{vmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{i1}&amp;a_{i2}&amp;\cdots &amp;a_{in} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ a_{j1}&amp;a_{j2}&amp;\cdots &amp;a_{jn} \\  \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\  a_{n1}&amp;a_{n2}&amp;\cdots &amp;a_{nn}\end{vmatrix}<br>$$</p><h3 id="行列式按行（列）展开"><a href="#行列式按行（列）展开" class="headerlink" title="行列式按行（列）展开"></a>行列式按行（列）展开</h3><!-- 余子式： $$ 恰好是行列式 $$ 中元 $$ 所在的第一行与第一列划去之后所得的 $$ 阶行列式， $$ 称为元 $$ 在 $$ 中的余子式。 --><p>代数余子式： $M_{ij}$ 是把行列式 $|A|$ 中元 $a_{ij}$ 所在的第 $i$ 行，第 $j$ 列划掉后所得到的 $n-1$ 阶行列式， $M_{ij}$ 称为元 $a_{ij}$ 在 $|A|$ 中的余子式，记 $A_{ij}=(-1)^{i+j}M_{ij}$ ， $A_{ij}$ 称为元 $a_{ij}$ 在 $|A|$ 中的代数余子式。</p><!-- $$\begin{vmatrix}a\_{11}&a\_{12}&\cdots &a\_{1n} \\\\ a\_{21}&a\_{22}&\cdots &a\_{2n} \\\\ \vdots &\vdots &\ddots&\vdots \\\\  a\_{n1}&a\_{n2}&\cdots &a\_{nn}\end{vmatrix}$$ --><p>定理： $n$ 阶 $n\geq 2$ 行列式等于它的任一行的各元与其代数余子式乘积之和，即<br>$$<br>|A|=\sum_{k=1}^na_{ik}A_{ik}(i=1,2,\cdots ,n)<br>$$<br>定理： $n$ 阶行列式等于它的任何一列的各元与其代数余子式乘积之和，即<br>$$<br>|A|=\sum_{k=1}^na_{kj}A_{kj}(j=1,2,\cdots ,n)<br>$$<br>定理： $n$ 阶行列式的任一行的各元与另一行对应元代数余子式乘积之和为零，即<br>$$<br>\sum_{k=1}^{n}a_{jk}A_{ik}=0(i\neq j)<br>$$<br>定理： $n$ 阶行列式的任一列的各元与另一列对应元代数余子式乘积之和为零，即<br>$$<br>\sum_{k=1}^{n}a_{kj}A_{ki}=0(i\neq j)<br>$$<br>于是有</p><p>$$<br>\sum_{k=1}^na_{jk}A_{ik}=\begin{cases} |A|,j = i \\ 0,j\neq i \end{cases},(i,j=1,2,\cdots ,n)<br>$$</p><p>$$<br>\sum_{k=1}^na_{kj}A_{ki}=\begin{cases} |A|,j = i \\ 0,j\neq i \end{cases},(i,j=1,2,\cdots ,n)<br>$$</p><p>范德蒙德行列式：<br>$$<br>V(x_1,x_2,\cdots,x_n)=\begin{vmatrix}1&amp;1&amp;1&amp;1 \\ x_{1}&amp;x_{2}&amp;\cdots &amp;x_{n}\\x_{1}^{2}&amp;x_{2}^{2}&amp;\cdots &amp;x_{n}^{2}\\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\x_{1}^{n-1}&amp;x_{2}^{n-1}&amp;\cdots &amp;x_{n}^{n-1}\end{vmatrix}=\prod_{1\leq j &lt; i\leq n}(x_i-x_j)<br>$$<br>互为余子式：在 $n$ 阶行列式在，任意指定 $r$ 个行与 $r$ 个列 $(1\leq r&lt;n)$ ，位于这些行列交点处的 $r^2$ 个元构成的 $r$ 阶行列式 $M$ 称为原行列式的一个 $r$ 阶子式。在 $n$ 阶行列式中，划去某个 $r$ 阶子式 $M$ 所在的行和列后，剩下的 $n-r$ 个行和 $n-r$ 个列上的元也构成一个 $n-r$ 阶子式 $N$ ，我们称这一对子式 $M$ 与 $N$ 互为余子式。</p><p>拉普拉斯定理：在 $n$ 阶行列式中任意选定 $k$ 个行（列） $1\leq k&lt;n$ ，则 $n$ 阶行列式等于位于这 $k$ 个行（列）中的一切 $k$ 阶子式 $M_i(i=1,2,\cdots,C_{n}^{k})$ 与其对应的代数余子式 $A_i$ 乘积之和，即<br>$$<br>|A|=\sum_{i=1}^{C_n^k}M_iA_i<br>$$</p><h2 id="矩阵代数"><a href="#矩阵代数" class="headerlink" title="矩阵代数"></a>矩阵代数</h2><h3 id="矩阵的概念"><a href="#矩阵的概念" class="headerlink" title="矩阵的概念"></a>矩阵的概念</h3><p>矩阵：由 $m\times n$ 个数 $$a_{ij}(i=1,\cdots,m;j=1,\cdots,n)$$ 排成的 $m$ 行 $n$ 列的数表<br>$$<br>\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\ a_{21}&amp;a_{22}&amp;\cdots &amp;a_{2n} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{m1}&amp;a_{m2}&amp;\cdots &amp;a_{mn}\end{pmatrix}<br>$$<br>称为 $m$ 行 $n$ 列矩阵（或 $m\times n$ 矩阵）。数 $a_{ij}$ 称为矩阵的元。</p><p>常用大写字母 $A,B,\cdots$ 表示矩阵，矩阵也可以表示为 $A=(a_{ij})$ ， $A_{m\times n}$ ， $(a_{ij})_{m\times n}$ 等。</p><p>特别的，当矩阵的行数和列数相等的时候称为方阵。 $n$ 行 $n$ 列的矩阵也被称为 $n$ 阶方阵。</p><p>实矩阵与复矩阵：如果矩阵 $A$ 的每个元 $a_{ij}$ 都是实数，矩阵 $A$ 称为实矩阵；如果 $A$ 的元是复数， $A$ 称为复矩阵。</p><p>同型矩阵：如果矩阵 $A$ 和 $B$ 有相同的行数与相同的列数，则 $A$ 与 $B$ 称为同型矩阵。</p><p>系数矩阵：考虑线性方程组<br>$$<br>\begin{cases} a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1, \\ a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2,\\ \cdots \\ a_{m1}x_1+a_{m2}x_2+\cdots+a_{mn}x_n=b_m \end{cases}<br>$$<br>由未知量的系数 $a_{ij}$ 所构成的 $m\times n$ 矩阵<br>$$<br>A=\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n} \\ a_{21}&amp;a_{22}&amp;\cdots &amp;a_{2n} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ a_{m1}&amp;a_{m2}&amp;\cdots &amp;a_{mn}\end{pmatrix}<br>$$<br>称为方程组的系数矩阵。</p><p>常数列矩阵：由方程组右端常数项 $b_i$ 构成的 $m\times 1$ 矩阵<br>$$<br>b=\begin{pmatrix}b_1 \\ b_2 \\ \vdots \\ b_m \end{pmatrix}<br>$$<br>称为方程组的常数列矩阵。</p><p>增广矩阵：由系数 $a_{ij}$ 和常数项 $b_i$ 组成的矩阵<br>$$<br>B=\begin{pmatrix}a_{11}&amp;a_{12}&amp;\cdots &amp;a_{1n}&amp;b_1 \\ a_{21}&amp;a_{22}&amp;\cdots &amp;a_{2n}&amp;b_2 \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots &amp;\vdots  \\ a_{m1}&amp;a_{m2}&amp;\cdots &amp;a_{mn}&amp;b_m\end{pmatrix}=(A,b)<br>$$<br>称为方程组的增广矩阵。</p><p>行向量与列向量：常把 $1\times n$ 矩阵称为 $n$ 维行向量， $n\times 1$ 矩阵称为 $n$ 维列向量。矩阵也可以写成行向量按列排列和列向量按行排列的形式。</p><h3 id="矩阵的代数运算"><a href="#矩阵的代数运算" class="headerlink" title="矩阵的代数运算"></a>矩阵的代数运算</h3><h4 id="矩阵的加法和数乘"><a href="#矩阵的加法和数乘" class="headerlink" title="矩阵的加法和数乘"></a>矩阵的加法和数乘</h4><p>相等：如果同型矩阵 $A=(a_{ij}),B=(b_{ij})$ 的对应元都相等，即 $a_{ij}=b_{ij}$ ，则称 $A$ 与 $B$ 相等，记为 $A=B$ 。</p><p>和：两个同型矩阵 $A={(a_{ij})}_{m\times n}$ 和 $B=(b_{ij})_{m\times n}$ 的对应元相加所得的同型矩阵 $C=(a_{ij}+b_{ij})_{m\times n}$ 称为矩阵 $A$ 与 $B$ 之和，记为 $C=A+B$ 。</p><!-- 和：两个同型矩阵 $A={(a\_{ij})}$ 和 $B=(b\_{ij})$ 的对应元相加所得的同型矩阵 $C=(a\_{ij}+b\_{ij})$ 称为矩阵 $A$ 与 $B$ 之和，记为 $C=A+B$ 。 --><p>零矩阵：每个元都等于零的 $m\times n$ 矩阵称为零矩阵，记为 $0_{m\times n}$ 或者 $0$ 。显然对一切 $A=A_{m\times n}$ 恒有 $0_{m\times n}+A_{m\times n}=A_{m\times n}$ 或 $0+A=A$ 。</p><p>负矩阵：若与 $A$ 同型的矩阵 $B$ 的每个元是矩阵 $A$ 的对应元的相反数，则称矩阵 $B$ 为 $A$ 的负矩阵。 $A$ 的负矩阵记为 $-A$ ，显然 $A+(-A)=0$ 。</p><p>差：若矩阵 $A,B$ 是同型矩阵，则称矩阵 $A+(-B)$ 为 $A$ 与 $B$ 的差，并记为 $A-B$ ，即 $A-B=A+(-B)$ 。</p><p>显然， $A=B$ 的充要条件是 $A-B=0$ 。</p><p>数乘：若 $\lambda$ 是一个数， $A=(a_{ij})_{m\times n}$ 是矩阵，则同型矩阵 $(\lambda a_{ij})_{m\times n}$ 称为数 $\lambda$ 与矩阵 $A$ 的乘积，记为 $\lambda A$ 或 $A\lambda$ ，即 $\lambda A=(\lambda a_{ij})_{m\times n}$ 。</p><!-- 数乘：若 $\lambda$ 是一个数， $A=(a\_{ij})$ 是矩阵，则同型矩阵 $(\lambda a\_{ij})$ 称为数 $\lambda$ 与矩阵 $A$ 的乘积，记为 $\lambda A$ 或 $A\lambda$ ，即 $\lambda A=(\lambda a\_{ij})$ 。 --><p>矩阵的加（减）法和数与矩阵的数乘统称为矩阵的线性运算。</p><p>性质：</p><ol><li>加法交换律 $A+B=B+A$ </li><li>加法结合律 $(A+B)+C=A+(B+C)$ </li><li>数乘的分配律 $$\lambda (A+B)=\lambda A+\lambda B$$ $$(\lambda+\mu)A=\lambda A+\mu A$$</li><li>数乘的结合律 $\lambda(\mu A)=(\lambda \mu)A$ </li><li>$1A=A$<br>其中 $A,B,C$ 是使上述矩阵线性运算有意义的矩阵， $\lambda,\mu $ 为数。</li></ol><p>线性组合：设给定了若干个同型矩阵 $A_1,\cdots,A_m$ ，经过线性运算<br>$$<br>\lambda_1A_1+\lambda_2A_2+\cdots+\lambda_mA_m=\sum_{j=1}^{m}\lambda_jA_j=B<br>$$<br>（其中 $\lambda_j$ 是常数， $j=1,2,\cdots,m$ ）得到的矩阵 $B$ 称为矩阵 $A_1,\cdots,A_m$ 的线性组合。或者称 $B$ 可经 $A_1,\cdots,A_m$ 线性表出。</p><h4 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h4><p>矩阵与列向量的乘积：设 $A=(a_{ij})_{m\times n},C=(c_j)_{n\times 1}$ ，则规定 $m\times n$ 矩阵 $A$ 与 $n$ 维列向量 $C$ 相乘的乘积 $AC$ 是以 $d_i=\sum_{j=1}^n{a_{ij}c_j}$ $(i=1,\cdots ,n)$ 为分量的 $m$ 维列向量，即</p><!-- 矩阵与列向量的乘积：设 $A=(a\_{ij}),C=(c\_j)$ ，则规定 $m\times n$ 矩阵 $A$ 与 $n$ 维列向量 $C$ 相乘的乘积 $AC$ 是以 $$d\_i=\sum\_{j=1}^n{a\_{ij}c\_j} (i=1,\cdots ,n)$$ 为分量的 $m$ 维列向量，即 --><p>$$<br>AC=\begin{pmatrix}a_{11}c_1+a_{12}c_2+\cdots +a_{1n}c_n\\a_{21}c_1+a_{22}c_2+\cdots +a_{2n}c_n\\ \vdots\\a_{m1}c_1+a_{m2}c_2+\cdots +a_{mn}c_n\end{pmatrix}<br>$$</p><p>矩阵与矩阵的乘积：设 $A=(a_{ij})_{m\times n}$ ， $B=(b_{ij})_{n\times s}$ ， $A$ 与 $B$ 相乘的乘积 $AB$ 定义如下</p><!-- 矩阵与矩阵的乘积：设 $A=(a\_{ij})$ ， $B=(b\_{ij})$ ， $A$ 与 $B$ 相乘的乘积 $AB$ 定义如下 --><p>$$<br>AB=\begin{pmatrix}\sum_{k=1}^na_{1k}b_{k1}&amp;\sum_{k=1}^na_{1k}b_{k2}&amp;\cdots &amp;\sum_{k=1}^na_{1k}b_{ks} \\ \sum_{k=1}^na_{2k}b_{k1}&amp;\sum_{k=1}^na_{2k}b_{k2}&amp;\cdots &amp;\sum_{k=1}^na_{2k}b_{ks} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ \sum_{k=1}^na_{mk}b_{k1}&amp;\sum_{k=1}^na_{mk}b_{k2}&amp;\cdots &amp;\sum_{k=1}^na_{mk}b_{ks}\end{pmatrix}=D<br>$$</p><p>即， $A$ 与 $B$ 相乘所得的矩阵 $D$ 是 $m\times s$ 矩阵。它的元 $d_{ij}=\sum_{k=1}^na_{ik}b_{kj}$ $(i=1,2,\cdots,m)$,$j=1,2,\cdots,s$ 由 $A$ 的第 $i$ 个行向量与 $B$ 的第 $j$ 个列向量的对应分量乘积之和。</p><p>矩阵乘法不符合交换律。</p><p>若 $AB$ 有意义，称 $A$ 右乘 $B$ ，或者 $B$ 左乘 $A$ 。</p><p>矩阵乘法不满足消去律，当 $A$ 和 $B$ 都是非零矩阵时，可能有 $AB=0$ 。</p><p>矩阵乘法的性质：</p><ol><li>结合律 $$(AB)C=A(BC)$$ </li><li>分配律 $$A(B+C)=AB+AC$$ $$(A+B)C=AC+BC$$ </li><li>$\lambda (AB)=(\lambda A)B=A(\lambda B)$<br>其中 $A,B,C$ 是使上述矩阵乘法有意义的矩阵， $\lambda$ 是数。</li></ol><p>单位矩阵： $n$ 阶方阵<br>$$<br>E_n=\begin{pmatrix}1&amp;0&amp;\cdots &amp;0 \\ 0&amp;1&amp;\cdots &amp;0 \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ 0&amp;0&amp;\cdots &amp;1\end{pmatrix}=\begin{pmatrix}1&amp;&amp;&amp; \\ &amp;1&amp;&amp; \\  &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;1\end{pmatrix}<br>$$<br>称为 $n$ 阶单位矩阵，也记为 $E$ 。容易验证对任意的 $n$ 阶矩阵 $A$ 有<br>$$AE=EA=A$$<br>设 $A$ 是 $n$ 阶矩阵，则乘积 ${A\cdots A}(\text{有限个})$ 有意义。 $k$ 个 $A$ 相乘称为 $A$ 的 $k$ 次幂，记为</p><!-- $$A^{k}=\underbrace{AA\cdots A}\_{k\text{个}}$$ --><p>$$<br>A^k=AA\cdots A(k\text{个})<br>$$<br>并约定 $A^0=E$ 。<br>不难验证</p><p>$$<br>A^kA^l=A^{k+l},(A^k)^l=A^{kl},(k,l\in \mathbb{Z^+})<br>$$<br>成立。由于矩阵乘法不满足交换律，一般的 $(AB)^k\neq A^kB^k$ （ $A,B$ 皆为方阵， $k\geq 2$ ）。</p><p>当 $A$ 为方阵时，称矩阵<br>$$<br>f(A)=a_0A^m+a_1A^{m-1}+\cdots+a_{m-1}A+a_mE<br>$$<br>为矩阵 $A$ 的多项式，也称 $f(A)$ 是普通多项式<br>$$<br>f(\lambda)=a_0\lambda^m+a_1\lambda^{m-1}+\cdots+a_{m-1}\lambda+a_m<br>$$<br>当 $\lambda =A$ 的值，设 $\varphi(\lambda),\psi(\lambda)$ 是两个多项式，令<br>$$<br>f(\lambda)=\varphi(\lambda)+\psi(\lambda),g(\lambda)=\varphi(\lambda)\psi(\lambda)<br>$$<br>由矩阵的运算法则有<br>$$<br>f(A)=\varphi(A)+\psi(A),g(A)=\varphi(A)\psi(A)<br>$$<br>特别是由 $\varphi(\lambda)\psi(\lambda)=\psi(\lambda)\varphi(\lambda)$ 推出 $\varphi(A)\psi(A)=\psi(A)\varphi(A)$ 。</p><p>定理：若 $A$ 与 $B$ 为 $n$ 阶矩阵，则 $|AB|=|A||B|$ 。</p><p>由该定理可知 $|AB|=|BA|$ 。</p><h3 id="逆矩阵与矩阵的初等变换"><a href="#逆矩阵与矩阵的初等变换" class="headerlink" title="逆矩阵与矩阵的初等变换"></a>逆矩阵与矩阵的初等变换</h3><h4 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h4><p>逆矩阵：设 $A$ 是一个 $n$ 阶矩阵。若存在 $n$ 阶矩阵 $B$ 使得<br>$$<br>AB=BA=E<br>$$<br>成立，则称 $A$ 是可逆矩阵， $B$ 是 $A$ 的逆矩阵。</p><p>定理：若 $A$ 是可逆矩阵，则它的逆矩阵是唯一的。</p><p>定理：矩阵 $A=(a_{ij})_{n\times n}$ 可逆的充分必要条件是 $|A|\neq 0$ 。</p><p>伴随矩阵：用 $A$ 中各元 $a_{ij}$ 的代数余子式为元构成矩阵<br>$$<br>A^{\star}=\begin{pmatrix}A_{11}&amp;A_{21}&amp;\cdots &amp;A_{n1} \\ A_{12}&amp;A_{22}&amp;\cdots &amp;A_{n2} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots  \\ A_{1n}&amp;A_{2n}&amp;\cdots &amp;A_{nn} \end{pmatrix}<br>$$</p><p>$A^{\star}$ 称为 $n$ 阶矩阵 $A$ 的伴随矩阵。</p><p>有 $A^{-1}=\frac{1}{|A|}A^{\star}$ 。<br> $n$ 阶矩阵 $A$ 可逆的充要条件是 $|A|\neq 0$ ，且当 $A$ 可逆时 $A$ 的逆矩阵<br>$$<br>A^{-1}=\frac{1}{|A|}A^{\star}=|A|^{-1}A^{\star}<br>$$<br>可逆矩阵又称非奇异矩阵，非退化矩阵或满秩矩阵。</p><p>推论：设 $A,B$ 为 $n$ 阶矩阵，若 $AB=E$ （或 $BA=E$ ）成立，则 $B=A^{-1}$ 。</p><p>定理：若 $A$ 与 $B$ 为 $n$ 阶可逆矩阵在，则 $AB$ 也为 $n$ 阶可逆矩阵，而且 $(AB)^{-1}=B^{-1}A^{-1}$ 。</p><p>推论：若 $A_1,A_2,\cdots ,A_m$ 皆为 $n$ 阶可逆矩阵，则乘积 $A_1A_2\cdots A_m$ 也是一个 $n$ 阶可逆矩阵且</p><p>定理：设 $A$ 是 $n$ 阶可逆矩阵，那么对任意的 $B=B_{n\times m}$ （或 $B=B_{m\times n}$ ），矩阵方程<br>$$<br>AX=B(\text{或}XA=B)<br>$$<br>有唯一解 $X$ 。</p><p>克拉默法则： $n$ 元线性方程组<br>$$<br>\begin{cases} a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1, \\ a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2,\\ \cdots \\ a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n=b_n \end{cases}<br>$$<br>当其系数矩阵 $A$ 的行列式 $D=|A|=\mathrm{det}(a_{ij})\neq 0$ 时，存在唯一解<br>$$<br>x_j=\dfrac{D_j}{D}(j=1,2,\cdots,n)<br>$$<br>其中 $D_j$ 表示把系数矩阵 $A$ 的第 $j$ 列换成常数项列后的矩阵的行列式。</p><h4 id="矩阵的初等变换"><a href="#矩阵的初等变换" class="headerlink" title="矩阵的初等变换"></a>矩阵的初等变换</h4><p>初等变换：对矩阵的行（列）施行下列三种变换都称为矩阵的初等行（列）变换，这三种变换是</p><ol><li>互换矩阵两行（列）的位置</li><li>用非零常数 $\lambda $ 乘矩阵的某行（列）</li><li>将矩阵某行（列）的 $\gamma$ 倍加到矩阵的另一行（列）上。</li></ol><p>矩阵的初等行变换和初等列变换统称为矩阵的初等变换。</p><p>初等矩阵：对 $n$ 阶单位矩阵 $E$ 分别施行一次上述三种初等变换之一后所得的矩阵称为初等矩阵。</p><ol><li>互换 $E$ 的 $i,j$ 两行（两列）所得的初等矩阵 $E_{ij}$</li><li>用 $\lambda(\lambda\neq 0)$ 乘 $E$ 的第 $i$ 行（列）所得的初等矩阵 $E_{ii}(\lambda)$</li><li>将 $E$ 的 $j$ 行（ $i$ 列）的 $\gamma$ 倍加到 $i$ 行（ $j$ 列）上去 $(i\neq j)$ 所得的初等矩阵 $E_{ij}(\gamma)$</li></ol><p>显然，三种初等矩阵都是可逆矩阵。</p><p>引理：对矩阵 $A=(a_{ij})_{m\times n}$ 施行某一初等行（列）变换，其结果等于对 $A$ 左（右）乘一个相应的 $n$ 阶（ $m$ 阶）初等矩阵。</p><p>初等矩阵的逆矩阵分别为<br>$$<br>(E_{ij})^{-1}=E_{ij}<br>$$<br>$$<br>(E_{ii}(\lambda))^{-1}=E_{ii}(\dfrac{1}{\lambda})(\lambda\neq 0)<br>$$<br>$$<br>(E_{ij}(\gamma))^{-1}=E_{ij}(-\gamma)<br>$$</p><p>定理：可逆矩阵必可表示为若干个初等矩阵的乘积。</p><p>初等行变换求矩阵的逆：<br>$$<br>(A,E)\rightarrow (E,A^{-1})<br>$$</p><p>初等列变换求矩阵的逆：<br>$$<br>\begin{pmatrix}A \\ E\end{pmatrix}\rightarrow \begin{pmatrix}E \\ A^{-1} \end{pmatrix}<br>$$</p><h3 id="转置矩阵与一些重要的方阵"><a href="#转置矩阵与一些重要的方阵" class="headerlink" title="转置矩阵与一些重要的方阵"></a>转置矩阵与一些重要的方阵</h3><h4 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h4><p>转置矩阵：设 $A$ 是一个 $m\times n$ 矩阵，若将 $A$ 的行顺次改成列，所得到的 $n\times m$ 矩阵称为 $A$ 的转置矩阵，记作 $A^T$ 。</p><p>转置矩阵满足下面的运算规律：</p><ol><li>$(A^T)^T=A$ 。</li><li>$(A\pm B)^T=A^T\pm B^T$ 。</li><li>$(\lambda A)^T=\lambda A^T(\lambda \text{为数})$ 。</li><li>$(AB)^T=B^TA^T$ 。</li><li>若 $A$ 是可逆矩阵，则 $(A^T)^{-1}=(A^{-1})^T$ 。</li></ol><h4 id="几个重要方阵"><a href="#几个重要方阵" class="headerlink" title="几个重要方阵"></a>几个重要方阵</h4><p>对称矩阵：若实矩阵 $A$ 满足条件 $A^T=A$ ，则 $A$ 称为对称矩阵。<br>一个 $n$ 阶矩阵 $A=(a_{ij})$ 是对称矩阵的充要条件是<br>$$<br>(a_{ij})=(a_{ji})(i,j=1,2,\cdots ,n)<br>$$<br>反称矩阵：若矩阵 $A$ 满足条件 $A^T=-A$ ，则 $A$ 称为反称矩阵。</p><p>一个 $n$ 阶矩阵是反称矩阵的充要条件是它的元满足条件<br>$$<br>a_{ij}=\begin{cases} -a_{ji},i\neq j \\ 0,i=j \end{cases}<br>$$<br>即主对角线上的元全为零，主对角线两侧对称的元反号。</p><p>奇数阶反称矩阵的行列式必为零。</p><p>对角矩阵：形为<br>$$<br>A=\begin{pmatrix}d_1&amp;&amp;&amp; \\ &amp;d_2&amp;&amp; \\ &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;d_{n}\end{pmatrix}<br>$$<br>的 $n$ 阶矩阵（主对角线以外的元全为零）称为对角矩阵。</p><p>对角矩阵有以下性质：</p><ol><li><p>若 $A$ 与 $B$ 均为 $n$ 阶对角矩阵，则 $A+B$ ， $\lambda A$ （ $\lambda$ 为实数）， $AB$ 皆为对角矩阵，且<br>$$<br>AB=\begin{pmatrix}a_1&amp;&amp;&amp; \\ &amp;a_2&amp;&amp; \\ &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;a_{n}\end{pmatrix}\begin{pmatrix}b_1&amp;&amp;&amp; \\ &amp;b_2&amp;&amp; \\ &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;b_{n}\end{pmatrix}=BA<br>$$<br>即两个对角矩阵相乘是可交换的。</p></li><li><p>对角矩阵可逆的充要条件是它的主对角线上的元全不为零，且逆矩阵 $A^{-1}$ 也是对角矩阵。 $A^{-1}$ 的主对角线的元恰为 $A$ 中对应元的倒数，即<br>$$<br>A^{-1}=\begin{pmatrix}a_1&amp;&amp;&amp; \\ &amp;a_2&amp;&amp; \\ &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;a_{n}\end{pmatrix}^{-1}=\begin{pmatrix}a_1^{-1}&amp;&amp;&amp; \\ &amp;a_2^{-1}&amp;&amp; \\ &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;a_{n}^{-1}\end{pmatrix}<br>$$<br>正交矩阵：若 $n$ 阶实矩阵 $A$ 满足 $A^TA=E$ ，则 $A$ 称为正交矩阵。</p></li><li><p> $n$ 阶矩阵 $A$ 为正交矩阵的充分必要条件为 $A^T=A^{-1}$ 。</p></li><li><p> $n$ 阶矩阵 $A$ 是正交矩阵的充分必要条件是下列两组等式</p></li></ol><p>$$<br>\sum_{k=1}^n{a_{ik}a_{jk}}=\begin{cases} 1,i=j \\ 0,i\neq j \end{cases},(i,j=1,2,\cdots,n)<br>$$</p><p>$$<br>\sum_{k=1}^n{a_{ki}a_{kj}}=\begin{cases} 1,i=j \\ 0,i\neq j \end{cases},(i,j=1,2,\cdots,n)<br>$$<br>中至少有一组成立。也就是说，正交矩阵每一行（列）  个元的平方和为1，两个不同行（列）对应元乘积之和等于零。</p><ol><li> $A$ 为正交矩阵，则 $A^T=A^{-1}$ 也是正交矩阵。</li><li> $A$ 为正交矩阵，则 $A$ 的行列式必为+1或-1，即 $|A|=\pm 1$ 。</li><li>若 $A$ 与 $B$ 均为 $n$ 阶正交矩阵，则乘积 $AB(BA)$ 也是正交矩阵。</li></ol><p>共轭矩阵：设 $n$ 阶矩阵 $A=(a_{ij})$ 的元 $a_{ij}$ 都是复数，则矩阵 $\overline{A}=(\overline{a}_{ij})$ 称为 $A$ 的共轭矩阵。</p><p>埃尔米特矩阵：若矩阵 $A$ 满足 $A^T=\overline{A}$ ，则 $A$ 称为埃尔米特矩阵。</p><p>酉矩阵：若 $n$ 阶矩阵 $A$ 满足条件 $A=\overline{A^{-1}}$ ，则 $A$ 称为酉矩阵。</p><h3 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h3><h4 id="分块矩阵-1"><a href="#分块矩阵-1" class="headerlink" title="分块矩阵"></a>分块矩阵</h4><p>分块矩阵：一般的，对于任意一个 $m\times n$ 矩阵 $A$ ，可以用若干条水平直线和竖直线按某种需要把 $A$ 划分成若干个行数与列数较少的矩阵，这种矩阵称为 $A$ 的子阵或子块，被划分了的矩阵 $A$ 称为分块矩阵。</p><h4 id="分块矩阵的运算"><a href="#分块矩阵的运算" class="headerlink" title="分块矩阵的运算"></a>分块矩阵的运算</h4><p>分块矩阵的加法：设 $A$ 与 $B$ 是两个同型矩阵，按照相同方式分块后相加，得到和矩阵。</p><p>分块矩阵的数乘：数乘分块矩阵等于数乘分块矩阵的每个子块所得矩阵。</p><p>分块矩阵的转置：每个子块行列交换后再将每个子块转置。</p><p>分块矩阵的乘法</p><p>准对角矩阵：形为<br>$$<br>\begin{pmatrix}A_1&amp;&amp;&amp; \\ &amp;A_2&amp;&amp; \\ &amp;&amp;\ddots &amp; \\ &amp;&amp;&amp;A_s\end{pmatrix}<br>$$<br>的 $n$ 阶矩阵 $A$ 称为准对角矩阵。</p><p>性质：</p><ol><li>两个同型的准对角矩阵的乘积还是准对角矩阵。</li><li>准对角矩阵 $A$ 可逆的充分必要条件是 $A_1,\cdots,A_s$ 均可逆矩阵，且为同一型的准对角矩阵。</li></ol><h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><h3 id="向量组和矩阵的秩"><a href="#向量组和矩阵的秩" class="headerlink" title="向量组和矩阵的秩"></a>向量组和矩阵的秩</h3><p>线性相关：设 $\alpha_1,\cdots,\alpha_s$ 是一组向量，若其中至少有一个向量可经组中其余 $s-1$ 个向量线性表出，则称 $\alpha_1,\cdots,\alpha_s$ 是线性相关的向量组。这时也称这 $s$ 个向量线性相关，否则就称该向量组是线性无关的向量组。这时也说这 $s$ 个向量线性无关。</p><p>定理：向量组 $\alpha_1,\cdots,\alpha_n$ 线性相关的充要条件是，至少存在一组不全为零的 $s$ 个数 $\lambda_1,\cdots \lambda_s$ ，使得等式<br>$$<br>\sum_{j=1}^s\lambda_j\alpha_j=\lambda_1\alpha_1+\cdots +\lambda_s\alpha_s<br>$$<br>成立。<br>推论：向量组 $\alpha_1,\cdots,\alpha_s$ 线性无关的充要条件是，仅当所有的 $\lambda_1,\cdots \lambda_s$ 都等于零时，该式成立。</p><p>定理： $n$ 阶行列式<br>$$<br>|A|=\mathrm{det}(a_{ij})=0<br>$$<br>的充分必要条件是，它的 $n$ 个行（列）向量线性相关。</p><p>推论： $n$ 阶行列式 $|A|\neq 0$ 的充要条件是， $|A|$ 的 $n$ 个行（列）向量线性无关。</p><p>推论：任何 $n+1$ 个 $n$ 维向量必线性相关。</p><p>极大线性无关组：若向量组的一个子组线性无关，但将向量组中任何一个向量添到这个线性无关子组中去，得到的都是线性相关的子组，则称该线性无关子组为向量组的极大线性无关组。</p><p>定理：对于一个给定的向量组，它的一切极大线性无关组所含向量的个数相同。</p><h4 id="向量组的秩"><a href="#向量组的秩" class="headerlink" title="向量组的秩"></a>向量组的秩</h4><h4 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h4><h3 id="线性方程组的解法"><a href="#线性方程组的解法" class="headerlink" title="线性方程组的解法"></a>线性方程组的解法</h3><h4 id="非齐次线性方程组的解法"><a href="#非齐次线性方程组的解法" class="headerlink" title="非齐次线性方程组的解法"></a>非齐次线性方程组的解法</h4><h4 id="齐次线性方程组的解法"><a href="#齐次线性方程组的解法" class="headerlink" title="齐次线性方程组的解法"></a>齐次线性方程组的解法</h4><h3 id="线性方程组的解的结构"><a href="#线性方程组的解的结构" class="headerlink" title="线性方程组的解的结构"></a>线性方程组的解的结构</h3><h4 id="齐次线性方程组的基础解系"><a href="#齐次线性方程组的基础解系" class="headerlink" title="齐次线性方程组的基础解系"></a>齐次线性方程组的基础解系</h4><h4 id="非齐次线性方程组解的结构"><a href="#非齐次线性方程组解的结构" class="headerlink" title="非齐次线性方程组解的结构"></a>非齐次线性方程组解的结构</h4><h2 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h2><h3 id="线性空间的概念"><a href="#线性空间的概念" class="headerlink" title="线性空间的概念"></a>线性空间的概念</h3><h4 id="线性空间的定义与例子"><a href="#线性空间的定义与例子" class="headerlink" title="线性空间的定义与例子"></a>线性空间的定义与例子</h4><h4 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h4><h3 id="n-维线性空间"><a href="#n-维线性空间" class="headerlink" title="$n$ 维线性空间"></a>$n$ 维线性空间</h3><h4 id="n-维线性空间的定义"><a href="#n-维线性空间的定义" class="headerlink" title="$n$ 维线性空间的定义"></a>$n$ 维线性空间的定义</h4><h4 id="基变换与坐标变换"><a href="#基变换与坐标变换" class="headerlink" title="基变换与坐标变换"></a>基变换与坐标变换</h4><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><h3 id="线性变换的定义"><a href="#线性变换的定义" class="headerlink" title="线性变换的定义"></a>线性变换的定义</h3><h3 id="维线性空间-中线性变换的矩阵"><a href="#维线性空间-中线性变换的矩阵" class="headerlink" title="$$ 维线性空间  中线性变换的矩阵"></a>$$ 维线性空间  中线性变换的矩阵</h3><h3 id="矩阵的对角化"><a href="#矩阵的对角化" class="headerlink" title="矩阵的对角化"></a>矩阵的对角化</h3><h2 id="欧几里得空间"><a href="#欧几里得空间" class="headerlink" title="欧几里得空间"></a>欧几里得空间</h2><h2 id="n-元实二次型"><a href="#n-元实二次型" class="headerlink" title="$n$ 元实二次型"></a>$n$ 元实二次型</h2>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高等代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复变函数与积分变换</title>
    <link href="/archives/e9faf39c.html"/>
    <url>/archives/e9faf39c.html</url>
    
    <content type="html"><![CDATA[<p>这门课虽然不在我的必修课里，但是许多课程，比如数字信号处理，都要用到里面的知识，这篇文章的更新速度也会偏慢。</p><span id="more"></span><h1 id="复变函数与积分变换"><a href="#复变函数与积分变换" class="headerlink" title="复变函数与积分变换"></a>复变函数与积分变换</h1><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><h3 id="复数的定义及其四则运算"><a href="#复数的定义及其四则运算" class="headerlink" title="复数的定义及其四则运算"></a>复数的定义及其四则运算</h3><p>复数：对实数 $x,y$ ，形如 $x+\mathrm{i} y$ 的数称为复数。两个复数 $x_1+\mathrm{i}y_1$ 和 $x_2+\mathrm{i}y_2$ 称为相等的，当且仅当 $x_1=x_2$ 且 $y_1=y_2$ 。由全体复数构成的集合记为 $\mathbb{C}$ 。</p><p>实部与虚部：对于复数 $x+\mathrm{i}y,(x,y\in \mathbb{R})$ ，称 $x$ 为 $z$ 的实部，记作 $\mathrm{Re} {z}$ ，称 $y$ 为 $z$ 的虚部，记作 $\mathrm{Im} {z}$ 。特别的，若 $x=0$ 且 $y\neq 0$ ，则将 $z$ 记为 $\mathrm{i}y$ ，称为纯虚数。</p><p>复数的四则运算：加减乘除</p><p>略</p><h3 id="复数的几何表示"><a href="#复数的几何表示" class="headerlink" title="复数的几何表示"></a>复数的几何表示</h3><p>模与幅角：复数 $z=x+\mathrm{i}y$ 的模规定为复数 $z$ 作为向量的欧氏长度 $|z|=\sqrt{x^2+y^2}$ ，非零复数 $z$ 的幅角规定为 $z$ 作为向量与 $x$ 轴正方向的夹角，记为 $\mathrm{Arg} z$ 。</p><p>若以 $r$ 和 $\theta$ 分别记一个非零复数的模和幅角，则 $(r,\theta)$ 为 $z$ 的极坐标，对一切非零复数 $z$ ，有<br>$$<br>z=r(\cos \theta+\mathrm{i}\sin \theta)<br>$$<br>这一表达式称为复数 $z$ 的三角形式。</p><p>显然幅角不唯一，如果 $\theta$ 是复数 $z$ 的幅角，则 $\theta +2\pi $ 也是 $z$ 的幅角，其中取值在 $(-\pi,\pi ]$ 上的幅角称为复数 $z$ 的幅角主值，记为 $\mathrm{arg}z$ 。</p><p>三角不等式： $|z_1| - |z_2| \leq |z_1+z_2| \leq |z_1|+|z_2|$ 。</p><p>棣莫弗公式：若 $z=r(\cos \theta+\mathrm{i}\sin \theta)$ 为非零复数 $z$ 的三角形式， $n$ 为整数，则 $z^n=r^n((\cos (n\theta)+\mathrm{i}\sin (n\theta))$ 。特别，对非零复数 $z$ 和整数 $n$ ，有<br>$$<br>|z^n|={|z|}^n,\mathrm{Arg}z^n=n \mathrm{arg}z +2k \pi,k\in \mathbb{Z}<br>$$<br>开方：任意一个非零复数 $z$ 恰有 $n$ 个互不相同的复 $n$ 次方根。若 $z=r(\cos \theta+\mathrm{i}\sin \theta)$ 为非零复数 $z$ 的三角形式，则 $z$ 的 $n$ 个互不相同的复 $n$ 次方根为<br>$$<br>\sqrt[n]{r}(\cos \dfrac{\theta+2k\pi }{n}+\mathrm{i}\sin \dfrac{\theta+2k\pi}{n})<br>$$<br>这里 $k=0,1,\cdots,n-1$ 。</p><p>复数的指数形式：欧拉记 $e^{\mathrm{i}\theta}=\cos \theta+\mathrm{\sin\theta}$ 。于是 $z=r(\cos \theta+\mathrm{i}\sin \theta)$ 可简记为 $z=re^{\mathrm{i}\theta}$ ，称为复数的指数形式。</p><p>利用欧拉公式可以得到： $1+e^{\mathrm{i}\pi}=0$ 。</p><p>共轭复数：对于复数 $z=x+\mathrm{i}y$ ，称 $\overline{z}=x-\mathrm{i}y$ 为 $z$ 的共轭复数。</p><p>球极投影：考虑三维欧式空间 $\mathbb{R}^3$ 以及其上的单位球面<br>$$<br>S^2=\{ (x_1,x_2,x_3)|x_1^2+x_2^2+x_3^2=1 \}<br>$$<br>并将赤道平面与复平面等同，其中 $x_1$ 轴取为实轴， $x_2$ 轴取为虚轴，记北极点 $(0,0,1)$ 为 $N$ ，任取复平面上一点 $A$ ，连接北极点 $N$ 与 $A$ 的直线，易见该直线与除去北极点的单位球面 $S^2-\{ N \}$ 交于唯一一点，记为 $P(A)$ ，于是<br>$$<br>P:C\rightarrow S^2-\{ N \}<br>$$<br>可看作复平面除去北极点的单位球面 $S^2-\{ N \}$ 上的一个映射，该映射就称为球极投影，此时的单位球面称为黎曼球面，显然，该映射是可逆的。</p><p>不难算出映射 $P$ 的表达式为</p><p>于是 $P$ 连续可微，且满足<br>$$<br>\lim_{|z|\to \infty}P(z)=N<br>$$<br>由此规定 $N=P(\infty)$ ， $\infty$ 称为无穷远点。并记 $\overline{C}=C\cup \{ \infty \}$ ，称为扩充复平面，从而 $P$ 是一个从扩充复平面到黎曼球面的双射，而且在无穷远点也是连续的。</p><h3 id="平面点集的复数表示"><a href="#平面点集的复数表示" class="headerlink" title="平面点集的复数表示"></a>平面点集的复数表示</h3><p>平面上的曲线是光滑的，如果该曲线可以写为参数方程<br>$$<br>\begin{cases}x=x\left( t\right) \\ y=y\left( t\right) \end{cases}<br>$$<br>这里 $\alpha \leq t\leq \beta$ ，且 $x^{\prime}(t)$ ， $y^{\prime}(t)$ 在 $[\alpha,\beta]$ 上连续。</p><p>曲线如果由有限段光滑曲线依次首尾连接而成的，这样的曲线称为逐段光滑曲线。</p><p>Jordan曲线定理：平面上的任何一条简单闭曲线 $C$ 必将平面分成两个不相交的区域，其中一个为有界，称为曲线 $C$ 的内部区域，另一个为无界的，称为曲线的外部区域，这两个区域均以 $C$ 为其边界。</p><p>设 $D$ 为一个区域，如果 $D$ 内任一条简单闭曲线的内部区域完全包含于 $D$ 内，则称 $D$ 是单连通的，否则称为多连通的。</p><h3 id="复变函数"><a href="#复变函数" class="headerlink" title="复变函数"></a>复变函数</h3><p>复变函数是定义在复数集的子集上，取值也在复数集上的函数。</p><p>复变函数的分量表示：给定复变函数 $w=f(z)$ ，记 $z=x+\mathrm{i}y$ ，再记 $u=\mathrm{Re}f(z),v=\mathrm{Im}f(z)$ ，显然 $u,v$ 由 $z$ 或者 $(x,y)$ 唯一确定，从而 $u,v$ 可以看做关于 $x,y$ 的二元实函数，于是，一元复变函数作为映射等同于以两个实二元函数为分量的从平面区域到平面的映射，即<br>$$<br>z\rightarrow f(z)\Leftrightarrow \begin{pmatrix}<br>x \\ y<br>\end{pmatrix} \rightarrow \begin{pmatrix}<br>u(x,y) \\ v(x,y)<br>\end{pmatrix}<br>$$</p><h2 id="解析函数的微积分"><a href="#解析函数的微积分" class="headerlink" title="解析函数的微积分"></a>解析函数的微积分</h2><h3 id="复变函数的极限和连续性"><a href="#复变函数的极限和连续性" class="headerlink" title="复变函数的极限和连续性"></a>复变函数的极限和连续性</h3><p>复数列的极限：设复数列 $\{ z_n \}$ ，若存在常数 $z_0$ 对任何 $\epsilon&gt;0$ ，存在 $N&gt;0$ ，使当 $n&gt;N$ 时，有 $|z_n-z_0|&lt;\epsilon$ ，则称该复数列 $\{ z_n \}$ 收敛或存在极限， $z_0$ 称为其极限，记为 $\lim_{n\to \infty}z_n=z_0$ 。</p><p>记 $z_n=x_n+\mathrm{i}y,(n=0,1,2,\cdots)$ ，有<br>$$<br>\max \{ |x_n-x_0|,|y_n-y_0| \} \leq |z_n-z_0| \leq |x_n-x_0|+|y_n-y_0|<br>$$<br>定理：复数列 $\{ z_n \}$ 收敛，当且仅当实数列 $\{ x_n=\mathrm{Re}z_n \}$ 和 $\{ y_n=\mathrm{Im}z_n \}$ 同时收敛，且 $\lim_{n\to \infty}z_n=\lim_{n\to \infty}x_n+\mathrm{i} \lim_{n\to \infty}y_n$ 。</p><p>定理：设 $\{ z_n \}$ 和 $\{ w_n \}$ 为复数列，且极限 $\lim_{n\to \infty}z_n$ 和 $\lim_{n\to \infty}w_n$ 都存在，则</p><ol><li>数列 $\{ z_n \}$ 和 $\{ w_n \}$ 均为有界的。</li><li> $$\lim_{n\to \infty}(z_n+w_n)=\lim_{n\to \infty}z_n \pm \lim_{n\to \infty}w_n$$</li><li>对一切复常数 $c$ ， $\lim_{n\to \infty}cz_n=c\lim_{n\to \infty}z_n$ 。</li><li> $$\lim_{n\to \infty}(z_nw_n)=(\lim_{n\to \infty}z_n)\cdot (\lim_{n\to \infty}w_n)$$</li><li>若 $\lim_{n\to \infty}w_n\neq 0$ ，则存在 $N&gt;0$ ，使得对一切 $n&gt;N$ ，有 $w_n\neq 0$ ，进一步， $\lim_{n\to \infty}w_n^{-1}=(\lim_{n\to \infty}w_n)^{-1}$ 。</li></ol><p>复变函数的极限：设 $f(z)$ 为定义在 $S$ 上的函数， $z_0$ 为 $\overline{S}$ 上的一点，且不是 $S$ 的孤立点。若存在复常数 $A$ ，使对任何 $\epsilon &gt;0$ ，都存在 $\delta &gt;0$ ，使得对 $S$ 上一切满足 $0&lt;|z-z_0|&lt;\delta$ 的点 $z$ ，都有 $|f(z)-A| &lt; \epsilon$ ，则称 $A$ 为 $f(z)$ 当 $z$ 趋向于 $z_0$ 时的极限，记作 $\lim_{z\to z_0}f(z)=A$ 。</p><p>记 $A=a+\mathrm{i}b$ ， $f(z)=u(x,y)+\mathrm{i}v(x,y)$ ，有<br>$$<br>\max \{ |u(x,y)-a|,|v(x,y)-b| \} \leq |f(z)-A| \leq |u(x,y)-a|+|v(x,y)-b|<br>$$<br>定理：函数 $f(z)$ 在点 $z_0$ 的极限 $\lim_{z\to z_0}f(z)$ 存在，当且仅当实部 $u(x,y)$ 和虚部 $v(x,y)$ 作为二元实函数，极限 $\lim_{x\to x_0 \\ y\to y_0}u(x,y)$ 与 $\lim_{x\to x_0 \ y\to y_0}v(x,y)$ 同时存在，且<br>$$<br>\lim_{z\to z_0}f(z)=\lim_{x\to x_0 \\ y\to y_0}u(x,y)+\mathrm{i}\lim_{x\to x_0 \ y\to y_0}v(x,y)<br>$$<br>定义：设 $f(z)$ 为定义在 $\{ |z| &gt; R \}$ 内的函数， $R$ 为给定的非负数。若存在复常数 $A$ ，使对任何 $\epsilon &gt;0$ 都存在 $G&gt;R$ ，使得对一切满足 $|z| &gt; G$ 的点 $z$ ，都有 $|f(z)-A| &lt; \epsilon$ ，则称 $z$ 为 $f(z)$ 当 $z$ 趋向于无穷远点时的极限，记作 $\lim_{z\to \infty}f(z)=A$ 。</p><p>定义：设 $f(z)$ 为定义在 $S$ 上的函数， $z_0$ 为 $\overline{S}$ 上的一点，若对任何 $M&gt;0$ ，都存在 $\delta&gt;0$ ，使得对 $S$ 内一切满足 $0&lt;|z-z_0|$ 的点 $z$ ，都有 $|f(z)|&gt;M$ ，则称当 $z$ 趋向于 $z_0$ 时 $f(z)$ 趋于无穷远点，记作 $\lim_{z\to z_0}f(z)=\infty$ 。</p><p>定义：设 $f(z)$ 为定义在 $\{ |z|&gt;R \}$ 上的函数， $R$ 为给定的非负数，若对任何 $M&gt;0$ ，都存在 $G&gt;R$ ，使得对一切满足 $|z|&gt;G$ 的点 $z$ ，都有 $|f(z)&gt;M|$ ，则称当 $z$ 趋向于 $\infty$ 时 $f(z)$ 趋于无穷远点，记作 $\lim_{z\to \infty}f(z)=\infty$ 。</p><p>定理：设 $f$ 和 $g$ 都是定义在 $S$ 上的函数，且极限 $\lim_{z\to z_0}f(z)$ 和 $\lim_{z\to z_0}g(z)$ 都存在有限，则以下结论成立：</p><ol><li>存在 $\delta&gt;0$ ，使得 $f(z)$ 和 $g(z)$ 在 \{ 0&lt;|z-z_0|&lt; \delta \} 内均为有界的。</li><li> $$\lim_{z\to z_0}(f(z)\pm g(z))=\lim_{z\to z_0}f(z)\pm \lim_{z\to z_0}g(z)$$ 。</li><li>对一切复常数 $c$ ， $\lim_{z\to z_0}cf(z)=c\lim_{z\to z_0}f(z)$ 。</li><li> $$\lim_{z\to z_0}(f(z) g(z))=\lim_{z\to z_0}f(z)\cdot \lim_{z\to z_0}g(z)$$ 。</li><li>若 $\lim_{z\to z_0}g(z)\neq 0$ ，则存在 $\delta &gt;0$ ，使对 $S$ 上一切满足 $0&lt;|z-z_0|&lt;\delta$ 的 $z$ ，有 $g(z)\neq 0$ ，进一步， $\lim_{z\to z_0}[g(z)]^{-1}=(\lim_{z\to z_0}g(z))^{-1}$ 。</li></ol><p>连续函数：设 $f(z)$ 为定义在 $S$ 上的函数， $z_0$ 为 $S$ 上的一点，若 $\lim_{z\to z_0}f(z)=f(z_0)$ ，则称 $f(z)$ 在点 $z_0$ 连续。若 $f(z)$ 在 $S$ 上的每一点都连续，则称 $f(z)$ 为 $S$ 上的连续函数。</p><p>定理：函数 $f(z)$ 在点 $z_0$ 连续的充分必要条件是 $f(z)$ 的实部 $u(x,y)$ 和虚部 $v(x,y)$ 作为二元实函数在点 $(x_0,y_0)$ 都连续。</p><p>定理：设函数 $f$ 和 $g$ 都在 $S$ 上连续， $c$ 为复常数，则</p><ol><li>函数 $f(z)+g(z)$ ， $cf(z)$ 以及 $f(z)g(z)$ 都在 $S$ 上连续。</li><li>若 $g(z)\neq 0$ ，则函数 $\dfrac{f(z)}{g(z)}$ 在 $S$ 上连续。</li></ol><p>定理：设 $f$ 和 $g$ 分别为定义在 $S$ 与 $S^{\prime}$ 上的连续函数，且 $f$ 的值域包含于 $S^{\prime}$ ，则 $g(f(z))$ 为 $S$ 上的连续函数。</p><p>定理：定义在有界闭区域 $\overline{D}$ 上的连续函数 $f(z)$ ，其模 $|f(z)|$ 必在 $\overline{D}$ 上达到最大值与最小值。</p><h3 id="复变函数的导数和解析函数"><a href="#复变函数的导数和解析函数" class="headerlink" title="复变函数的导数和解析函数"></a>复变函数的导数和解析函数</h3><p>复变函数的导数：设 $f(z)$ 为定义在区域 $D$ 内的函数， $z_0$ 为 $D$ 内一点，如果极限</p><p>$$<br>\lim_{\Delta z\to 0}\dfrac{f(z_0+\Delta z)-f(z_0)}{\Delta z}<br>$$</p><p>存在有限，则称 $f(z)$ 在 $z_0$ 点可导。该极限称为 $f(z)$ 在 $z_0$ 点的导数，记作 $f^{\prime}(z_0)$ 或 $\frac{\mathrm{d}f}{\mathrm{d}z}(z_0)$ ，即</p><p>$$<br>\dfrac{\mathrm{d}f}{\mathrm{d}z}(z_0)=f^{\prime}(z_0)=\lim_{\Delta z\to 0}\dfrac{f(z_0+\Delta z)-f(z_0)}{\Delta z}<br>$$</p><p>如果 $f(z)$ 在区域 $D$ 内每点都可导，就称 $f(z)$ 在区域 $D$ 内可导。此时， $f^{\prime}(z)$ 可看作定义在 $D$ 内的函数，称为 $f(z)$ 的导函数，简称导数。</p><p>复变函数的导数与实函数有许多类似的性质：</p><ul><li>线性性</li><li>积的求导法则</li><li>商的求导法则</li><li>复合函数求导链式法则</li><li>可导必然连续</li></ul><p>反函数求导法则：设 $w=f(z)$ 与 $z=\varphi(w)$ 是两个互为反函数的单值可导函数，则 $f^{\prime}(z)\neq 0$ ， $\varphi^{\prime}(w)\neq 0$ ，且 $f^{\prime}(z)=\frac{1}{\varphi^{\prime}(f(z))}$ 。</p><p>在一元实函数的反函数求导法则中，导数不为0是定理的条件，而在复变函数中，导数不为0是结论。这一点的证明需要用到 Rouche 定理。</p><p>柯西-黎曼方程：设 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 为定义在区域 $D$ 的函数，且在 $z=x+\mathrm{i}y\in D$ 处处可导，则<br>$$<br>f^{\prime}(z)=\lim_{\Delta z\to 0}\dfrac{f(z+\Delta z)-f(z)}{\Delta z}<br>$$<br>记 $\Delta z = \Delta x+\mathrm{i}\Delta y$ ，则<br>$$<br>f(z+\Delta z)-f(z)=[u(x+\Delta x,y+\Delta y)-u(x,y)]+\mathrm{i}[v(x+\Delta x,y+\Delta y)-v(x,y)]=\Delta u+\mathrm{i}\Delta v<br>$$<br>分别沿平行于实轴和虚轴的方向取极限，可得<br>$$<br>f^{\prime}(z)=\lim_{\Delta x\to 0}\dfrac{\Delta u+\mathrm{i}\Delta v}{\Delta x}=u_x+\mathrm{i}v_x \\ f^{\prime}(z)=\lim_{\Delta y\to 0}\dfrac{\Delta u+\mathrm{i}\Delta v}{\Delta y}=u_y+\mathrm{i}v_y<br>$$<br>比较实部与虚部有<br>$$<br>\frac{\partial u}{\partial x}=\frac{\partial v}{\partial y},\frac{\partial u}{\partial y}=-\frac{\partial v}{\partial x}<br>$$<br>这就是著名的柯西-黎曼方程。</p><p>定理：设函数 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 定义在区域 $D$ 内， $f(z)$ 在 $z=x+\mathrm{i}y\in D$ 处可导的必要条件是其实部函数 $u(x,y)$ 和虚部函数 $v(x,y)$ 在点 $(x,y)$ 偏导数存在，并且在该点满足柯西-黎曼方程。进一步，当 $f(z)$ 在 $z=z+\mathrm{i}y$ 处可导时，其导数可表达为 $f^{\prime}(z)=u_x+\mathrm{i}v_x=v_y-\mathrm{i}u_y$ 。</p><p>定理：设函数 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 定义在区域 $D$ 内， $f(z)$ 在 $z=x+\mathrm{i}y\in D$ 处可导的充分必要条件是 $u(x,y)$ 和 $v(x,y)$ 在点 $(x,y)$ 可微，并且在该点满足柯西-黎曼方程。</p><p>解析函数：如果 $f(z)$ 在点 $z_0$ 的某个邻域处处可导，则称 $f(z)$ 在点 $z_0$ 解析。若 $f(z)$ 在复平面的子集 $S$ 上的每一点都解析，则称 $f(z)$ 在 $S$ 上解析，或称 $f(z)$ 为 $S$ 上的解析函数。</p><p>定理：设函数 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 在区域 $D$ 内有定义， $f(z)$ 在 $z_0\in D$ 处解析的充分必要条件是存在点 $z_0$ 的一个邻域，使得 $u(x,y)$ 和 $v(x,y)$ 在该邻域内处处可微并且满足柯西-黎曼方程。</p><p>定理：设函数 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ ，则 $f(z)$ 在区域 $D$ 内解析的充分必要条件是 $u(x,y)$ 和 $v(x,y)$ 在区域 $D$ 内处处可微，并且柯西-黎曼方程在区域 $D$ 内处处成立。</p><p>定理：设 $f(z)$ 在区域 $D$ 内解析且 $f^{\prime}(z)\equiv 0$ ，则 $f(z)$ 为常值函数。</p><p>推论：设 $f(z)$ 在区域 $D$ 内解析且 $|f(z)|$ 为常数，则 $f(z)$ 是区域 $D$ 内的常值函数。</p><h3 id="初等函数"><a href="#初等函数" class="headerlink" title="初等函数"></a>初等函数</h3><p>指数函数：对复数 $z=x+\mathrm{i}y$ ，规定指数函数为<br>$$<br>\mathrm{e}^z=\mathrm{e}^{x+\mathrm{i}y}=\mathrm{e}^x \mathrm{e}^{\mathrm{i}y}=\mathrm{e}^x(\cos y+ \mathrm{i} \sin y)<br>$$</p><!-- 根据该定义，有1.   ；  。2.   ，特别  。3.   （  为整数）4.   在复平面解析。5. 当  为实数时，  。6. 当  为纯虚数时，  。7.   。特别的，对正整数  ，有  。8.   （  为整数），即  是周期函数，周期为  。 --><p>单叶性区域：设 $f(z)$ 为定义在区域 $D$ 内的函数，如果对于任何 $z_1,z_2 \in D$ ，只要 $z_1 \neq z_2$ ，就有 $f(z_1)\neq f(z_2)$ ，则称 $f(z)$ 在 $D$ 内是单叶的，区域 $D$ 称为 $f(z)$ 的单叶性区域。</p><p>对数函数：对一切非零复数 $z$ ，定义对数函数为<br>$$<br>\mathrm{Ln}z=\ln{|z|}+\mathrm{i}\mathrm{Arg}z<br>$$<br>对于一个给定的整数 $k$ ，记<br>$$<br>\mathrm{Ln}_k z=\ln{|z|}+\mathrm{i}(\mathrm{arg}z+2k\pi)<br>$$<br>称为对数函数 $\mathrm{Ln}z$ 的一个单值分支函数。</p><p>定义：称 $\mathrm{Ln}_0 z$ 为对数函数的主值，记为 $\ln{z}$ ，即<br>$$<br>\ln{z}=\ln{|z|}+\mathrm{i} \mathrm{arg}z<br>$$<br>定理：对数函数的每个单值分支函数在复平面去掉原点和负实轴的区域内解析。</p><p>三角函数：记<br>$$<br>\sin z = \dfrac{\mathrm{e}^{\mathrm{i}z}-\mathrm{e}^{-\mathrm{i}z}}{2},\cos z = \dfrac{\mathrm{e}^{\mathrm{i}z}+\mathrm{e}^{-\mathrm{i}z}}{2}<br>$$<br>分别称为复变量 $z$ 的正弦函数和余弦函数。</p><p>注意：在复平面上，正弦函数和余弦函数无界，正弦函数和余弦函数解析，零点个数没有增加。</p><p>双曲函数：对一切的复数 $z$ ，规定<br>$$<br>\sin z = \dfrac{\mathrm{e}^{z}-\mathrm{e}^{-z}}{2},\cos z = \dfrac{\mathrm{e}^{z}+\mathrm{e}^{-z}}{2}<br>$$<br>分别称为 $z$ 的双曲正弦和双曲余弦。</p><p>幂函数：设 $a$ 为复常数，定义 $w=z^a=\mathrm{e}^{a\mathrm{Ln}z},z\neq 0$ ，称为 $z$ 的幂函数，当对数 $\mathrm{Ln} z$ 取主值 $\ln{z}$ 时，函数 $\mathrm{e}^{a\mathrm{Ln}z}$ 称为幂函数的主值。</p><p>反三角函数</p><h3 id="复变函数的积分"><a href="#复变函数的积分" class="headerlink" title="复变函数的积分"></a>复变函数的积分</h3><p>复积分：设 $C$ 是区域 $D$ 内一条有向的简单曲线，起点为 $A$ ，终点为 $B$ ， $f(z)$ 为定义在 $D$ 内的函数。在 $C$ 上从 $A$ 向 $B$ 依次插入分点<br>$$<br>A=z_0,z_1,\cdots,z_n=B<br>$$<br>将该曲线 $C$ 分割成 $n$ 个小弧段。在每一个从 $z_{k-1}$ 到 $z_k$ 的小弧段上任取一点 $\zeta_k$ ，记 $\Delta z_k=z_k-z_{k-1}$ ，以及 $\lambda=\max \{ |\Delta z_k| : k=1,2,\cdots,n\}$ 为所有小线段的最大长度，如果极限<br>$$<br>\lim_{\lambda\to 0}\sum_{k=1}^{n}f(\zeta_k)\Delta z_k<br>$$<br>不依赖与曲线 $C$ 的分割方法和点 $\zeta_k$ 的取法而存在，则该极限为 $f(z)$ 沿曲线 $C$ 的复积分。</p><p>复积分的运算性质：</p><ol><li>线性性</li><li>逐段积分</li><li>记 $C^{-}$ 为 $C$ 的反向曲线，则 $\int_{C^{-}}f(z)\mathrm{d}z=\int_{C}f(z)\mathrm{d}z$ 。</li></ol><p>定理：对任意 $z_0 \in C$ ，以及正数 $\rho$ 和整数 $n$ ，有<br>$$<br>\int_{|z-z_0|=\rho}\dfrac{\mathrm{d}z}{(z-z_0)^n}=\begin{cases} 2\pi \mathrm{i} ,n=1 \\ 0,n\neq 1\end{cases}<br>$$<br>这里积分曲线 $|z-z_0|=\rho$ 取逆时针方向。</p><p>复变函数关于弧长的积分：设 $C$ 是一段光滑曲线，函数 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 在 $C$ 上连续，定义函数 $f(z)$ 关于弧长的积分为<br>$$<br>\int_{C}f(z)\mathrm{d}s=\int_{C}u(x,y)\mathrm{d}x+\mathrm{i}\int_{C}v(x,y)\mathrm{d}s<br>$$<br>若曲线 $C$ 的参数方程为 $z(t)=x(t)+\mathrm{i}y(t),(\alpha\leq t \leq \beta)$ ，由于 $\mathrm{d}z=\mathrm{d}x+\mathrm{i}\mathrm{d}y$ ，所以弧长微分<br>$$<br>\mathrm{d}s=\sqrt{(\mathrm{d}x)^2+(\mathrm{d}y)^2}=|\mathrm{d}z|=|z^{\prime}(t)|\mathrm{d}t<br>$$<br>则有<br>$$<br>\int_{C}f(z)\mathrm{d}s=\int_{\alpha}^{\beta}f(z(t))|z^{\prime}(t)|\mathrm{d}t<br>$$</p><p>定理：设 $C$ 为简单有向曲线， $f(z)$ 在包含 $C$ 的一个区域内连续，则<br>$$<br>|\int_C f(z)\mathrm{d}z|\leq \int_C|f(z)|\mathrm{d}s<br>$$<br>特别的，记 $C$ 的长度为 $\mathrm{Length}(C)$ ，且在 $C$ 上有 $|f(z)|\leq M$ ，则<br>$$<br>|\int_C f(z)\mathrm{d}z|\leq M\cdot \mathrm{Length}(C)<br>$$<br>复积分与路径无关：设 $f(z)$ 为定义在区域 $D$ 内的函数，所谓积分 $f(z)$ 在 $D$ 内与路径无关是指对 $D$ 内任意给定的两点 $z_1,z_2$ ，以及 $D$ 内任意两条连接起点为 $z_1$ 终点为 $z_2$ 的简单曲线 $C$ ，都有 $\int_C f(z)\mathrm{d}z=0$ 。</p><p>定理：设 $f(z)$ 为定义在区域 $D$ 内的连续函数，则以下事实等价：</p><ol><li> $f(z)$ 在 $D$ 内与路径无关。</li><li>对 $D$ 内任一简单闭曲线 $C$ ，都有 $\int_C f(z)\mathrm{d}z=0$ 。</li><li>在 $D$ 内存在函数 $F(z)$ ，使得 $f(z)=F^{\prime}(z)$ （此时称 $F(z)$ 为 $f(z)$ 在区域 $D$ 内的一个函数）。</li></ol><p>复积分的牛顿莱布尼兹公式：设 $f(z)$ 为定义在区域 $D$ 内连续函数，且在 $D$ 内存在原函数 $F(z)$ ，则对任何 $z_1,z_2\in D$ 以及连接 $z_1,z_2$ 的曲线 $C$ ，有<br>$$<br>\int_C f(z)\mathrm{d}z=F(z_2)-F(z_1)<br>$$</p><h3 id="柯西积分公式"><a href="#柯西积分公式" class="headerlink" title="柯西积分公式"></a>柯西积分公式</h3><p>格林公式：设 $D$ 为有界区域， $P(x,y),Q(x,y)$ 在 $D$ 上有一阶连续偏导数，则<br>$$<br>\int_{\partial D} P\mathrm{d}x+Q\mathrm{d}y=\iint_{D}(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\mathrm{d}x\mathrm{d}y)<br>$$<br>这里 $\partial D$ 为区域 $D$ 的正向边界。</p><p>柯西积分定理：设 $D$ 为有界区域， $f(z)$ 在 $D$ 内解析，在 $\overline{D}$ 上连续，则有 $\int_{\partial D}f(z)\mathrm{d}z=0$ ，这里 $\partial D$ 为区域 $D$ 的正向边界。</p><p>定理：设 $D$ 为单连通区域， $f(z)$ 在 $D$ 内解析， $C$ 为 $D$ 内任一条简单闭曲线，则有 $\int_{C}f(z)\mathrm{d}z=0$ ，从而 $f(z)$ 在 $D$ 内积分与路径无关。</p><p>解析函数的平均值性质：设 $f(z)$ 在区域 $D$ 内解析，则对一切 $z_0\in D$ ，以及满足 $\{ |z-z_0|\leq R \}\subset D$ 的正数 $R$ ，有<br>$$<br>f(z_0)=\dfrac{1}{2\pi}\int_{0}^{2\pi} f(z_0+R\mathrm{e}^{\mathrm{i}\theta})\mathrm{d}\theta<br>$$<br>柯西积分公式：设 $D$ 为有界区域，若 $f(z)$ 在 $D$ 内解析，在 $\overline{D}$ 上连续，则对一切 $z_0\in D$ ，<br>$$<br>f(z_0)=\dfrac{1}{2\pi \mathrm{i}}\int_{\partial D}\dfrac{f(z)}{z-z_0}\mathrm{d}z<br>$$<br>这里 $\partial D$ 为区域 $D$ 的正向边界。</p><p>定理：设函数 $f(z),g(z)$ 都在有界区域 $D$ 内解析，在 $\overline{D}$ 上连续，且当 $z\in \partial D$ 时有 $f(z)=g(z)$ 则当 $z\in \overline{D}$ 时， $f(z)=g(z)$ 。</p><p>柯西高阶导数公式：设 $D$ 为有界区域，且 $f(z)$ 在 $D$ 内解析，在 $\overline{D}$ 上连续，则对一切 $z_0\in D$ 和正整数 $n$ ，有<br>$$<br>f^{(n)}(z_0)=\dfrac{n!}{2\pi \mathrm{i}}\int_{\partial D}\dfrac{f(z)}{(z-z_0)^{n+1}}\mathrm{d}z<br>$$<br>这里 $\partial D$ 为区域 $D$ 的正向边界。</p><p>定理：设 $f(z)$ 为定义在区域 $D$ 内的连续函数，且 $f(z)$ 在 $D$ 内积分与路径无关，则 $f(z)$ 在 $D$ 内解析。</p><p>定理：有界整函数必定是常值函数。</p><p>皮卡小定理：非常值函数，其值域只有两种类型，全体复数或全体复数除去一个值。</p><p>代数学基本定理：任何复系数多项式方程在复平面上至少有一个根。</p><h3 id="调和函数"><a href="#调和函数" class="headerlink" title="调和函数"></a>调和函数</h3><p>调和函数：设二元实函数 $H(x,y)$ 在平面区域 $D$ 内有二阶连续的偏导数，且满足拉普拉斯方程<br>$$<br>\frac{\partial^2 H}{\partial x^2}+\frac{\partial^2 H}{\partial y^2}=\Delta H=0<br>$$<br>则称其为 $D$ 内的调和函数。</p><p>共轭调和函数：若二元实函数 $u(x,y),v(x,y)$ 都是区域 $D$ 内的调和函数，且满足柯西黎曼方程，则称 $v(x,y)$ 为 $u(x,y)$ 的共轭调和函数。</p><p>注意：共轭调和函数不具有自反性。</p><p>定理：复变函数 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 在区域 $D$ 内解析的充分必要条件是 $u(x,y)$ 与 $v(x,y)$ 都在区域 $D$ 内调和，且 $v(x,y)$ 为 $u(x,y)$ 的共轭调和函数。</p><p>定理：对一切定义在单连通区域 $D$ 的调和函数 $u(x,y)$ ，由下式定义的函数<br>$$<br>v(x,y)=\int_{(x_0,y_0)}^{(x,y)}-u_y\mathrm{d}x+u_x\mathrm{d}y+c<br>$$<br>恰为 $u$ 在 $D$ 内的共轭调和函数，这里 $c$ 为任意实数。</p><p>定理：设 $f(z)=u(x,y)+\mathrm{i}v(x,y)$ 在区域 $D$ 内解析，取值在区域 $D_1$ 中， $h(x,y)$ 在区域 $D_1$ 内调和，则 $h(u(x,y),v(x,y))$ 在区域 $D$ 内调和。</p><p>调和函数的平均值性质：设 $u(x,y)$ 在区域 $D$ 内调和，则对一切 $z_0=x_0+\mathrm{i}y_0\in D$ ，以及满足 ${\overline{B_r}} {(z_0)}\subset D$ 的正数 $r$ ，有</p><p>$$<br>u( x_0 , y_0 )=\dfrac{1}{2\pi}\int_{0}^{2\pi}u( x_0+r\cos \theta, y_0+r\sin \theta)\mathrm{d}\theta<br>$$</p><p>极值原理：设 $u(x,y)$ 在有界区域 $D$ 内调和，在 $\overline{D}$ 上连续，若 $u$ 在 $\overline{D}$ 上的最大值或最小值在 $\overline{D}$ 的内部取到，则 $u$ 必定为 $\overline{D}$ 上的常数函数。</p><p>引理：若非负函数 $f(x)$ 在 $[a,b]$ 上连续，且 $\int_{a}^{b}f(x)\mathrm{d}x=0$ ，则 $f(x)$ 在 $[a,b]$ 上恒为零。</p><p>最大模原理：设 $f(z)$ 在有界区域 $D$ 内解析，在 $\overline{D}$ 上连续，若 $|f(z)|$ 在 $\overline{D}$ 上的最大值在 $D$ 的内部取到，则 $|f(z)|$ 必定为常数函数。</p><p>定理：在平面上调和并且有上界（或下界）的调和函数，必定是常值函数。</p><h2 id="解析函数的级数理论与留数定理"><a href="#解析函数的级数理论与留数定理" class="headerlink" title="解析函数的级数理论与留数定理"></a>解析函数的级数理论与留数定理</h2><h3 id="复数列的级数与幂级数"><a href="#复数列的级数与幂级数" class="headerlink" title="复数列的级数与幂级数"></a>复数列的级数与幂级数</h3><p>级数：给定复数列 $\{ z_k \}$ ，其前 $k$ 项之和记为<br>$$<br>S_k=z_1+z_2+\cdots+z_k<br>$$<br>数列 $\{ S_k \}$ 的极限记为 $\sum_{k=1}^{\infty}z_k$ ，称为级数， $S_k$ 称为级数 $\sum_{k=1}^{\infty}z_k$ 的部分和。若部分和数列 $\{ S_k \}$ 收敛，则称级数 $\sum_{k=1}^{\infty}z_k$ 收敛，否则称级数 $\sum_{k=1}^{\infty}z_k$ 发散。</p><p>定理：复数项级数 $\sum_{k=1}^{\infty}z_k$ 收敛的充分必要条件是实数项级数 $\sum_{k=1}^{\infty}x_k$ 和 $\sum_{k=1}^{\infty}y_k$ 同时收敛。</p><p>定理：若 $\sum_{k=1}^{\infty}z_k$ 收敛，则 $\lim_{k\to \infty}z_k=0$ ，即 $\lim_{k\to \infty}|z_k|=0$ 。</p><p>绝对收敛：对复数项级数 $\sum_{k=1}^{\infty}z_k$ ，若正项级数 $\sum_{k=1}^{\infty}|z_k|$ 收敛，则称 $\sum_{k=1}^{\infty}z_k$ 绝对收敛。</p><p>定理：若 $\sum_{k=1}^{\infty}z_k$ 绝对收敛，则 $\sum_{k=1}^{\infty}z_k$ 收敛。</p><p>和函数：设 $\{ f_k(z) \}$ 为定义在区域 $D$ 内的函数序列，则对每个固定的 $z$ ，当 $\sum_{k=0}^{\infty}f_k(z)$ 作为数项级数收敛时，记其和为 $S(z)$ ，于是 $S(z)$ 为定义在使得级数 $\sum_{k=0}^{\infty}f_k(z)$ 收敛的点集上的函数，称为函数项级数 $\sum_{k=0}^{\infty}f_k(z)$ 的和函数。</p><p>幂级数：函数项级数 $\sum_{k=0}^{\infty}c_k(z-z_0)^k$ 称为以 $z_0$ 为中心的幂级数，这里 $c_k$ 为复常数，并约定 $(z-z_0)^0=1$ 。</p><p>定理：如果 $\sum_{k=0}^{\infty}c_kz^k$ 在非零点 $z_0$ 收敛，则在区域 $\{ |z| &lt; |z_0| \}$ 内，幂级数 $\sum_{k=0}^{\infty}c_kz^k$ 绝对收敛，如果 $\sum_{k=0}^{\infty}c_kz^k$ 在 $z_0$ 点发散，则在区域 $\{ |z| &gt; |z_0| \}$ 内，幂级数 $\sum_{k=0}^{\infty}c_kz^k$ 发散。</p><p>考虑实数集合<br>$$<br>S=\{ r|\text{当}|z-z_0|&lt;r\text{时，级数} \sum_{k=0}^{\infty}c_k(z-z_0)^k \}<br>$$<br>可以证明 $S$ 只可能是三种情形：空集，有界半闭区间 $(0,b]$ 和 $(0,+\infty)$ 。</p><p>记 $R$ 为 $S$ 的最小上界，称为幂级数 $\sum_{k=0}^{\infty}c_k(z-z_0)^k$ 的收敛半径，约定 $S$ 为空集时，$R=0$ ,$S$ 为 $(0,+\infty)$ 时， $R=+\infty$ 。此时 $\{ |z-z_0|&lt;R \}$ 称为幂级数 $\sum_{k=0}^{\infty}c_k(z-z_0)^k$ 的收敛圆盘。</p><p>定理：幂级数 $\sum_{k=0}^{\infty}c_k(z-z_0)^k$ 在收敛圆盘的内部处处绝对收敛，在收敛圆盘的外部处处发散。</p><p>定理：对幂级数 $\sum_{k=0}^{\infty}c_kz^k$ ，若极限 $\lambda =\lim_{k\to \infty}|c_k|^{\frac{1}{k}}$ 存在，则该幂级数的收敛半径 $$R\frac{1}{\lambda} 。</p><p>定理：对幂级数 $\sum_{k=0}^{\infty}c_kz^k$ ，若极限 $\lambda =\lim_{k\to \infty}|\frac{c_{k+1}}{c_k}|$ 存在，则该幂级数的收敛半径 $R=\frac{1}{\lambda}$ 。</p><p>定理：设幂级数 $\sum_{k=0}^{\infty}c_k(z-z_0)^k$ 的收敛半径为 $R$ ，则其和函数 $S(z)$ 满足：</p><ol><li>在收敛圆盘内科逐项求极限，即 $\lim_{z\to z_1}S(z)=\sum_{k=0}^{\infty}c_k(z-z_0)^k$ ，其中 $|z_1-z_0|&lt;R$ 。</li><li>在手链圆盘镊科逐项求导，且逐项求导不改变收敛半径，特别， $S(z)$ 在收敛圆盘内部解析， $S^{\prime}(z)=\sum_{k=1}^{\infty}\dfrac{c_k}{k+1}(z-z_0)^{k+1}$ 。</li><li>在收敛圆盘内可逐项积分，且逐项积分不改变收敛半径，即<br>$$<br>\int_{z_0}^{z}S(\zeta)\mathrm{d}\zeta = \sum_{k=0}^{\infty}\dfrac{c_k}{k+1}(z-z_0)^{k+1}<br>$$<br>其中 $|z-z_0|&lt;R$ 。</li></ol><h3 id="泰勒级数"><a href="#泰勒级数" class="headerlink" title="泰勒级数"></a>泰勒级数</h3><h2 id="积分变换"><a href="#积分变换" class="headerlink" title="积分变换"></a>积分变换</h2><h2 id="共形映照"><a href="#共形映照" class="headerlink" title="共形映照"></a>共形映照</h2>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>复分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实变函数</title>
    <link href="/archives/3178e13f.html"/>
    <url>/archives/3178e13f.html</url>
    
    <content type="html"><![CDATA[<p>这是门要学十遍的课。写这篇笔记纯属兴趣使然，不过由于作业越来越多，估计很长时间无法更新笔记，而且我感觉参考的实变函数的教材十分难懂（可能只是因为我比较菜），回头看看有没有相对简单易懂的教材。</p><span id="more"></span><h1 id="实变函数"><a href="#实变函数" class="headerlink" title="实变函数"></a>实变函数</h1><h2 id="集合与关系"><a href="#集合与关系" class="headerlink" title="集合与关系"></a>集合与关系</h2><h3 id="集合及其运算"><a href="#集合及其运算" class="headerlink" title="集合及其运算"></a>集合及其运算</h3><p><strong>集合的表示</strong>：枚举法，描述法。</p><p><strong>广义实数系</strong>：以 $\overline{\mathbb{R}}$ 表示全体实数与正无穷大 $+ \infty$ 和负无穷大 $- \infty$ 所成之集，称为广义实数系。</p><p><strong>子集</strong>：以 $A\subset B$ 或 $B\supset A$ 表示集合 $A$ 是集合 $B$ 的真子集。以 $A\subseteq B$ 或 $B\supseteq A$ 表示 $A$ 是 $B$ 的子集或 $B$ 是 $A$ 的超集。</p><p>$$\mathbb{N}\subset \mathbb{Z}\subset \mathbb{Q}\subset \mathbb{R}\subset \mathbb{C}\subset \mathbb{H}$$</p><p><strong>子集的性质</strong>：</p><ul><li>空集是任何集合的子集： $\emptyset \subseteq A$ 。</li><li>自反性：当 $A$ 是集合时， $A\subseteq A$ 。</li><li>反称性：当 $A\subseteq B$ 且 $B\subseteq A$ 时， $A=B$ 。</li><li>传递性：当 $A\subseteq B$ 且 $B\subseteq C$ 时， $A\subseteq C$ 。</li><li>上定向性：当 $A$ 和 $B$ 是集合时，有集合 $C$ 使 $A\subseteq C$ 且 $B\subseteq C$ 。</li><li>下定向性：当 $A$ 和 $B$ 是集合时，有集合 $C$ 使 $A\supseteq C$ 且 $B\supseteq C$ 。</li></ul><p><strong>有限个集合的运算</strong>：<br>集合的交，并，差运算。</p><p><strong>对称差</strong>： $A\Delta B=(A-B)\cup (B-A)$ 。</p><p><strong>运算律</strong>：</p><ul><li>零元律：<br>$$A\cup \emptyset = A-\emptyset =A,A\cap \emptyset =\emptyset$$</li><li>交换律：<br>$$A\cup B=B\cup A,A\cap B=B\cap A,A\Delta B=B\Delta A$$</li><li>结合律：<br>$$(A\cup B)\cup C=A\cup (B\cup C)$$<br>$$(A\cap B)\cap C=A\cap (B\cap C)$$</li><li>分配律：<br>$$(A-B)\cap C=(A\cap C)-(B\cap C)$$</li><li>单调性：<br>$$(A_1\subseteq A_2)\wedge (B_2\subseteq B_1)\Rightarrow (A_1-B_1)\subseteq (A_2-B_2)$$</li></ul><p><strong>集族的运算</strong>：</p><ul><li><p>幂等律：<br>$$\bigcup _{i\in I}A=A$$<br>其中 $I\neq \emptyset$ 且每个指标 $i\in I$ 对应的集合都是 $A$ 。</p><p>$$\bigcap _{i\in I}A=A$$</p><p>其中 $I\neq \emptyset$ 且每个指标 $i\in I$ 对应的集合都是 $A$ 。</p></li><li><p>对偶律：<br>$$B-\bigcup _{i\in I}A_i=\bigcap _{i\in I}(B-A_i)$$</p><p>$$B-\bigcap _{i\in I}A_i=\bigcup _{i\in I}(B-A_i)$$</p></li><li><p>结合律：<br>$$\bigcup _{i\in I}A_i=\bigcup _{j\in J}\bigcup _{i\in I_j}A_i,I=\bigcup _{j\in J}I_j$$</p><p>$$\bigcap _{i\in I}A_i=\bigcap _{j\in J}\bigcap _{i\in I_j}A_i,I=\bigcup _{j\in J}I_j$$</p></li><li><p>分配律：<br>$$B\cap (\bigcup \{ A_i | i\in I \})=\bigcup \{ B\cap A_i | i\in I \}$$</p><p>$$B\cap (\bigcap \{ A_i | i\in I \})=\bigcap \{ B\cap A_i | i\in I \}$$</p></li><li><p>单调性：<br>设 $A_i\subseteq B_i (i\in I)$ ，则</p><p>$$\bigcup _{i\in I}A_i\subseteq \bigcup _{i\in I} B_i,\bigcap _{i\in I}A_i\subseteq \bigcap _{i\in I} B_i$$</p></li></ul><p><strong>补集</strong>：固定一个集合 $X$ 。当 $A\subseteq X$ 时，称 $X-A$ 为 $A$ 在 $X$ 中的补集或余集。这可以用 $A^c$ 表示。</p><p><strong>无交并</strong>：$\bigsqcup$</p><p><strong>集列的极限</strong>：</p><p>上限集：对于一般的集列 $\{ A_n \}$ ,称 ${\bigcap _{n=1}^{\infty}\bigcup _{k=n}^{\infty}A_k}$ 为 $\{ A_n \}$ 的上限集，记为 ${\lim _{n\rightarrow \infty} \sup A_n}$ 或 ${\lim _{n\rightarrow \infty} \sup A_n}$ 。</p><p>下限集：对于一般的集列 $\{ A_n \}$ ,称 ${\bigcup _{n=1}^{\infty}\bigcap _{k=n}^{\infty}A_k}$ 为 $\{ A_n \}$ 的下限集，记为 ${\lim _{n\rightarrow \infty} \inf A_n}$ 或 ${\lim _{n\rightarrow \infty} \inf A_n}$ 。</p><p><strong>笛卡尔积</strong>：分量依次在 $X_1,X_2,\cdots ,X_n$ 中的 $n$ 元组所成的集合<br>$$<br>\prod_{i=1}^n X_i=X_1\times X_2\times \cdots \times X_n:=\{ (x_1,\cdots,x_n)| x_n\in X_n \}<br>$$<br>称为笛卡尔积。其中两个 $n$ 元组 $(x_1,\cdots,x_n)$ 与 $(y_1,\cdots,y_n)$ 相等是指他们的对应分量相等： $x_1=y_1, \cdots ,x_n=y_n $ 。</p><p><strong>截口</strong>：子集 $G\subseteq X\times Y$ 在 $a\in X$ 处截口 $G_a$ 和在 $b\in Y$ 处截口 $G^b$ 为<br>$$<br>G_a=\{ y\in Y|(a,y)\in G \}<br>$$</p><p>$$<br>G^b=\{ x\in X|(x,b)\in G \}<br>$$</p><ol><li>截口保持单调性</li><li>截口保持并运算</li><li>截口保持较运算</li><li>截口保持差运算</li><li>若 $G\cap H=\emptyset$ ，则 $G_x\cap H_x =\emptyset$ 且 $G^y\cap H^y =\emptyset$ 。</li></ol><p><strong>像集与原像集</strong>：设 $f:X\rightarrow Y$ 是映射，对于 $B\subseteq Y$ ，令 $f^{-1}(B)=\{ x\in X|f(x)\in B \}$ ，这称为 $B$ 在映射 $f$ 下的原像。对于 $A\subseteq X$ ，令 $f(A)=\{ f(x)|x\in A \}$ （即 $f(A)=\{ f(x)|x\in A \}$ ），这称为 $A$ 在映射 $f$ 下的像。记 $ran f=f(X)$ ，这是 $f$ 的值域。</p><ol><li>像集保持单调性</li><li>像集保持并运算</li><li>原像保持单调性</li><li>原像保持并运算</li><li>原像保持交运算</li><li>原像保持差运算</li><li>原像保持补运算</li><li>$f(A)\subseteq B$ 当且仅当 $A\subseteq f^{-1}(B)$ 。</li></ol><p><strong>单射</strong>：设 $f$ 是由集合 $A$ 到集合 $B$ 的映射，如果所有 $x,y\in A$ ，且 $x\neq y$ ，都有 $f(x)\neq f(y)$ ，则称 $f$ 为由 $A$ 到 $B$ 的单射。</p><p><strong>满射</strong>：设 $f$ 是由集合 $A$ 到集合 $B$ 的映射，如果所有 $y\in B$  ，都有 $\exists x\in A,f(x)=y$ ，则称 $f$ 为由 $A$ 到 $B$ 的满射。</p><p><strong>双射</strong>：设 $f$ 是由集合 $A$ 到集合 $B$ 的映射，如果 $f$ 是单射又是满射，那么就是双射，也叫一一对应。</p><h3 id="三类常用关系"><a href="#三类常用关系" class="headerlink" title="三类常用关系"></a>三类常用关系</h3><p><strong>关系</strong>：一些元素对 $(x,y)$ 构成的集合 $R$ 称为一个关系，此时记 $xRy$ 。</p><p>现在设 $R$ 是集合 $X$ 上的一个关系，这即 $R\subseteq X\times X$ 。</p><ol><li>自反性：$x\in X$，时 $xRx$ 。</li><li>对称性： $xRy$ 时， $yRx$ 。</li><li>传递性： $xRy$ 且 $yRz$ 时， $xRz$ 。</li><li>反称性： $xRy$ 且 $yRx$ 时， $x=y$ 。</li></ol><p><strong>等价关系与划分</strong>：集合 $X$ 上具有自反性、对称性和传递性的关系 $R$ 称为等价关系。当 $xRy$ 时，记 $x\sim y$ ，称 $x$ 与 $y$ 等价。</p><ol><li>与 $x$ 等价的元素全体 $[x]$ 称为 $x$ 所在的等价类： $[x]=\{ y\in X|y\sim x \}$ 等价元素所在的等价类相同。不等价元素所在的等价类不相交。</li><li>等价关系 $\sim $ 的商集 $\{ [x]|x\in X \}$ 记为 $X/\sim $ 或 $\tilde{X}$ 。令 $\pi (x)=[x]$ ，得自然射影或商映射 $\pi :X\rightarrow \tilde{X}$ 使 $\pi (x_1)=\pi (x_2)$ 当且仅当 $x_1\sim x_2$ 。</li><li>每个映射 $f:X\rightarrow Y$ 都按照等值方式诱导 $X$ 上一个等价关系 $\sim $ 使 $x_1\sim x_2$ 表示 $f(x_1)=f(x_2)$ 。</li><li>等价关系 $\sim $ 确定的互异等价类全体记为 $[x_i]:i\in J$ ，则 $X=\bigcup_{i\in J}[x_i]$ 。<br>一般的，当集类 $\mathcal{D}$ 中成员都非空且相互不交而使 $X=\bigcup \mathcal{D}$ 时，称 $\mathcal{D}$ 是 $X$ 的一个划分。</li><li>集合 $X$ 上的关系 $R$ 是个等价关系当且仅当 $X$ 有唯一的划分 $\{ X_i|i\in I \}$ ，使 $xRy$ 表示 $x$ 与 $y$ 在同一个 $X_i$ 中。此时每个等价类恰好是某个 $X_i$ 。</li></ol><p>设 $\mathcal{D}$ 与 $\mathcal{D}^{\prime}$ 是 $X$ 的划分使 $\mathcal{D}$ 的成员 $A$ 都有划分 $\{ B\in \mathcal{D}^{\prime}|B\subseteq A \}$ ，称 $\mathcal{D}^{\prime}$ 是 $\mathcal{D}$ 的细分并记为 $\mathcal{D}^{\prime} \preceq \mathcal{D}$ 。细分有以下性质：</p><ul><li>自反性： $\mathcal{D}\preceq \mathcal{D}$ 。</li><li>反称性： $\mathcal{D}^{\prime} \preceq \mathcal{D}$ 且 $\mathcal{D} \preceq \mathcal{D}^{\prime}$ 时， $\mathcal{D}^{\prime} = \mathcal{D}$ 。</li><li>传递性： $\mathcal{D} \preceq \mathcal{D}^{\prime}$ 且 $\mathcal{D}^{\prime} \preceq \mathcal{D}^{\prime \prime}$ 时， $\mathcal{D} \preceq \mathcal{D}^{\prime \prime}$ 。</li><li>定向性： $\mathcal{D}$ 与 $\mathcal{D}^{\prime}$ 有细分 $$\mathcal{D}\vee \mathcal{D}^{\prime}:=\{ A\cap B | A\in \mathcal{D},B\in \mathcal{D} \} - \{ \emptyset  \}$$</li></ul><h3 id="对等集合与势"><a href="#对等集合与势" class="headerlink" title="对等集合与势"></a>对等集合与势</h3><p><strong>对等</strong>：称 $X$ 与 $Y$ 是对等集合也称为等势集合是指它们是空集或有双射 $f:X\rightarrow Y$ 。此时，记 $X\sim Y$ 。对等集合具有相同的势。以 $|X|$ 表示 $X$ 的势。</p><ol><li>对等具有自反性： $X\sim X$ 。</li><li>对等具有对称性： $X\sim Y\Rightarrow Y\sim X$ 。</li><li>对等具有传递性： $X\sim Y,Y\sim Z\Rightarrow X\sim Z$ 。</li><li>笛卡尔积保持对等： $X_i\sim Y_i(i\in I)$ 时， $\prod X_i\sim \prod Y_i$ 。</li><li>无交并保持对等： $\bigsqcup X_i\sim \bigsqcup Y_i$ 在诸 $X_i\sim Y_i$ 时成立。</li><li>一般幂集保持对等： $X_1\sim X_2$ 且 $Y_1\sim Y_2$ 时， $Y_1^{X_1}\sim Y_2^{X_2}$ 。这里约定 $Y^X$ 表示 $X$ 至 $Y$ 的映射全体。</li></ol><p>令 $F_0=\emptyset$ 及 $F_n=F_{n-1}\cup \{n\}$ ，直观上它们只有有限个元素。</p><p><strong>可数集</strong>：与某个 $F_n$ 对等的集合 $A$ 称为有限集，它的势用 $n$ 表示，也称 $n$ 为 $A$ 的基数。与自然数对等的集合称为可列集，它的势记为 $\aleph _{0}$ 。有限集与可列集统称为可数集。</p><ol><li>有限集的子集是有限集且有限集不与其真子集对应。</li><li>有限集的像集，两个有限集的并与笛卡尔积都是有限集。</li><li>可列集的子集与像集都是可数集。</li><li>有限个可列集的笛卡尔积与可列个可列集的并是可列集。</li></ol><p><strong>康托-伯恩斯坦定理</strong>：设集合 $X$ 与集合 $Y$ 的一个子集对等且 $Y$ 也与 $X$ 的一个子集对等，则 $X$ 与 $Y$ 对等。</p><p><strong>连续统</strong>：与实数系对等的集合称为连续统。所有长度非零的区间都是连续统。</p><p>集合 $A$ 是无限集当且仅当 $A$ 包含一个可列子集 $S$ 当且仅当 $A$ 与任何可数集之并与 $A$ 对等当且仅当 $A$ 与自身的一个真子集对等。</p><p><strong>势的比较和运算</strong>：集合 $X$ 对于等于集合 $Y$ 的一个子集当且仅当有单射 $f:X\rightarrow Y$ 当且仅当有满射 $g:Y\rightarrow X$ ，此时记 $|X|\leq |Y|$ 。</p><ol><li>自反性： $|X|\leq |X|$ 。</li><li>反称性： $|X|\leq |Y|$ 且 $|Y|\leq |X|$ 时， $|X|=|Y|$ 。</li><li>传递性： $|X|\leq |Y|$ 且 $|Y|\leq |Z|$ 时， $|X|\leq |Z|$ 。</li><li>三歧性：两个势有且只有三种可能性（大于，小于，等于）。</li></ol><p>一般集合 $X$ 的<strong>幂集</strong> $2^{X}$ 的势记为 $2^{|X|}$ 。</p><p><strong>定理</strong>：任何集合 $X$ 满足势的不等式： $|X|&lt;2^{|X|}$ 。</p><p>连续统的势记为 $\aleph$ 并称为连续势，可列集的势记为 $\aleph _{0}$ 。在势的意义下，<br>$$<br>0&lt;1&lt;\cdots&lt;\aleph _{0}&lt;\aleph =2^{\aleph _{0}}<br>$$</p><p><strong>Konig 不等式</strong>：设 $i\in I$ 时 $|A_i|&lt;|B_i|$ ，则 $| \bigcup_{i\in I}A_i |&lt;| \prod_{i\in I}B_i |$ 。</p><p>以 $\alpha$ 和 $\beta$ 分别记 $A$ 和 $B$ 的势。笛卡尔积 $A\times B$ 的势记为 $\alpha \beta$ 。当 $A\cap B=\emptyset$ 时，将 $A\bigsqcup B$ 的势记为 $\alpha+\beta$ 。两个集合之间的映射 $f:A\rightarrow B$ 全体 $B^A$ 的势记为 $\beta ^{\alpha}$ 。</p><ol><li>交换律： $\alpha+\beta=\beta +\alpha$， $\alpha \beta=\beta \alpha$ 。</li><li>零元律： $0+\alpha=\alpha$ ， $0 \alpha=0$ ， $\beta ^{0}=1$， $0^{\gamma}=0(\gamma &gt;0)$ 。</li><li>单位律： $1\alpha =\alpha$，$1^{\alpha} =1$， $\alpha ^1 =\alpha$ 。</li><li>结合律： $(\alpha+\beta)+\gamma=\alpha+(\beta+\gamma)$， $(\alpha\beta)\gamma=\alpha(\beta\gamma)$ 。</li><li>吸收律：如果 $\beta$ 是无限势而 $1\leq \alpha \leq \beta$ ，则 $\alpha+\beta=\alpha\beta=\beta$ 。</li><li>单调性：如果 $\alpha_1\leq \alpha_2$ 且 $\beta_{1}\leq \beta_{2}$ ，则 $\alpha _{1}^{\beta_1}\leq \alpha _{2}^{\beta_2}$ 。</li></ol><p><strong>重要等式</strong>：</p><ol><li>设 $n$ 是正整数，则 $n+\aleph_0=n\aleph_0=\aleph_0^{n}=\aleph_0$ 。</li><li>设 $n$ 是正整数，则 $n\aleph=\aleph_0\aleph=\aleph^{n}=\aleph$ 。</li><li>设整数 $n\geq 2$ ，则 $n^{\aleph} =\aleph_0^{\aleph}=\aleph^{\aleph}=2^{\aleph}$ 。</li><li>设整数 $n\geq 2$ ，则 $n^{\aleph_0}=\aleph_0^{\aleph_0}=\aleph^{\aleph_0}=\aleph$ 。</li></ol><p>以 $\alpha_i$ ， $\beta_{i}$ 和 $\gamma_i$ 分别记 $A_i$ ， $B_i$ 和 $C_i$ 的势，则 $\prod_{i\in I}A_i$ 的势记为 $\prod_{i\in I}\alpha_i$ ，无交并 $\bigsqcup_{i\in I}A_i$ 的势记为 $\sum_{i\in I}\alpha_i$ 。约定 $\sum_{i\in \emptyset}\alpha_i=0$ 且 $\prod_{i\in \emptyset}=1$ 。</p><ol><li>完全次可加性： $|\cup_{i\in I}A_i|\leq \sum_{i\in I}|A_i|$ 。</li><li>结合律： $\sum_{i\in I}\gamma_i=\sum_{j\in J}\sum_{i\in I_j}\gamma_i$ ，其中 $I=\bigsqcup_{j\in J}I_j$ 。</li><li>分配律： $\alpha\sum_{i\in I}\gamma_i=\sum_{i\in I}\alpha\gamma_i$ 。</li><li>分解律： $\sum_{a\in A}\beta =\alpha\beta$ 及 $\prod_{a\in A}\beta =\beta^{\alpha}$ 。</li><li>单调性：<br>$$<br>\forall i\in I:\alpha_i\leq \beta_i\Rightarrow \sum_{i\in I}\alpha_i\leq \sum_{i\in I}\beta_i<br>$$<br>$$<br>\forall i\in I:\alpha_i\leq \beta_i\Rightarrow \prod_{i\in I}\alpha_i\leq \prod_{i\in I}\beta_i<br>$$</li></ol><h3 id="实数与无穷大"><a href="#实数与无穷大" class="headerlink" title="实数与无穷大"></a>实数与无穷大</h3><p><strong>上确界与下确界</strong>：设 $S$ 是偏序集 $X$ 的非空子集， $S$ 的最小上界（若存在）称为 $S$ 的上确界，并记为 $\sup S$ 或 $\sup_{x\in S}x$ 。因此<br>$$<br>\sup S=\min \{ b\in X|\forall x\in S:x\leq b \}<br>$$<br>而 $S$ 的有最大下界（若存在）称为 $S$ 的下确界并记为 $\inf S$ 或 $\inf_{x\in S}x$ ，即<br>$$<br>\inf S=\max \{ a\in X|\forall x\in S:x\geq a \}<br>$$</p><ol><li>对偶律： $\sup (-A)=-\inf A$ 而 $\inf(-A)=-\sup A$ 。</li><li>单调性：如果 $A\subseteq B$ ，则 $\sup A\leq \sup B$ 且 $\inf B\leq \inf A$ 。</li><li>分配律： $\sup (\bigcup_{i\in I}A_i)=\sup_{i\in I}\sup A_i$ 且 $\inf (\bigcup_{i\in I}A_i)=\inf_{i\in I}\inf A_i$ 。</li><li>平移律： $\sup(x+B)=x+\sup B$ 在两边有意义时成立， $\inf(x+B)=x+\inf B$ 在两边有意义时成立。</li><li>分配律： $\sup(A+B)=\sup A+\sup B$ 在两边有意义时成立， $\inf(A+B)=\inf A+\inf B$ 在两边有意义时成立。</li></ol><p><strong>定理</strong>：广义数集 $A$ 在广义实数系中有上确界 $\sup A$ 和下确界 $\inf A$ 。</p><p><strong>上极限与下极限</strong>：广义实数序列 $(x_n)$ 有上极限<br>$$<br>\varlimsup_{n\to \infty}x_n=\inf_{n\geq 1}\sup_{k\geq n}x_k<br>$$<br>也有下极限<br>$$<br>\varliminf_{n\to \infty}x_n=\sup_{n\geq 1}\inf_{k\geq n}x_k<br>$$<br>总有不等式<br>$$<br>\varliminf_{n\to \infty}x_n\leq \varlimsup_{n\to \infty}x_n<br>$$<br>它们相等时记为 $\lim_{n\to \infty}x_n$ 并称为 $(x_n)$ 的极限。</p><ol><li> $\varlimsup (-x_n)=-\varliminf x_n$ 而 $\varliminf (-x_n)=-\varlimsup x_n$ 。</li><li>对于子列 $(k_n)$ ，有 $\varliminf x_n\leq \varliminf x_{k_n}$ 且 $\varlimsup x_{k_n}\leq \varlimsup x_{n}$ 。</li><li>从某项起 $x_n\leq y_n$ ，则 $\varliminf x_n\leq \varliminf y_n$ 且 $\varlimsup x_n\leq \varlimsup y_n$ 。</li><li> $0&lt;\lim x_n&lt;\infty$ 时， $\varlimsup (x_ny_n)=\lim x_n\varlimsup y_n$ 。</li><li> $0&lt;\lim x_n&lt;\infty$ 时， $\varliminf (x_ny_n)=\lim x_n\varliminf y_n$ 。</li><li>在有意义时， $\varlimsup (x_n+y_n)\leq \varlimsup x_n+\varlimsup y_n$ 。</li><li>在有意义时， $\varliminf (x_n+y_n)\geq \varliminf x_n+\varliminf y_n$ 。</li><li>在有意义时，$$\varliminf (x_n+y_n)\leq \varliminf x_n+\varlimsup y_n\leq \varlimsup (x_n+y_n)$$</li></ol><p><strong>柯西收敛原理</strong>：关于实数列 $(x_n)$ 的以下三个条件等价：</p><ol><li><p>$(x_n)$ 是收敛数列：<br>$$<br>\exists x\in \mathbb{R} , \forall \epsilon &gt;0 , \exists m\geq 1,\forall n&gt;m:|x_n-x|&lt;\epsilon<br>$$</p></li><li><p>$(x_n)$ 是基本数列：<br>$$<br>\forall \epsilon &gt;0 , \exists m\leq 1,\forall n,l&gt;m:|x_n-x_l|&lt;\epsilon<br>$$</p></li><li><p> $(x_n)$ 是有界数列并且极限存在。此时 $x=\lim_{n\to \infty}x_n$ 。</p></li></ol><p><strong>单调完备性</strong>：单调广义数列 $(x_n)$ 有极限。在递增情形， $\lim_{n\to \infty}x_n=\sup_{n\geq 1}x_n$ ；在递减情形， $\lim_{n\to \infty}x_n=\inf_{n\geq 1}x_n$ 。</p><p><strong>广义实数列</strong>： $(x_n)$ 的上极限是其子列极限中的最大者，而 $(x_n)$ 的下极限是其子列极限中的最小者。</p><p><strong>定理</strong>：广义实数列都有其收敛子列。</p><p><strong>数值项级数</strong></p><p><strong>级数形式的单调收敛定理</strong>：设 $J$ 是定向集，设 $i\in I$ 时非负函数 $u_i$ 是递增的——当 $k\preceq l$ 时 $u_i(k)\leq u_i(l)$ ，则<br>$$<br>\sup_{j\in J}\sum_{i\in I}u_i(j)=\sum_{i\in I}\sup_{j\in J}u_i(j)<br>$$<br><strong>小数</strong></p><h3 id="Euclid-空间"><a href="#Euclid-空间" class="headerlink" title="Euclid 空间"></a>Euclid 空间</h3><p>Euclid 距离性质：<br>非负对称性： $ |y-x| = |x-y| \geq 0$ ， $ |x-y| =0$ 当且仅当 $x=y$ 。<br>三角不等式： $ |x-z|\leq |x-y|+|y-z|$ 或 $ | | x-z |-| y-z | | \leq | x-y |$ 。</p><p>在 Euclid 空间中，以点 $x$ 为球心以正数 $r$ 为半径，定义</p><p>开球： $O(x,r)=\{ y\in {\mathbb{R}}^n: |y-x|&lt;r \}$ ，<br>闭球： $B(x,r)=\{ y\in {\mathbb{R}}^n: |y-x|\leq r \}$ ，<br>球面： $S(x,r)=\{ y\in {\mathbb{R}}^n: |y-x|=r \}$ 。</p><p>在实直线上，它们分别是开区间 $(x-r,x+r)$ ，闭区间 $[x-r,x+r]$ 与两点集 $\{ x-r,x+r \}$ 。在平面上，它们分别是开圆盘、闭圆盘与圆周。</p><p>Euclid 空间的拓扑：Euclid 空间 ${\mathbb{R}}^n$ 的子集 $U$ 为开集是指任何 $x\in U$ 都拥有个 $r&gt;0$ 使 $O(x,r)\subseteq U$ 。而 ${\mathbb{R}}^n$ 的子集 $F$ 为闭集是指 ${\mathbb{R}}^n-F$ 为开集。任何开覆盖都有有限子覆盖的集合称为紧集。</p><p>可列个开集的交集称为 $G_{\delta}-$ 型集，而可列个闭集的并集称为 $F_{\sigma}-$ 型集。</p><ol><li>空集与 Euclid 空间是开集，空集与 Euclid 空间是闭集。</li><li>任意个开集的并集是开集，任意个闭集的交集是闭集。</li><li>有限个开集的交集是开集，有限个闭集的并集是闭集。</li><li>开集减闭集是开集，闭集减开集是闭集。</li><li> Euclid 空间的开集都是 $G_{\delta}-$ 型集而闭集都是 $F_{\sigma}-$ 型集。</li></ol><p>定理（Heine-Borel）： Euclid 空间的子集为紧集当且仅当它是有界闭集。</p><p>定理（Cantor）：实直线上非空开集 $U$ 可唯一地表示为至多可列个相互不交开区间的并。这些开区间称为 $U$ 的构成区间，它们的端点不在 $U$ 中。</p><p>定理：对于函数 $f:X\rightarrow Y$ ，以下条件等价：</p><ol><li> $f$ 是连续函数——逐点连续的函数。</li><li>对于 ${\mathbb{R}}^m$ 的开集 $V$ ，存在 ${\mathbb{R}}^n$ 的开集 $U$ 使 $f^{-1}(V\cap Y)=U\cap X$ 。</li><li>对于 ${\mathbb{R}}^m$ 的开集 $F$ ，存在 ${\mathbb{R}}^n$ 的开集 $E$ 使 $f^{-1}(F\cap Y)=E\cap X$ 。</li></ol><p>此时， $f$ 将 $X$ 中的紧集映为紧集而 $F_{\sigma}-$ 型集映为 $F_{\sigma}-$ 型集。</p><p>设函数 $g:[a,b]\rightarrow \mathbb{R}$ 的不连续点都是第一类的，命 $\hat{g}(a)=g(a+)$ 与 $\hat{g}(b)=g(b-)$ 。当 $a&lt;x&lt;b$ 时，命 $\hat{g}(x)=\max \{ g(x),g(x-),g(x+) \}$ ，设 $a&lt;x&lt;y&lt;b$ 使 $\hat{g}(x)&lt;\hat{g}(y)$ ，称 $x$ 为 $g$ 的一个右控点。设 $a&lt;y&lt;x&lt;b$ 使 $g(y)&gt;\hat{g}(x)$ ，称 $x$ 为 $g$ 的一个左控点。</p><p>定理（F.Riesz）：不连续点都是第一类的函数 $g:[a,b]\rightarrow\mathbb{R}$ 的右控点全体 $U$ 是开集且其构成区间 $(u,v)$ 都满足不等式 $g(u+)\leq \hat{g}(v)$ 。</p><p>定理（F.Riesz）：不连续点都是第一类的函数 $g:[a,b]\rightarrow\mathbb{R}$ 的左控点全体 $U$ 是开集且其构成区间 $(u,v)$ 都满足不等式 $g(v-)\leq \hat{g}(u)$ 。</p><p>康托集与康托函数：将闭区间 $[0,1]$ 三等分后移去中间的开区间 $(0.1,0.2)$ ，其中小数为三进制的。剩下的两个闭区间 $[0,0.1]$ 与 $[0.2,1]$ 分别三等分后各移去中间的开区间 $(0.01,0.02)$ 和 $(0.21,0.22)$ 。如此下去，这些被移去的开区间作为构成区间并成一个开集 $O$ 。剩下的集 $K$ 称为康托集。等式 $K=[0,1]-O$ 表明 $K$ 是紧集。</p><p>线性组合：以 $\mathbb{K}$ 代表一个数域，设 $X$ 是数域 $\mathbb{K}$ 上线性空间。如果 $x,x_i$ 是 $X$ 中向量而 $a_i$ 是 $\mathbb{K}$ 中数使得<br>$$<br>x=a_1x_1+\cdots +a_nx_n<br>$$<br>称 $x$ 是 $x_1,\cdots ,x_n$ 的线性组合。如果 $x=0$ 必导致 $a_1=\cdots =a_n=0$ ，称 $x_1,\cdots,x_n$ 是线性无关组。</p><ol><li>对于线性组合封闭的子集称为线性子空间。一般非空子集 $S$ 的线性包<br>$$<br>\mathrm{span} S=\bigcup_{n=1}^{\infty} \{\sum_{i=1}^{n}a_ix_i|a_i\in\mathbb{K};x_i\in S \}<br>$$<br>这是包含 $S$ 的最小线性子子空间。</li><li>称 $S$ 为线性无关集是指 $S$ 中任何有限个互异向量线性无关。这即 $S$ 对 $\mathrm{span} S$ 中向量都有唯一线性表示。一个非零向量构成一个线性无关集。</li><li>对于 $a\in \mathbb{K}$ ，命 $aS=\{ax|x\in S\}$ 。对于 $S_i\subseteq X$ ，作代数和差 $S_1\pm S_2=\{ x_1\pm x_2|x_1\in S_1,x_2\in S_2 \}$ 。</li><li>当 $a_i$ 都非负且 $a_1+\cdots +a_n$ 时，称 $a_1x_1+\cdots+a_nx_n$ 是 $x_1,\cdots ,x_n$ 的凸组合。非空子集 $E$ 对凸组合封闭当且仅当满足 $0&lt;t&lt;1$ 的实数 $t$ 使 $tE+(1-t)E=E$ 当且仅当 $a$ 和 $b$ 是非负实数时 $aE+bE=(a+b)E$ ，此时称 $E$ 是凸集。</li><li>包含非空子集 $S$ 的所有凸集之交 $\mathrm{cov} S$ 是 $S$ 的凸包——包含 $S$ 的最小凸集：<br>$$<br>\mathrm{cov}=\bigcup_{n=1}^{\infty}\{ \sum_{i=1}^nt_ix_i|t_i\geq 0:\sum_{i\leq n}t_i=1;x_i\in S \}<br>$$<br>定理：设 $X$ 是数域 $\mathbb{K}$ 上非平凡线性空间【而 $S$ 是其线性无关集】，则 $X$ 有个【含 $S$ 的】线性基或 Hamel 基——使 $\mathbb{span}B$ 的线性无关集 $B$ 。</li></ol><p>平移：对于线性空间 $X$ 的子集 $E$ 与向量 $x$ ，作平移<br>$$<br>x+E={x+y|y\in E}<br>$$<br>这是 $S$ 在双射 $X\rightarrow X,y\rightarrow x+y$ 下的像集。它有如下性质：</p><ol><li>平移保持单调性： $E\subseteq F\Rightarrow x+E\subseteq x+F$ 。</li><li>平移保持并运算： $x+\bigcup\{ E_i|i\in I \}=\bigcup \{ x+E_i|i\in I \}$ 。</li><li>平移保持交运算： $x+\bigcap\{ E_i|i\in I \}=\bigcap \{ x+E_i|i\in I \}$ 。</li><li>平移保持差运算： $x+(E-F)=(x+E)-(x+F)$ 。</li><li>平移服从结合律： $x+(y+E)=(x+y)+E$ 。</li><li>凸集的平移还是凸集，但线性子空间不必是线性子空间。</li></ol><h2 id="测度与可测性"><a href="#测度与可测性" class="headerlink" title="测度与可测性"></a>测度与可测性</h2><h3 id="环与测度"><a href="#环与测度" class="headerlink" title="环与测度"></a>环与测度</h3><p>设某些集合组成集类 $\mathcal{A}$ 使 $X=\bigcup \mathcal{A}$ ，称 $X$ 为 $\mathcal{A}$ 的基本空间。</p><ul><li> $\mathcal{A}$ 对有限并运算封闭。</li><li> $\mathcal{A}$ 对有限无交并运算封闭。</li><li> $\mathcal{A}$ 对有限交运算封闭。</li><li> $\mathcal{A}$ 对差运算封闭。</li><li> $\mathcal{A}$ 对补运算封闭。</li><li> $\mathcal{A}$ 对可列并运算封闭。</li><li> $\mathcal{A}$ 对可列无交并运算封闭。</li></ul><p>环与代数：对于集合差运算与有限无交并运算封闭的集类 $\mathcal{R}$ 称为一个环。以基本空间 $X$ 为其成员的环也称为一个代数。</p><ol><li>空集是每个环的成员；环对于有限个集的并运算与交运算封闭。</li><li>一簇环 $\mathcal{R}_{i}:i\in I$ 之交 $\bigcap _{i\in I}\mathcal{R} _i$ 还是环。</li><li>幂集 $2^X$ 是 $X$ 上最大的代数。包含集类 $\mathcal{A}$ 的所有环之交 $R(\mathcal{A})$ 是包含 $\mathcal{A}$ 的最小环——这称为 $\mathcal{A}$ 生成的环。</li><li>大的集类生成的环不会小： $\mathcal{\theta}\subset\mathcal{F}\Rightarrow R(\theta)\subset\ R(F)$ 。</li></ol><p>初等分解与半环：集类 $\mathcal{A}$ 中有限个相互不交的成员 $E_1,\cdots,E_n$ 之并为 $E$ 时，称 $\{ E_i|i\leq n \}$ 是 $E$ 相对于 $\mathcal{A}$ 的初等分解。</p><ol><li>设集类 $\mathcal{A}$ 是半环——它对有限交运算封闭且 $\mathcal{A}$ 中两个成员的差可由 $\mathcal{A}$ 初等分解，则 $R(\mathcal{A})$ 中成员都可由 $\mathcal{A}$ 初等分解。</li><li>设 $\mathcal{E}$ 和 $\mathcal{F}$ 是半环，则 $\mathcal{E}*\mathcal{F}=\{ E\times F|E\in \mathcal{E},F\in \mathcal{F} \}$ 是半环。</li></ol><p>测度：设环上集函数 $\mu :\mathcal{R}\rightarrow\overline{\mathbb{R}}$ 满足以下条件：</p><ol><li>空集是其零集——取值为零的集： $\mu(\varnothing)=0$ 。</li><li>非负性： $E\in \mathcal{R}$ 时， $0\leq \mu(E)\leq +\infty$ 。</li><li>可列可加性： $\mathcal{R}$ 中相互不交序列 $(E_n)$ 之并 $E$ 仍在 $\mathcal{R}$ 中时，<br>$$<br>\mu(E)=\mu(E_1)+\mu(E_2)+\cdots<br>$$<br>则称 $\mu$ 为测度。它有以下性质（以下点集都来自 $\mathcal{R}$ 中）</li><li>有限可加性： $\mu(\sqcup_{i=1}^{n}E_i)=\sum_{i=1}^{n}\mu(E_i)$ 。</li><li>分割测量性（与有限可加性等价）： $\mu(F)=\mu(F\cap E)+\mu(F-E)$ 。</li><li>单调性：若 $E$ 是 $F$ 的子集，则 $\mu(E)\leq \mu(F)$ 。</li><li>可减性：若 $E$ 是 $F$ 的测度有限子集，则 $\mu(F-E)=\mu(F)-\mu(E)$ 。</li><li>可列次可加性： $\{ E_n \}$ 覆盖 $E$ 时， $\mu(E)\leq \sum_{i=1}^{\infty}\mu(E_i)$ 。</li><li>下连续性： $(E_n)$ 递增至 $E$ 时， $\lim_{n\to \infty}\mu(E_n)=\mu(E)$ 。</li><li>上连续性： $(E_n)$ 递减至 $E$ 且某项测度有限时， $\lim_{n\to \infty}\mu(E_n)=\mu(E)$ 。</li><li>序列 $(E_n)$ 的下限集为 $E$ 时， $\mu(E)\leq \varliminf_{n \to \infty}\mu(E_n)$ 。</li><li> $E=\varlimsup_{n\to \infty}E_n$ 且有 $k$ 使 $\mu(\cup_{n\geq k}E_n$ 有限时， $\varlimsup_{n\to \infty}\leq \mu(E)$ 。</li></ol><p>任何环 $\mathcal{R}$ 上都有一个计数测度——有限集 $E$ 的计数测度 $|E|_0$ 是 $E$ 中元素的个数而无限集 $E$ 的计数测度 $|E|_0=+\infty$ 。</p><p>Borel-Cantelli 引理：设 $\mu$ 是环 $\mathcal{R}$ 上的测度，设 $(E_n)$ 是 $\mathcal{R}$ 中序列使 $E=\varlimsup_{n\to \infty}E_n$ 在 $\mathcal{R}$ 中。若有 $k$ 使 $\sum_{n\geq k}\mu(E_n)&lt;+\infty$ ，则 $\mu(E)=0$ 。</p><p>定理：如果环上非负集函数 $\mu:\mathcal{R}\rightarrow\overline{\mathbb{R}}$ 具有分割测量性（相当于有限可加性）与可列次可加性，则它具有可列可加性。</p><p>单调性与 $\sigma -$ 环：<br>（一）对于单调集列的极限运算封闭的集类 $\mathcal{M} $ 称为单调类。如果幂集 $ 2^X $ 是单调类。一簇单调类 $ \{ \mathcal{M}<em>i | i\in I \} $ 之交 $\cap</em>{i\in I} {\mathcal{M}_i} $ 还是单调类。集类 $ \mathcal{A} $ 生成的单调类 $ M(\mathcal{A}) $ 是包含 $ \mathcal{A} $ 的最小单调类。</p><p>（二）对于差运算与可列无交并运算封闭的集类 $\mathcal{S}$ 称为 $\sigma -$ 环。以基本空间为成员的 $\sigma -$ 环也称为 $\sigma -$ 代数。幂集 $2^X$ 是 $X$ 上最大的 $\sigma -$ 代数和单调类。</p><p>单调类定理：包含环 $\mathcal{R}$ 的单调类 $\mathcal{M}$ 必包含 $\mathcal{R}$ 生成的 $\sigma-$ 环 $S(\mathcal{R})$ 。特别的，环 $\mathcal{R}$ 生成的单调类 $M(\mathcal{R})$ 与 $\sigma-$ 环 $S(\mathcal{R})$ 相等。</p><p>外测度：环 $\mathcal{R}$ 上的非负集函数 $\nu$ 称为外测度是指 $\nu$ 在空集上取值为 $0$ 且满足单调性与可列次可加性。设 $\mu$ 是环 $\mathcal{R}$ 上测度。对任何 $E\in H(\mathcal{R})$ ，作其外测度<br>$$<br>\mu^*(E)=\inf\{ \sum_{i=1}^{\infty}\mu(E_i)|\{ E_i|i\geq 1 \}\subseteq \mathcal{R}:E\subseteq \cup_{i=1}^{\infty}E_i \}<br>$$</p><ol><li>外测度 $\mu^*$ 在空集上为零： $\mu^*(\varnothing)=0$ 。</li><li>外测度 $\mu^*$ 具有非负性： $0\leq \mu^* \leq +\infty$ 。</li><li>外测度 $\mu^*$ 具有单调性： $E\subseteq F$ 蕴涵 $\mu^*(E)\leq \mu^*(F)$ 。</li><li>外测度具有可列次可加性：设 $H(\mathcal{R})$ 中序列 $(E_n)$ 覆盖 $E$ ，则<br>$$<br>\mu^*(E)\leq \mu^*(E_1)+\mu^*(E_2)+\cdots<br>$$</li><li>外测度 $\mu^*$ 是测度 $\mu$ 的集函数延拓： $E\in \mathcal{R}$ 蕴涵 $\mu(E)=\mu^*(E)$ 。</li><li>对于 $E\in H(\mathcal{R})$ ， $\mu^*(E)=\min\{ \mu^*(F)|E\subseteq F\in S(\mathcal{R}) \}$ 。</li><li>如果 $\mathcal{R}$ 由半环 $\mathcal{A}$ 生成，则<br>$$<br>\mu^*(E)=\inf\{ \sum_{n\geq 1}\mu(E_n) |\{ E_n \}\subseteq \mathcal{A}:E\subseteq \sqcup_{n\geq 1}E_n\}<br>$$</li></ol><p>定理：设 $\mu$ 是环 $\mathcal{R}$ 上测度而 $E\in H(\mathcal{R})$ 。如果 $E$ 能分割测量 $\mathcal{R}$ 中所有成员，则 $E$ 满足Caratheodory 条件——对任何 $F\in H(\mathcal{R})$ ，<br>$$<br>\mu^*(F)=\mu^*(F\cap E)+\mu^*(F-E)<br>$$</p><p>定理：设 $\mu$ 是环 $\mathcal{R}$ 上测度。全体 $\mu^*-$ 可测集组成一个包含 $\mathcal{R}$ 与一切 $\mu^*-$ 零集的 $\sigma-$ 环 $\mathcal{R}^*$ ，而 $\mu^*$ 限制在 $\mathcal{R}^*$ 上后是 $\mu$ 的一个完全测度延拓。</p><p>定理：设 $\mu$ 是环 $\mathcal{R}$ 上 $\sigma- $ 有限测度而 $E$ 是 $\mu^*-$ 可测集，则 $\mathcal{R}$ 中有个测度有限的递增序列 $(H_n)$ 覆盖 $E$ （因而 $\mu^*$ 在 $\mathcal{R}^*$ 与 $S(\mathcal{R})$ 上都 $\sigma-$ 有限）。进而，</p><ol><li>有 $D,F\in S(\mathcal{R})$ 使 $D\subseteq E\subseteq F$ 且 $\mu^*(F-D)=0$ 。</li><li> $\mu^*(E)&lt;+\infty$ 且 $\varepsilon&gt;0$ 时，有 $F\in\mathcal{R}$ 使 $\mu^*(E\Delta F)&lt;\varepsilon$ 。</li></ol><p>定理：环 $\mathcal{R}$ 上的 $\sigma -$ 有限测度在 $S(\mathcal{R})$ 上有唯一测度延拓。 </p><h3 id="勒贝格测度"><a href="#勒贝格测度" class="headerlink" title="勒贝格测度"></a>勒贝格测度</h3><p>定理：环  上有唯一有限测度  使任何  维区间  的测度就是它的  维体积——各边长度之积  。而  诱导的外测度是</p><p>欧几里得空间与Borel集：将  环  记为  ，其成员称为  的Borel集。另外  还有5个生成系：区间  全体，区间  全体，区间  全体，开集全体和紧集全体。</p><h2 id="积分与可积性"><a href="#积分与可积性" class="headerlink" title="积分与可积性"></a>积分与可积性</h2><h2 id="微分与不定积分"><a href="#微分与不定积分" class="headerlink" title="微分与不定积分"></a>微分与不定积分</h2>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog</title>
    <link href="/archives/301227eb.html"/>
    <url>/archives/301227eb.html</url>
    
    <content type="html"><![CDATA[<p>这是一种用来设计电路的语言。学还是挺好学的，就是一个仿真模拟的软件有十几个G的大小，我的电脑装不下。</p><span id="more"></span><h1 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="什么是-Verilog"><a href="#什么是-Verilog" class="headerlink" title="什么是 Verilog"></a>什么是 Verilog</h3><p><strong>Verilog HDL</strong>是一种用于数字逻辑电路设计的硬件描述语言，可以用来进行数字电路的仿真验证、时序分析、逻辑综合。</p><p>用Verilog HDL描述的电路设计就是该电路的<strong>Verilog HDL模型</strong>。</p><p>Verilog HDL 既是一种<strong>行为描述</strong>语言也是一种<strong>结构描述</strong>语言。</p><p>Verilog HDL模型可以是实际电路的不同级别的抽象。<strong>抽象级别</strong>可分为五级：</p><ul><li><strong>系统级</strong>：用高级语言结构（如case语句）实现的设计模块外部性能的模型；</li><li><strong>算法级</strong>：用高级语言结构实现的设计算法模型（写出逻辑表达式）；</li><li><strong>RTL级</strong>：描述数据在寄存器之间流动和如何处理这些数据的模型；</li><li><strong>门级</strong>：描述逻辑门（如与门、非门、或门、与非门、三态门等）以及逻辑门之间连接的模型；</li><li><strong>开关级</strong>：描述器件中三极管和储存节点及其之间连接的模型。</li></ul><h3 id="Verilog-HDL的特点"><a href="#Verilog-HDL的特点" class="headerlink" title="Verilog HDL的特点"></a>Verilog HDL的特点</h3><ul><li>形式化地表示电路的行为和结构；</li><li>借用C语言的结构和语句；</li><li>可在多个层次上对所设计的系统加以描述，语言对设计规模不加任何限制；</li><li>具有混合建模能力：一个设计中的各子模块可用不同级别的抽象模型来描述；</li><li>基本逻辑门、开关级结构模型均内置于语言中，可直接调用；</li></ul><h2 id="Verilog-HDL-的基本结构"><a href="#Verilog-HDL-的基本结构" class="headerlink" title="Verilog HDL 的基本结构"></a>Verilog HDL 的基本结构</h2><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//2位比较器</span><br><span class="hljs-keyword">module</span> compare2 (equal,a,b);<br>    <span class="hljs-keyword">output</span> equal;<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a,b;<br>    <span class="hljs-keyword">assign</span> equal = (a == b)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><ol><li>端口定义</li><li>I/O说明</li><li>信号类型声明</li><li>功能描述</li></ol><p>逻辑功能定义</p><p>有三种方法可以描述电路的逻辑功能</p><ol><li>用 assign 语句</li></ol><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> x = (b &amp; ~c);<br></code></pre></div></td></tr></table></figure><ol start="2"><li>用元件<strong>例化</strong></li></ol><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">and</span> myand3(f,a,b,c);<span class="hljs-comment">//门元件例化</span><br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//模块元件例化</span><br><span class="hljs-keyword">module</span> trist1(out,in,enable);<br>    <span class="hljs-keyword">output</span> out;<br>    <span class="hljs-keyword">input</span> in,enable;<br>    mytri tri_inst(out,in,enable);<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-keyword">module</span> mytri(out,on,enable);<br>    <span class="hljs-keyword">output</span> out;<br>    <span class="hljs-keyword">input</span> in,enable;<br>    <span class="hljs-keyword">assign</span> out = enable?in:<span class="hljs-number">&#x27;bz</span>;<span class="hljs-comment">//&#x27;bz表示高阻态</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><p>模块元件例化——顶层模块（trist1）调用由某子模块（mytri）定义的实例元件（tri_inst）来实现某功能。</p><ul><li>元件例化是调用 Verilog HDL 提供的元件</li><li>元件例化包括<strong>门元件例化</strong>和<strong>模块元件例化</strong></li><li>每个实例元件的名字必须<strong>唯一</strong>！避免与其他调用元件的实例相混淆</li><li>例化元件名也可以省略（当元件只用到一个时）</li></ul><ol start="3"><li>用 “always” 引导的块语句</li></ol><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)<span class="hljs-comment">//敏感信号变化就执行块内语句</span><br>    <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">if</span>(load)<br>            out = data;<span class="hljs-comment">//同步预置数据</span><br>        <span class="hljs-keyword">else</span><br>            out = data + <span class="hljs-number">1</span> + cin;<span class="hljs-comment">//加1计数</span><br>    <span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><ul><li>“always” 块语句通常用于描述时序逻辑，也可以描述组合逻辑</li><li>“always” 块语句可用多种手段表达逻辑关系</li><li>“always” 块语句与 assign 语句是<strong>并发执行</strong>的， assign 语句一定要放在 “always” 块语句之外</li></ul><p>Verilog HDL 模块的模板</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> &lt;顶层模块名&gt; (&lt; 输入输出端口列表&gt;) ；<br>    <span class="hljs-keyword">output</span> 输出端口列表；<br>    <span class="hljs-keyword">input</span> 输入端口列表；<br> <span class="hljs-comment">//（1）使用assign语句定义逻辑功能</span><br>    <span class="hljs-keyword">wire</span> 结果信号名；<br>    <span class="hljs-keyword">assign</span> &lt;结果信号名&gt; = 表达式 ；  <br> <span class="hljs-comment">//（2）使用always块定义逻辑功能</span><br>    <span class="hljs-keyword">always</span> @(&lt;敏感信号表达式&gt;)<br>        <span class="hljs-keyword">begin</span><br>       <span class="hljs-comment">//过程赋值语句</span><br>            <span class="hljs-comment">//if语句</span><br>            <span class="hljs-comment">// case语句</span><br>           <span class="hljs-comment">// while,repeat,for循环语句</span><br>           <span class="hljs-comment">// task,function调用</span><br>       <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h2 id="数据类型及常量、变量"><a href="#数据类型及常量、变量" class="headerlink" title="数据类型及常量、变量"></a>数据类型及常量、变量</h2><h3 id="Verilog-关键字"><a href="#Verilog-关键字" class="headerlink" title="Verilog 关键字"></a>Verilog 关键字</h3><p><strong>关键字</strong>:事先定义好的确认符，用来组织语言结构；或者用于定义Verilog HDL提供的门元件（如and，not，or，buf）。用小写字母定义！</p><p>Verilog的关键字:</p><blockquote><p>always， and， assign，begin，buf，bufif0，bufif1，case，casex，casez，cmos，deassign， default，defparam，disable，edge，else，end，endcase，endmodule，endfunction，endprimitive, endspecify, endtable， endtask， event， for， force， forever， fork， function，highz0， highz1, if，initial, inout, input，integer，join,large，macromodule，medium，module， nand，negedge，nmos，nor，not，notif0，notifl, or, output, parameter, pmos, posedge, primitive, pull0, pull1, pullup, pulldown, rcmos, reg, releses, repeat, mmos, rpmos, rtran, rtranif0,rtranif1,scalared,small，specify，specparam，strength，strong0, strong1, supply0, supply1, table, task, time, tran, tranif0, tranif1, tri, tri0, tri1, triand, trior， trireg，vectored，wait，wand，weak0，weak1，while， wire，wor, xnor， xor</p></blockquote><h3 id="Verilog-标识符"><a href="#Verilog-标识符" class="headerlink" title="Verilog 标识符"></a>Verilog 标识符</h3><p><strong>标识符</strong>:任何用Verilog HDL语言描述的“东西”都通过其名字来识别，这个名字被称为标识符。</p><p>标识符可由字母、数字、下划线和美元符号构成；但第一个字符必须是字母或下划线，不能是数字或美元符号！</p><p>Verilog HDL中变量名是<strong>区分大小写</strong>。</p><h3 id="Verilog-数据类型"><a href="#Verilog-数据类型" class="headerlink" title="Verilog 数据类型"></a>Verilog 数据类型</h3><p>Verilog HDL中共有19种数据类型；其中4个最基本的数据类型为：</p><ul><li>integer型</li><li>parameter型</li><li>reg型</li><li>wire型</li></ul><p>其它数据类型：large型、medium型、 scalared型、 small型、time型、tri型、tri0型、tri1型、triand型、trior型、trireg型、vectored型、wand型、wor型等</p><p><strong>常量</strong>：在程序运行过程中，其值不能被改变的量，称为常量。 </p><ul><li>数字（包括整数，x和z值，负数）</li><li>parameter常量（或称符号常量）</li></ul><p>(1)<strong>整数型常量</strong>（即整常数）的4种进制表示形式：</p><ul><li>二进制整数（b或B）；</li><li>十进制整数（d或D）；</li><li>十六进制整数（h或H）；</li><li>八进制整数（o或O）。</li></ul><table><thead><tr><th>表达方式</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>&lt;位宽&gt; ’&lt;进制&gt; &lt;数字&gt;</td><td>完整表达方式</td><td>8’b11000101或8’hc5或8’b1100_0101</td></tr><tr><td>&lt;进制&gt; &lt;数字&gt;</td><td>缺省位宽，则位宽由机器系统决定，至少32位</td><td>hc5</td></tr><tr><td>&lt;数字&gt;</td><td>缺省进制为十进制，位宽默认为32位</td><td>197</td></tr></tbody></table><p>(2)<strong>x和z值</strong></p><p>x表示不定值，z表示高阻值；</p><ul><li>每个字符代表的二进制数的宽度取决于所用的进制；</li><li>当用二进制表示时，已标明位宽的数若用x或z表示某些位，则只有在最左边的x或z具有扩展性！为清晰可见，最好直接写出每一位的值！<br>[例]8’bzx = 8’bzzzz_zzzx<br>[例]8’b1x = 8’b0000_001x</li><li>“？”是z的另一种表示符号，建议在case语句中使用？表示高阻态z<br>[例] </li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">casez</span> (select)<br>        <span class="hljs-number">4</span>’b???<span class="hljs-number">1</span>: out = a;<br>        <span class="hljs-number">4</span>’b??<span class="hljs-number">1</span>?: out = b;<br>        <span class="hljs-number">4</span>’b?<span class="hljs-number">1</span>??: out = c;<br>        <span class="hljs-number">4</span>’b1???: out = d;<br><span class="hljs-keyword">endcase</span><br></code></pre></div></td></tr></table></figure><p>(3)<strong>负数</strong></p><ul><li>在位宽前加一个减号，即表示负数<br>如：-8’d5    //5的补数，= 8‘b11111011</li><li>减号不能放在位宽与进制之间，也不能放在进制与数字之间！<br>8 ’ d-5    //非法格式</li></ul><blockquote><p>为提高可读性，在较长的数字之间可用下划线_隔开！但不可以用在&lt;进制&gt;和&lt;数字&gt;之间。<br>当常量未指明位宽时，默认为32位。</p></blockquote><p>(4)<strong>parameter常量（符号常量）</strong></p><p>用parameter来定义一个标识符，代表一个常量——称为符号常量</p><p>parameter 参数名1 = 表达式,参数名2 = 表达式, ……；</p><ul><li>每个赋值语句的右边必须为常数表达式，即只能包含数字或先前定义过的符号常量！</li><li>常用参数来定义延迟时间和变量宽度。</li><li>可用字符串表示的任何地方,都可以用定义的参数来代替。</li><li>参数是本地的，其定义只在本模块内有效。</li><li>在模块或实例引用时，可通过参数传递改变在被引用模块或实例中已定义的参数！</li></ul><p><strong>参数常量的使用</strong>：</p><ol><li><p>利用defparam定义参数声明语句！<br>defparam 例化模块名.参数名1 = 常数表达式,<br>例化模块名.参数名2 = 常数表达式, ……；</p><ul><li>defparam语句在编译时可重新定义参数值。</li><li>可综合性问题：一般情况下是不可综合的。</li><li>提示：不要使用defparam语句！在模块的实例引用时可用“#”号后跟参数的语法来重新定义参数。</li></ul></li><li><p>利用特殊符号“#”<br>被引用模块名 # （参数1,参数2,…）例化模块名（端口列表）；</p></li></ol><p><strong>变量</strong>：在程序运行过程中，其值可以改变的量，称为变量。</p><p>其数据类型有19种，常用的有3种：</p><ul><li>网络型（nets type）</li><li>寄存器型（register type ）</li><li>数组（memory type）</li></ul><p><strong>nets型变量</strong>：输出始终随输入的变化而变化的变量。表示结构实体（如门）之间的物理连接。</p><p><strong>常用nets型变量</strong>：</p><ul><li>wire，tri：连线类型（两者功能一致）</li><li>wor，trior：具有线或特性的连线（两者功能一致）</li><li>wand，triand：具有线与特性的连线（两者功能一致）</li><li>tri1，tri0：上拉电阻和下拉电阻</li><li>supply1，supply0：电源（逻辑1）和地（逻辑0）</li></ul><p><strong>wire型变量</strong>：</p><ul><li><strong>最常用的nets型变量</strong>，常用来表示以assign语句赋值的组合逻辑信号。</li><li>模块中的输入/输出信号类型缺省为wire型。</li><li>可用做任何方程式的输入，或“assign”语句和实例元件的输出。</li></ul><p>wire 数据名1,数据名2, ……,数据名n;</p><p>wire型向量（总线）：wire[n-1:0] 数据名1,数据名2, ……,数据名m;或 wire[n:1] 数据名1,数据名2, ……,数据名m;</p><p><strong>register型变量</strong>：对应具有状态保持作用的电路元件（如触发器、寄存器等）,常用来表示过程块语句（如initial，always，task，function）内的指定信号 。</p><p><strong>常用register型变量</strong>：</p><ul><li>reg：常代表触发器</li><li>integer：32位带符号整数型变量</li><li>real：64位带符号实数型变量</li><li>time：无符号时间变量</li></ul><p><strong>reg型变量</strong>：在过程块中被赋值的信号，往往代表触发器，但不一定就是触发器（也可以是组合逻辑信号）！</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> 数据名<span class="hljs-number">1</span>,数据名<span class="hljs-number">2</span>, ……,数据名n;<br></code></pre></div></td></tr></table></figure><p>reg型向量（总线）：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><br><span class="hljs-keyword">reg</span>[n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] 数据名<span class="hljs-number">1</span>,数据名<span class="hljs-number">2</span>, ……,数据名m; <br><span class="hljs-comment">//或</span><br><span class="hljs-keyword">reg</span>[n:<span class="hljs-number">1</span>] 数据名<span class="hljs-number">1</span>,数据名<span class="hljs-number">2</span>, ……,数据名m;<br></code></pre></div></td></tr></table></figure><p>对比register型变量和nets型变量</p><ul><li>register型变量需要被明确地赋值，并且在被重新赋值前一直保持原值。</li><li>register型变量必须通过过程赋值语句赋值！不能通过assign语句赋值！</li><li>在过程块内被赋值的每个信号必须定义成register型！</li><li>wire型变量只能生成组合逻辑。 reg型变量既可生成触发器，也可生成组合逻辑。</li></ul><p><strong>memory型变量</strong>：由若干个相同宽度的reg型向量构成的数组。</p><ul><li>Verilog HDL通过reg型变量建立数组来对存储器建模。</li><li>memory型变量可描述RAM、ROM和reg文件。</li><li>memory型变量通过扩展reg型变量的地址范围来生成：</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span>[n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] 存储器名[m-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];或 <span class="hljs-keyword">reg</span>[n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>]存储器名[m:<span class="hljs-number">1</span>];<br></code></pre></div></td></tr></table></figure><p>memory型变量与reg型变量的区别：</p><ul><li>含义不同：reg[n-1:0] rega；//一个n位的寄存器 reg mema [n-1:0] ；//由n个1位寄存器组成的存储器</li><li>赋值方式不同:一个n位的寄存器可用一条赋值语句赋值； 一个完整的存储器则不行！若要对某存储器中的存储单元进行读写操作，必须指明该单元在存储器中的地址！</li></ul><h2 id="运算符及表达式"><a href="#运算符及表达式" class="headerlink" title="运算符及表达式"></a>运算符及表达式</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table><thead><tr><th>算术运算符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>/</td><td>除</td></tr><tr><td>%</td><td>求模</td></tr></tbody></table><ul><li>除法取整：进行整数除法运算时，结果值略去小数部分，只取整数部分！</li><li>%称为求模（或求余）运算符，要求%<strong>两侧均为整型数据</strong>；</li><li>求模运算结果值的符号位取第一个操作数的符号位！<br>[例] -11%3     结果为-2</li><li>进行算术运算时，若某操作数为不定值x，则整个结果也为x。</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符把它的操作数当作布尔变量：</p><ul><li>非零的操作数被认为是真(1’b1)；</li><li>零被认为是假(1’b0)；</li><li>不确定的操作数如4’bxx00, 被认为是不确定的(可能为零，也可能为非零）（记为1’bx)； 但4’bxx11被认为是真（记为1’b1，因为它肯定是非零的）。</li><li>进行逻辑运算后的结果为布尔值（为1或0或x）！</li><li>“&amp;&amp;”和“||”的优先级除高于条件运算符外，低于关系运算符、等式运算符等几乎所有运算符；</li><li>逻辑非“！”优先级最高。</li></ul><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th>关系运算符</th><th>说明</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr></tbody></table><ul><li>运算结果为1位的逻辑值1或0或x。关系运算时，若关系为真，则返回值为1；若声明的关系为假，则返回值为0；若某操作数为不定值x，则返回值为x。</li><li>所有的关系运算符优先级别相同。</li><li>关系运算符的优先级低于算术运算符。</li></ul><h3 id="等式运算符"><a href="#等式运算符" class="headerlink" title="等式运算符"></a>等式运算符</h3><table><thead><tr><th>等式运算符</th><th>说明</th></tr></thead><tbody><tr><td>==</td><td>等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>===</td><td>全等</td></tr><tr><td>!==</td><td>不全等</td></tr></tbody></table><ul><li>运算结果为1位的逻辑值1或0或x。</li><li>等于运算符(= =)和全等运算符(= = =)的区别:<br>使用等于运算符时，两个操作数必须逐位相等,结果才为1；若某些位为x或z，则结果为x。<br>使用全等运算符时，若两个操作数的相应位完全一致（如同是1，或同是0，或同是x，或同是z）,则结果为1；否则为0。</li><li>所有的等式运算符优先级别相同。</li><li>= = =和！= =运算符常用于case表达式的判别，又称为“case等式运算符”。</li></ul><h3 id="缩减运算符"><a href="#缩减运算符" class="headerlink" title="缩减运算符"></a>缩减运算符</h3><table><thead><tr><th>缩减运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td></tr><tr><td>~&amp;</td><td>与非</td></tr><tr><td>|</td><td>或</td></tr><tr><td>~|</td><td>或非</td></tr><tr><td>^</td><td>异或</td></tr><tr><td>^ ~,~ ^</td><td>同或</td></tr></tbody></table><ul><li>运算法则与位运算符类似，但运算过程不同！</li><li>对单个操作数进行递推运算,即先将操作数的最低位与第二位进行与、或、非运算，再将运算结果与第三位进行相同的运算，依次类推，直至最高位 。</li><li>运算结果缩减为1位二进制数。<br>[例]reg[3:0] a;<br>b=|a;          //等效于 b =( (a[0] | a[1]) | a(2)) | a[3]</li></ul><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>条件运算符为？：<br>用法：信号=条件?表达式1:表达式2</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table><thead><tr><th>位运算符</th><th>说明</th></tr></thead><tbody><tr><td>~</td><td>按位取反</td></tr><tr><td>&amp;</td><td>按位与</td></tr><tr><td>|</td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>^ ~,~ ^</td><td>按位同或</td></tr></tbody></table><ul><li>位运算其结果与操作数位数相同。位运算符中的双目运算符要求对两个操作数的相应位逐位进行运算。</li><li>两个不同长度的操作数进行位运算时，将<strong>自动按右端对齐</strong>，位数少的操作数会在高位用0补齐。<br>[例] 若A = 5’b11001，B = 3’b101，<br>则A &amp; B = （5’b11001）&amp;（5’b00101）= 5’b00001</li></ul><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><table><thead><tr><th>移位运算符</th><th>说明</th></tr></thead><tbody><tr><td>&gt;&gt;</td><td>右移</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr></tbody></table><ul><li>用法：A&gt;&gt;n   或 A&lt;&lt;n<br>将操作数右移或左移n位，同时用n个0填补移出的空位。<br>[例] 4’b1001&gt;&gt;3 = 4’b0001； 4’b1001&gt;&gt;4 = 4’b0000<br>4’b1001&lt;&lt;1 = 5’b10010；4’b1001&lt;&lt;2 = 6’b100100；<br>1&lt;&lt;6 = 32’b1000000</li></ul><h3 id="位拼接运算符"><a href="#位拼接运算符" class="headerlink" title="位拼接运算符"></a>位拼接运算符</h3><ul><li>位拼接运算符为{ }</li><li>用于<strong>将两个或多个信号的某些位拼接起来</strong>，表示一个整体信号。</li><li>用法：{信号1的某几位，信号2的某几位，···，信号n的某几位}</li><li>例如在进行加法运算时，可将进位输出与和拼接在一起使用。</li></ul><h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><p>运算符优先级</p><p><img src="301227eb/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.jpg" alt="运算符优先级"></p><p>为提高程序的可读性，建议使用括号来控制运算的优先级！</p><h2 id="Verilog-语句"><a href="#Verilog-语句" class="headerlink" title="Verilog 语句"></a>Verilog 语句</h2><p><img src="301227eb/%E8%AF%AD%E5%8F%A5.jpg" alt="语句"></p><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><ol><li><strong>连续赋值语句</strong>——assign语句，用于对wire型变量赋值，是描述组合逻辑最常用的方法之一。[例] assign c=a&b;    //a、b、c均为wire型变量。</li><li><strong>过程赋值语句</strong>——用于对reg型变量赋值，有两种方式：<ul><li>非阻塞（non-blocking)赋值方式：赋值符号为&lt;=，如 b &lt;= a ；</li><li>阻塞（blocking)赋值方式：赋值符号为=，如 b = a ；</li></ul></li></ol><p>非阻塞赋值与阻塞赋值的<strong>区别</strong></p><ol><li><p><strong>非阻塞赋值</strong>方式<br>非阻塞赋值在<strong>块结束时</strong>才完成赋值操作</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)  <br>    <span class="hljs-keyword">begin</span>  <br>            b &lt;=  a ; <br>            c &lt;= b;<br>        <span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p> 注：c的值比b的值落后一个时钟周期！</p></li><li><p><strong>阻塞赋值</strong>方式<br>阻塞赋值在<strong>该语句结束时</strong>就完成赋值操作！</p> <figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)  <br>    <span class="hljs-keyword">begin</span>  <br>            b = a ; <br>            c = b;<br>        <span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><p> 注：在一个块语句中，如果有多条阻塞赋值语句，在前面的赋值语句没有完成之前，后面的语句就不能被执行，就像被阻塞了一样，因此称为阻塞赋值方式。<br> 这里c的值与b的值一样 ！</p></li></ol><p>非阻塞赋值与阻塞赋值方式的<strong>主要区别</strong></p><p>非阻塞（non-blocking)赋值方式 ( b&lt;= a)：</p><ul><li>b的值被赋成新值a的操作, 并不是立刻完成的，而是在块结束时才完成；</li><li>块内的多条赋值语句在块结束时同时赋值；</li><li>硬件有对应的电路。</li></ul><p>阻塞（blocking)赋值方式 ( b = a)：</p><ul><li>b的值立刻被赋成新值a；</li><li>完成该赋值语句后才能执行下一句的操作；</li><li>硬件没有对应的电路，因而综合结果未知。</li></ul><p>建议在初学时只使用一种方式，不要混用！</p><p>建议在可综合风格的模块中使用非阻塞赋值！</p><h3 id="块语句"><a href="#块语句" class="headerlink" title="块语句"></a>块语句</h3><p>用来将两条或多条语句组合在一起，使其在格式上更像一条语句，以增加程序的可读性。</p><p>顺序块语句：</p><ul><li>begin_end语句——标识顺序执行的语句</li></ul><p><img src="301227eb/%E9%A1%BA%E5%BA%8F%E5%9D%97%E6%A0%BC%E5%BC%8F.jpg" alt="顺序块格式"></p><p>特点：</p><p>块内的语句是<strong>顺序执行</strong>的；</p><ul><li>每条语句的延迟时间是相对于前一条语句的仿真时间而言的；</li><li>直到最后一条语句执行完，程序流程控制才跳出该顺序块。</li></ul><p>并行块语句：</p><ul><li>用fork_join标识的块</li></ul><p><img src="301227eb/%E5%B9%B6%E8%A1%8C%E5%9D%97%E6%A0%BC%E5%BC%8F.jpg" alt="并行块格式"></p><p>特点：</p><ul><li>块内的语句是<strong>同时执行</strong>的；</li><li>块内每条语句的延迟时间是相对于程序流程控制进入到块内时的仿真时间而言的；</li><li>延迟时间用于给赋值语句提供时序；</li><li>当按时间排序在最后的语句执行完或一个disable语句执行时，程序流程控制跳出该并行块。</li></ul><h3 id="编译预处理语句"><a href="#编译预处理语句" class="headerlink" title="编译预处理语句"></a>编译预处理语句</h3><p>一、‵define语句<br>宏定义语句——用一个指定的标志符（即宏名）来代表一个字符串（即宏内容）</p><p>宏展开——在编译预处理时将宏名替换为字符串的过程。</p><p>宏定义的作用：</p><ul><li>以一个简单的名字代替一个长的字符串或复杂表达式；</li><li>以一个有含义的名字代替没有含义的数字和符号。</li></ul><p>注意：</p><ul><li>宏名可以用大写字母，也可用小写字母表示；但建议用大写字母，以与变量名相区别。</li><li>‵define语句可以写在模块定义的外面或里面。宏名的有效范围为定义命令之后到源文件结束。</li><li>在引用已定义的宏名时，必须在其前面加上符号“‵ ” ！</li><li>使用宏名代替一个字符串，可简化书写，便于记忆，易于修改。</li><li>预处理时只是将程序中的宏名替换为字符串，不管含义是否正确。只有在编译宏展开后的源程序时才报错。</li><li>宏名和宏内容必须在同一行中进行声明！</li><li>宏定义不是Verilog HDL语句，不必在行末加分号！如果加了分号，会连分号一起置换！</li><li>在进行宏定义时，可引用已定义的宏名，实现层层置换。</li></ul><p>二、‵include语句<br>文件包含语句——一个源文件可将另一个源文件的全部内容包含进来。</p><p>好处：</p><p>避免程序设计人员的重复劳动！不必将源代码复制到自己的另一源文件中，使源文件显得简洁。<br>（1）可以将一些常用的宏定义命令或任务（task）组成一个文件，然后用‵include语句将该文件包含到自己的另一源文件中，相当于将工业上的标准元件拿来使用。<br>（2）当某几个源文件经常需要被其他源文件调用时，则在其他源文件中用‵include语句将所需源文件包含进来。</p><p>注意：</p><ul><li>一个‵include语句只能指定一个被包含的文件；若要包含n个文件，需用n个‵include语句。</li><li>‵include语句可出现在源程序的任何地方。被包含的文件若与包含文件不在同一子目录下，必须指明其路径！</li><li>可将多个‵include语句写在一行；在该行中，只可出现空格和注释行。<br>文件包含允许嵌套。</li></ul><p>三、‵timescale语句<br>时间尺度语句——用于定义跟在该命令后模块的时间单位和时间精度。</p><p>‵timescale &lt;时间单位&gt; / &lt;时间精度&gt;</p><ul><li>时间单位——用于定义模块中仿真时间和延迟时间的基准单位；</li><li>时间精度——用来声明该模块的仿真时间和延迟时间的精确程度。</li><li>在同一程序设计里，可以包含采用不同时间单位的模块。此时用最小的时间精度值决定仿真的时间单位。</li></ul><p>注意：</p><ul><li>时间精度至少要和时间单位一样精确，时间精度值不能大于时间单位值！</li><li>在‵timescale语句中，用来说明时间单位和时间精度参量值的数字必须是整数。</li><li>其有效数字为1、10、100；</li><li>单位为秒（s）、毫秒（ms）、微秒（us）、纳秒（ns）、皮秒（ps）、毫皮秒（fs）。</li></ul><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>条件语句分为两种：if-else语句和case语句；<br>它们都是顺序语句，应放在“always”块内！</p><ol><li>if-else 语句</li></ol><p>判定所给条件是否满足，根据判定的结果（真或假）决定执行给出的两种操作之一。</p><p>if-else语句有3种形式：</p><ul><li>其中“表达式”为逻辑表达式或关系表达式，或一位的变量。</li><li>若表达式的值为0、或z，则判定的结果为“假”；若为1，则结果为“真”。</li><li>语句可为单句，也可为多句；多句时一定要用“begin_end”语句括起来，形成一个复合块语句。</li></ul><p>允许一定形式的表达式简写方式，如：<br>if(expression) 等同于if(expression = = 1)<br>if(！expression) 等同于if(expression ！= 1)</p><p>方式1：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>（表达式） 语句<span class="hljs-number">1</span>；<br></code></pre></div></td></tr></table></figure><p>方式2：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>（表达式<span class="hljs-number">1</span>） 语句<span class="hljs-number">1</span>；<br><span class="hljs-keyword">else</span> 语句<span class="hljs-number">2</span>；<br></code></pre></div></td></tr></table></figure><p>方式3：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>（表达式<span class="hljs-number">1</span>） 语句<span class="hljs-number">1</span>；<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>（表达式<span class="hljs-number">2</span>）语句<span class="hljs-number">2</span>；<br>      …<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>（表达式n）语句n；<br></code></pre></div></td></tr></table></figure><ul><li>if语句可以嵌套；</li><li>若if与else的数目不一样，注意用“begin_end”语句来确定if与else的配对关系！</li></ul><p>if语句的嵌套：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>（表达式<span class="hljs-number">1</span>） <br>  <span class="hljs-keyword">if</span>（表达式<span class="hljs-number">2</span>）语句<span class="hljs-number">1</span>；<br>  <span class="hljs-keyword">else</span>         语句<span class="hljs-number">2</span>；<br><span class="hljs-keyword">else</span><br>  <span class="hljs-keyword">if</span>（表达式<span class="hljs-number">3</span>）语句<span class="hljs-number">3</span>；<br>  <span class="hljs-keyword">else</span>         语句<span class="hljs-number">4</span>；<br><br></code></pre></div></td></tr></table></figure><p>当if与else的数目不一样时，最好用“begin_end”语句将单独的if语句括起来：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span>（表达式<span class="hljs-number">1</span>） <br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span>（表达式<span class="hljs-number">2</span>）语句<span class="hljs-number">1</span>；<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br>  语句<span class="hljs-number">2</span>；<br><br></code></pre></div></td></tr></table></figure><p>注意：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span> (reset)<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (load)<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cin)<br></code></pre></div></td></tr></table></figure><p>不要写成3个并列的if语句：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span> (reset)<br><span class="hljs-keyword">if</span> (load)<br><span class="hljs-keyword">if</span> (cin)<br></code></pre></div></td></tr></table></figure><p>因为这样写则是同时对3个信号reset、load和cin进行判断，现实中很可能出现三者同时为“1”的情况，即3个条件同时满足，则应该同时执行它们对应的执行语句，但3条执行语句是对同一个信号qout赋不同的值，显然相互矛盾。故编译时会报错！</p><ol start="2"><li>case 语句</li></ol><ul><li>当敏感表达式取不同的值时, 执行不同的语句。</li><li>功能：当某个（控制）信号取不同的值时，给另一个（输出）信号赋不同的值。常用于多条件译码电路（如译码器、数据选择器、状态机、微处理器的指令译码）！</li><li>case语句有3种形式：case，casez，casex</li></ul><p>(1)case 语句</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><br><span class="hljs-keyword">case</span>（敏感表达式） <br>    值<span class="hljs-number">1</span>：语句<span class="hljs-number">1</span>；<br>    值<span class="hljs-number">2</span>：语句<span class="hljs-number">2</span>；<br>      …<br>    值n：语句n；<br>    <span class="hljs-keyword">default</span>: 语句n+<span class="hljs-number">1</span>；<br><span class="hljs-keyword">endcase</span><br><br></code></pre></div></td></tr></table></figure><p>说明：</p><ul><li>其中“敏感表达式”又称为“控制表达式”，通常表示为控制信号的某些位。<br>值1~值n称为分支表达式，用控制信号的具体状态值表示，因此又称为常量表达式。</li><li>default项可有可无，一个case语句里只能有一个default项!</li><li>值1~值n必须互不相同，否则矛盾。</li><li>值1~值n的位宽必须相等，且与控制表达式的位宽相同。</li></ul><p>(2)casex 语句与casez 语句</p><ul><li>在case语句中，分支表达式每一位的值都是确定的（或者为0，或者为1）；</li><li>在casez语句中，若分支表达式某些位的值为高阻值z，则不考虑对这些位的比较；</li><li>在casex语句中，若分支表达式某些位的值为z或不定值x，则不考虑对这些位的比较。</li><li>在分支表达式中，可用“？”来标识x或z。</li></ul><p>[例] 用casez描述的数据选择器</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> mux_z(out,a,b,c,d,select);<br>      <span class="hljs-keyword">output</span> out;<br>      <span class="hljs-keyword">input</span> a,b,c,d;<br>      <span class="hljs-keyword">input</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] select;<br>      <span class="hljs-keyword">reg</span> out; <span class="hljs-comment">//必须声明</span><br>     <span class="hljs-keyword">always</span>@ (select[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> a <span class="hljs-keyword">or</span> b <span class="hljs-keyword">or</span> c <span class="hljs-keyword">or</span> d)<br>     <span class="hljs-keyword">begin</span><br>         <span class="hljs-keyword">casez</span> (select)<br>             <span class="hljs-number">4</span>’b???<span class="hljs-number">1</span>: out = a；<br>             <span class="hljs-number">4</span>’b??<span class="hljs-number">1</span>? : out = b；<br>             <span class="hljs-number">4</span>’b? <span class="hljs-number">1</span>?? : out = c；<br>             <span class="hljs-number">4</span>’b <span class="hljs-number">1</span>??? : out = d；<br>         <span class="hljs-keyword">endcase</span><br>     <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>循环语句分为4种：</p><ul><li><p>for语句——通过3个步骤来决定语句的循环执行：<br>（1）给控制循环次数的变量赋初值。<br>（2）判定循环执行条件，若为假则跳出循环；若为真，则执行指定的语句后，转到第（3）步。<br>（3）修改循环变量的值，返回第（2）步。</p></li><li><p>repeat语句——连续执行一条语句n次</p></li><li><p>while语句——执行一条语句，直到循环执行条件不满足；若一开始条件即不满足，则该语句一次也不能被执行！</p></li><li><p>forever语句——无限连续地执行语句，可用disable语句中断！</p></li></ul><ol><li>for语句</li></ol><p>一般形式：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">for</span> （表达式<span class="hljs-number">1</span>；表达式<span class="hljs-number">2</span>；表达式<span class="hljs-number">3</span>）语句<br></code></pre></div></td></tr></table></figure><p>简单应用形式：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">for</span>（循环变量赋初值；循环执行条件；循环变量增值）<br>    执行语句<br><br></code></pre></div></td></tr></table></figure><p>[例]用for语句描述的7人投票表决器：若超过4人（含4人）投赞成票，则表决通过。</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><br><span class="hljs-keyword">module</span>  vote7 ( pass,vote ); <br>      <span class="hljs-keyword">output</span> pass;<br>      <span class="hljs-keyword">input</span> [<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] vote; <br>      <span class="hljs-keyword">reg</span>[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sum;      <span class="hljs-comment">//sum为reg型变量，用于统计赞成的人数</span><br>      <span class="hljs-keyword">integer</span> i; <br>      <span class="hljs-keyword">reg</span> pass;<br>      <span class="hljs-keyword">always</span> @(vote)<br>          <span class="hljs-keyword">begin</span><br>              sum = <span class="hljs-number">0</span>;                                    <span class="hljs-comment">//sum初值为0</span><br>              <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">6</span>;i = i+<span class="hljs-number">1</span>)                <span class="hljs-comment">//for语句</span><br>    <span class="hljs-keyword">if</span>(vote[i])      sum = sum+<span class="hljs-number">1</span>; <br>                                                    <span class="hljs-comment">//只要有人投赞成票，则 sum加1</span><br>              <span class="hljs-keyword">if</span>(sum[<span class="hljs-number">2</span>])     pass = <span class="hljs-number">1</span>;  <span class="hljs-comment">//若超过4人赞成，则表决通过else                 pass = 0;</span><br>         <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br><br><br></code></pre></div></td></tr></table></figure><p>[例] 用for语句初始化memory。</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><br><span class="hljs-keyword">begin</span>:init_mem <br>    <span class="hljs-keyword">reg</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] tempi;      <span class="hljs-comment">//存储器的地址变量</span><br>    <span class="hljs-keyword">for</span>(tempi = <span class="hljs-number">0</span>;tempi&lt;memsize;tempi = tempi+<span class="hljs-number">1</span>)<br>        memory[tempi] = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">end</span><br><br></code></pre></div></td></tr></table></figure><p>注：当执行语句有多条时，可用begin_end语句将其括起来！</p><ol start="2"><li>while 语句</li></ol><ul><li>有条件地执行一条或多条语句。</li><li>首先判断循环执行条件表达式是否为真。若为真，则执行后面的语句或语句块；然后再回头判断循环执行条件表达式是否为真，若为真，再执行一次后面的语句；如此不断，直到条件表达式不为真。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">while</span> （循环执行条件表达式）语句<br><span class="hljs-comment">//或</span><br><span class="hljs-keyword">while</span> （循环执行条件表达式）<br>  <span class="hljs-keyword">begin</span><br>    ……<br>   <span class="hljs-keyword">end</span><br><br></code></pre></div></td></tr></table></figure><p>注1：首先判断循环执行条件表达式是否为真，若不为真，则其后的语句一次也不被执行！<br>注2：在执行语句中，必须有一条改变循环执行条件表达式的值的语句！<br>注3：while语句只有当循环块有事件控制（即@（posedge clock））时才可综合！</p><h3 id="结构说明语句"><a href="#结构说明语句" class="headerlink" title="结构说明语句"></a>结构说明语句</h3><ul><li>initial说明语句——只执行一次</li><li>always说明语句——不断重复执行，直到仿真结束</li><li>task说明语句——可在程序模块中的一处或多处调用</li><li>function说明语句——可在程序模块中的一处或多处调用</li></ul><ol><li>always 块语句</li></ol><p>包含一个或一个以上的声明语句(如:过程赋值语句、任务调用、条件语句和循环语句等），在仿真运行的全过程中，在定时控制下被反复执行。</p><ul><li>在always块中被赋值的只能是register型变量（如reg，integer，real，time）。</li><li>每个always块在仿真一开始便开始执行，当执行完块中最后一个语句，继续从always块的开头执行。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> &lt;时序控制&gt; &lt;语句&gt;<br></code></pre></div></td></tr></table></figure><p>注1：如果always块中包含一个以上的语句，则这些语句必须放在begin_end或fork_join块中！</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clk <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> clear)<br>   <span class="hljs-keyword">begin</span><br>       <span class="hljs-keyword">if</span>(!clear)  qout = <span class="hljs-number">0</span>;   <span class="hljs-comment">//异步清零</span><br>       <span class="hljs-keyword">else</span>           qout = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">end</span>  <br><br></code></pre></div></td></tr></table></figure><p>注2：always语句必须与一定的时序控制结合在一起才有用！如果没有时序控制，则易形成仿真死锁！</p><p>always块语句模板</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (&lt;敏感信号表达式&gt;) <br>  <span class="hljs-keyword">begin</span><br>    <span class="hljs-comment">// 过程赋值语句</span><br>    <span class="hljs-comment">// if语句</span><br>    <span class="hljs-comment">// case语句</span><br>    <span class="hljs-comment">// while，repeat，for循环</span><br>    <span class="hljs-comment">// task，function调用    </span><br>  <span class="hljs-keyword">end</span><br><br><br></code></pre></div></td></tr></table></figure><ul><li>敏感信号表达式又称事件表达式或敏感表，当其值改变时，则执行一遍块内语句；</li><li>在敏感信号表达式中应列出影响块内取值的所有信号!</li><li>敏感信号可以为单个信号，也可为多个信号，中间需用关键字or连接！</li><li>敏感信号不要为x或z，否则会阻挡进程！</li><li>always的时间控制可以为沿触发，也可为电平触发。</li><li>关键字posedge表示上升沿；negedge表示下降沿。</li></ul><p>由两个沿触发的always 块：常用于描述时序逻辑</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@ (<span class="hljs-keyword">posedge</span> clock <span class="hljs-keyword">or</span> <span class="hljs-keyword">posedge</span> reset)<br>   <span class="hljs-keyword">begin</span><br>        …… <br>   <span class="hljs-keyword">end</span><br><br></code></pre></div></td></tr></table></figure><p>由多个电平触发的always 块：常用于描述组合逻辑</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@ (a <span class="hljs-keyword">or</span> b <span class="hljs-keyword">or</span> c)<br>   <span class="hljs-keyword">begin</span><br>        …… <br>   <span class="hljs-keyword">end</span><br><br></code></pre></div></td></tr></table></figure><p>always块语句是用于综合过程的最有用的语句之一，但又常常是不可综合的。为得到最好的综合结果， always块程序应严格按以下模板来编写：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (Inputs) <span class="hljs-comment">//所有输入信号必须列出，用or隔开</span><br>   <span class="hljs-keyword">begin</span><br>       ……                 <span class="hljs-comment">//组合逻辑关系</span><br>   <span class="hljs-keyword">end</span>  <br><br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (Inputs) <span class="hljs-comment">//所有输入信号必须列出，用or隔开</span><br>   <span class="hljs-keyword">if</span> (Enable) <br>      <span class="hljs-keyword">begin</span><br>        ……                 <span class="hljs-comment">//锁存动作</span><br>      <span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> Clock)  <span class="hljs-comment">// Clock only</span><br>   <span class="hljs-keyword">begin</span><br>       ……                               <span class="hljs-comment">// 同步动作</span><br>   <span class="hljs-keyword">end</span>  <br></code></pre></div></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> Clock <span class="hljs-keyword">or</span> <span class="hljs-keyword">negedge</span> Reset)<br><span class="hljs-comment">// Clock and Reset only</span><br>   <span class="hljs-keyword">begin</span><br>       <span class="hljs-keyword">if</span> (! Reset)            <span class="hljs-comment">// 测试异步复位电平是否有效</span><br>           ……                  <span class="hljs-comment">// 异步动作</span><br>       <span class="hljs-keyword">else</span><br>           ……                 <span class="hljs-comment">// 同步动作</span><br>   <span class="hljs-keyword">end</span>                           <span class="hljs-comment">// 可产生触发器和组合逻辑</span><br><br></code></pre></div></td></tr></table></figure><p>（1）当always块有多个敏感信号时，一定要采用if - else if语句，而不能采用并列的if语句！否则易造成一个寄存器有多个时钟驱动，将出现编译错误。<br> （2）通常采用异步清零！只有在时钟周期很小或清零信号为电平信号时（容易捕捉到清零信号）采用同步清零。</p><ol start="2"><li>initial 语句</li></ol><p>格式：</p><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span><br> <span class="hljs-keyword">begin</span><br>   语句<span class="hljs-number">1</span>；<br>   语句<span class="hljs-number">2</span>；<br>   ……<br>   语句n；<br>  <span class="hljs-keyword">end</span><br><br></code></pre></div></td></tr></table></figure><p>用途：</p><ul><li>在仿真的初始状态对各变量进行初始化；</li><li>在测试文件中生成激励波形作为电路的仿真信号。</li></ul><h2 id="一些Verilog程序"><a href="#一些Verilog程序" class="headerlink" title="一些Verilog程序"></a>一些Verilog程序</h2><figure class="highlight verilog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs verilog"><span class="hljs-comment">//计算rega中1的个数</span><br><span class="hljs-keyword">module</span> count1s_for_good(count,rega);<br>    <span class="hljs-keyword">output</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count;<br>    <span class="hljs-keyword">input</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] rega;<br>    <span class="hljs-keyword">reg</span>[<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count;<br>    <span class="hljs-keyword">always</span> @ (rega)<br>    <span class="hljs-keyword">begin</span>:<br>        block<br>        <span class="hljs-keyword">integer</span> i;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">7</span>;i=i+<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">if</span>(rega[i] == <span class="hljs-number">1</span>)<br>                count = count +<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Verilog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字信号处理</title>
    <link href="/archives/ddac2bd0.html"/>
    <url>/archives/ddac2bd0.html</url>
    
    <content type="html"><![CDATA[<p>这门课我学半个学期了，老师还没留过作业。感觉这会是我挂的第一科。</p><span id="more"></span><h1 id="数字信号处理"><a href="#数字信号处理" class="headerlink" title="数字信号处理"></a>数字信号处理</h1><h2 id="时域数字信号处理"><a href="#时域数字信号处理" class="headerlink" title="时域数字信号处理"></a>时域数字信号处理</h2><h3 id="信号的基本概念"><a href="#信号的基本概念" class="headerlink" title="信号的基本概念"></a>信号的基本概念</h3><p>信号：一个（一维或多维）的数据量。</p><h3 id="从模拟信号到数字信号"><a href="#从模拟信号到数字信号" class="headerlink" title="从模拟信号到数字信号"></a>从模拟信号到数字信号</h3><p><strong>信号的分类</strong>：</p><ul><li>模拟信号<br>X,Y轴都是连续值的信号，来自外界收集和用于设备交互</li><li>数字信号<br>X,Y轴都是离散值的信号，用于DSP高速，便捷处理</li><li>量化信号<br>Y轴是离散值的信号，进行过Y轴数据编码，提高数据处理能力，抗噪等</li><li>离散信号<br>X轴是离散值的信号，由采样生成，是DSP的核心内容</li></ul><p><strong>数字信号的特点</strong>：</p><ul><li>抗干扰能力强</li><li>功耗低</li><li>电路设计简单，集成度高</li><li>后期处理方便</li></ul><h3 id="DSP的常见应用"><a href="#DSP的常见应用" class="headerlink" title="DSP的常见应用"></a>DSP的常见应用</h3><p><strong>DSP应用范例</strong>：</p><ul><li>离散多音调传输</li><li>行动电话</li><li>数字声音合成</li><li>信号编码和压缩</li><li>信号增强</li></ul><h3 id="基本信号与基本算法"><a href="#基本信号与基本算法" class="headerlink" title="基本信号与基本算法"></a>基本信号与基本算法</h3><p>连续信号的表示 $f(t)$</p><p>离散信号的表示 $x[n]$</p><p>基本处理办法</p><p>多信号处理：加法，数乘<br>单一信号处理：补零，时移，反折，拉伸</p><p>相对复杂处理：微分，积分，卷积，相似计算</p><h4 id="补零"><a href="#补零" class="headerlink" title="补零"></a>补零</h4><p>对于不同长度或不在统一时间范围的序列间的运算，必须先将不一致的部分序列做适当的补零运算，使这些序列拥有相同的时间n范围。</p><ul><li>补零是一个书写简单，但是编程困难的问题</li><li>补零需要改变用于存储序列的数组长度，这在大部分编程中都是较为困难的。</li><li>如何处理序列变化长度需要自行研究<br>别忘了改变序列长度后，序列时间index也要做相应处理</li></ul><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>加法运算：<br>$$f(t)=g(t)+k(t)$$<br><img src="Adder.png" alt="Adder"></p><p>加法运算的一个简单应用：去噪——总体平均</p><p>假设 $d_i$ 表示干扰原资料向量 $s$ 的第 $i$ 次量测值的噪声序列：<br>$$<br>x_i[n]=s[n]+d_i[n]<br>$$</p><p>在 $K$ 次量测后，计算一个平均数据向量，称为总体平均。</p><p>$$<br>X_{ave}=\frac{1}{K}\sum_{i=1}^{K}X_i=\frac{1}{K}\sum_{i=1}^K(s+d_i)=S+\frac{1}{K}\sum_{i=1}^Kd_i<br>$$</p><p>从噪音定义可以知道， $\sum_{i=1}^Kd_i\approx 0$ 。<br>对于一个非常大的 $K$ 值而言， $X_{ave}$ 通常相当程度近似于原资料向量 $s$ 。</p><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><ol><li>数乘：<br>$$f(t)=k\cdot g(t)$$</li></ol><p><img src="ddac2bd0/Multiplier.png" alt="Multiplier"></p><p>乘法运算：放大器。</p><ul><li>现实中的放大器往往也会将噪声等干扰一起放大，所以通常和其他处理配套使用。</li><li>放大器需要引入能量，在电路设计中通常代表需要提供新的能量源（功率放大器—功放）</li></ul><ol start="2"><li>两个信号相乘</li></ol><p>乘积 (调变，modulation) 运算:</p><p>$$f(t)=k(t)\cdot g(t)$$<br><img src="ddac2bd0/Modulator.png" alt="Modulator"></p><ul><li>乘法在DSP中有着特殊的作用，通常表明的某种操作。</li><li>文字描述操作是无法量化计算的，例如屏蔽某频率的信号；放大某些局部信息；对当前时间点的信号，做延时间轴的弱化扩散处理</li><li>方法：将要实施的处理，转化成一个特定的信号，然后做乘法<ul><li>以及乘法后的加法和滑动窗处理，三个处理组成最核心的卷积运算。</li></ul></li></ul><p>很多情况下，乘法的运算其中一方是特意设计的，表明某个效果的操作</p><p>应用：遮罩。</p><h4 id="时移"><a href="#时移" class="headerlink" title="时移"></a>时移</h4><p>时间位移运算：时移时一个单一信号的处理方法。<br>$$<br>g(t)=f(t-t_0)<br>$$<br>离散格式 $y(n)=x(n-N)$ 其中 $N$ 是一个整数。</p><p>若 $N&gt;0$ ，称之为延迟运算：<br><img src="ddac2bd0/Unit%20delay.png" alt="Unit delay"></p><p>若 $N&lt;0$ ，则称之为超前运算。<br><img src="ddac2bd0/Unit%20advance.png" alt="Unit advance"></p><p>计算方法：</p><ul><li>平移法</li><li>罗列计算法</li></ul><p>应用：</p><ul><li>主动发射信号，并接受： 激光定位，激光扫描距离 = 延迟时间*速度/2</li><li>被动接受信号，并不进行发射:GPS</li></ul><h4 id="反折"><a href="#反折" class="headerlink" title="反折"></a>反折</h4><p>时间反向或是折叠运算<br>$$<br>g(t)=f(-t)<br>$$<br>离散格式 $y[n]=x[-n]$</p><h4 id="时域尺度变换（拉伸）"><a href="#时域尺度变换（拉伸）" class="headerlink" title="时域尺度变换（拉伸）"></a>时域尺度变换（拉伸）</h4><p>拉伸运算：  。<br>离散格式：  。<br>拉伸变化我们称为采样率（上采样和下采样）的变化，其中  通常采取以下定义：</p><ul><li>若  ，则  通常为正数，即  。</li><li>若  ，则通常找到一个正整数  ，使得  。</li><li>若  ，则先处理  ，然后再做反折。</li><li>通常对于复杂的变化，定义二次采样（采样率变化），不在拉伸部分讨论，把它单独作为一个系统。</li></ul><h4 id="时域尺度变换（上采样）"><a href="#时域尺度变换（上采样）" class="headerlink" title="时域尺度变换（上采样）"></a>时域尺度变换（上采样）</h4><p>若以整数因子$L&gt;1$来进行上采样，计算公式见下图。</p><ul><li>除法是上采样，越除得到的数列越长。而“上”采样的上字与长短对应，上采样变长。</li><li>对于$x[0.5]$之类的index不为整数的项，我们直接定义其为0</li><li>为0的部分，通常通过内插算法（interpolation）后续将其补上</li><li>在上述计算中，仍然左右不变的是$n$项，可以使用列举法进行计算。</li></ul><p><img src="ddac2bd0/%E4%B8%8A%E9%87%87%E6%A0%B7.png"></p><h4 id="时域尺度变换（下采样）"><a href="#时域尺度变换（下采样）" class="headerlink" title="时域尺度变换（下采样）"></a>时域尺度变换（下采样）</h4><p>若以整数因子M&gt;1来进行下采样，计算公式见下图。</p><ul><li>乘法是下采样，越除得到的数列越短。“下”采样的序列变短。</li><li>下采样不会产生新的项。</li><li>在上述计算中，仍然左右不变的是 $n$ 项，可以使用列举法进行计算</li></ul><p><img src="ddac2bd0/%E4%B8%8B%E9%87%87%E6%A0%B7.png"></p><h4 id="时域尺度变换9-双向拉伸"><a href="#时域尺度变换9-双向拉伸" class="headerlink" title="时域尺度变换9 双向拉伸"></a>时域尺度变换9 双向拉伸</h4><h4 id="内插"><a href="#内插" class="headerlink" title="内插"></a>内插</h4><h3 id="相对复杂的基本运算"><a href="#相对复杂的基本运算" class="headerlink" title="相对复杂的基本运算"></a>相对复杂的基本运算</h3><h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><p>差分： $x^{\prime}[n]=x[n+1]-x[n]$ </p><p>二阶差分： $x^{\prime \prime}[n]=x[n+2]+x[n]-2x[n+1]$ </p><h4 id="累加"><a href="#累加" class="headerlink" title="累加"></a>累加</h4><p>累加： $g(n)=\sum_{a}^{b}x[n]$ </p><h4 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h4><p>卷积是整个数字信号处理中最重要的运算。</p><ul><li>我们所学的基础处理整合起来称为“系统”</li><li>在本课程中我们只学习一种系统“线性时不变系统”</li><li>一个线性时不变系统，不管多么复杂，其都可以变成输出信号=输入信息与特定（且固定）信号的卷积<br>即：本课程的任何系统，都可以用卷积来表示和研究。S</li></ul><p>卷积分为两种：线性卷积和周期（循环）卷积</p><p>线性卷积的连续性表达式为</p><p>$$<br>F(t)=f(t)*g(t)=\int_{a}^{b}f(t-m)g(m)\mathrm{d}m<br>$$</p><p>其离散表示为</p><p>$$<br>y[n]=x[n]*h[n]=\sum_{k=-\infty}^{\infty}x[n-k]h[k]<br>$$<br>运算的基本流程：</p><ul><li>将 $h[n]$ 反转，作为滑动窗</li><li>窗口内处理 $h[n]$ ，并进行对位相乘后求和</li><li>将滑动窗从 $x[n]$ 最左侧一直移动到最右侧</li></ul><p>快速卷积说明</p><ul><li>所谓的快速卷积只是给人类手动算卷积准备的<br>节省的时间是不需要处理边缘效果的那几次滑动</li><li>当窗口很大时，节省的时间微乎其微<br>手动编写感受</li><li>所以计算机并不使用快速卷积<br>计算机使用转频域-&gt; 算乘法-&gt;转回时域的方法</li><li>这个需要循环卷积</li></ul><h4 id="讯号的相关性"><a href="#讯号的相关性" class="headerlink" title="讯号的相关性"></a>讯号的相关性</h4><p>互相关序列：两个能量讯号 $x[n]$ 及 $y[n]$ 彼此间的相似度可利用以下定义的互相关序列来量度。</p><p>相关性计算和卷积相似，但没有反转。</p><p>相关性中平移的意义：</p><ul><li>参数 $l$ 表示的是将序列 $y[n]$ 作相应的延迟后，对位相乘做加法。</li><li>按照滑动窗的解释， $r_{xy}[l]$ 中的 $l$ 表示的是，对于滑动窗每个滑动距离的结果上的记录。</li></ul><p>相关系数：</p><p>正规化：对一个向量 $A=\{ A_i \}$ ，正规化<br>$$<br>K=\sqrt{\sum A_i^2}\cdot A_i^{\prime}=\frac{A_i}{K}<br>$$<br>$$<br>\sum A_i^{\prime 2}=\sum \frac{A_i^2}{K^2}=\frac{\sqrt{\sum A_i^2}}{\sum A_i^2=1}<br>$$<br>平方和为 $1$ ，称 $A_i^{\prime}$ 为 $A$ 的一种正规化结果。</p><ul><li><p>将向量至于一个单位圆内（即一个单位下），以便进行后期的比较等运算</p></li><li><p>例子：当我们观察信号 A={3,4,5,5,5} 与信号B={-5,-8,-10,-9,-10}时，<br>由于放大器(K=-2)和噪声(Noise={1,0,0,1,0})的共同影响，不一定可以准确的观测到其关系，进行正规化以后<br>A’={0.3,    0.4,    0.5,   0.5,    0.5} 与<br>B’={-0.26,-0.42,-0.52,-0.47,-0.52}的相似度就足够高了</p></li></ul><p>零均值：对一个向量 $A$ ，零均值<br>则有<br>$$<br>\overline{A}=\frac{1}{N}\sum A_i,A_i^{\prime}=A-i-\overline{A}<br>$$<br> $A_i^{\prime}$ 满足<br>$$<br>\sum A_i^{\prime}=\sum (A_i-\overline{A})=0<br>$$<br>称 $A_i^{\prime}$ 为 $A$ 的一种零均值。</p><ul><li>例子，当我们观察信号 A={3,-4,2,5,-7} 与信号B={4,-2,5,7,-5}时，<br>由于叠加信号（D={2,2,2,2,2}和叠加噪声(Noise={-1,0,1,0,0})）的共同影响，不一定可以准确的观测到其关系，进行零均值化以后<br>A’={3.2, -3.8,2.2,5.2,6.8} 与 B’={2.2,-3.8,3.2,5.2,-6.8}的相似度就足够高了</li></ul><p>再看相关系数的定义，令 $A_i$ 零均值变化后为 $A_i^{\prime}$<br>$$<br>\mathrm{Corr}=\sum_{i}\frac{(A_i^{\prime}\cdot B_i^{\prime})}{\sqrt{\sum_{i}(A_i^{\prime})^2\sum_{i}(B_i^{\prime})^2}}=\sum_{i}\overline{A_i^{\prime}}\cdot \overline{B_i^{\prime}}<br>$$<br>在令 $\hat{A_i^{\prime}}$ 为正规化的 $A_i^{\prime}$</p><p>$$<br>\mathrm{Corr}=\sum_{i}\hat{A_i^{\prime}}\hat{B_i^{\prime}}<br>$$</p><ul><li>相似度绝对值 $0\leq |\mathrm{Corr}| \leq 1$ 。</li><li>两个向量的相似度与符号无关，有绝对值决定。</li><li>若 $|\mathrm{Corr}|=1$ 则两个向量相同（反向），相似度最高。</li><li>若 $|\mathrm{Corr}|=0$ 则两个信号完全无关（向量正交），相似度最低。</li></ul><p>相关性一般只出现在DSP，相关系数应用广泛。</p><p>不做零均值和正规化的缺点：</p><ul><li>不做正规化，没有基准，两个向量相似度位于  ，对放大不免疫。</li><li>因为没有零均值，对任何叠加都不免疫。</li></ul><p>如果我们希望 $y[n]$ 当做参考信号，将 $x[n]$ 相对于 $y[n]$ 产生位移，则互相关序列可改写为<br>$$<br>r_{yx}[\mathcal{l}]=r_{xy}[\mathcal{-l}]<br>$$<br>因此，将 $r_{xy}[\mathcal{l}]$ 作时间反向可以得到 $r_{yx}[\mathcal{l}]$ 。</p><p>在互相关序列 $r_{xy}[\mathcal{l}]$ 的公式中设定 $y[n]=x[n]$ ，则 $x[n]$ 的自相关序列可得到：<br>$$<br>r_{xx}[\mathcal{l}]=\sum_{n=-\infty}^{\infty}x[n]x[n-\mathcal{l}]<br>$$<br>$$<br>r_{xx}[0]=\sum_{n=-\infty}^{\infty}x^2[n]=\mathcal{E}_x<br>$$</p><h3 id="信号分类"><a href="#信号分类" class="headerlink" title="信号分类"></a>信号分类</h3><ul><li>连续信号与离散信号</li><li>确定信号与随机信号</li><li>周期信号与非周期信号</li><li>功率信号与能量信号</li></ul><p>确定信号与随机信号：</p><ul><li>确定信号多为我们需要研究的对象<br>此处的确定信号实际上有两种，一种是可以使用公式表示的（这是我们后面本节课要学习的）；另一种确实无法公式表示（如某人的语音输入，却是确定的）</li><li>随机信号在我们这节课的研究中，多为干扰噪音</li><li>所以：评估一个信号是确定信号还是随机信号，不是看是否公式表示，而是讨论其是否具有实际意义。</li></ul><p>周期信号与非周期信号：</p><ul><li>周期信号可以用一个周期函数表示。且周期信号是DSP学习中最重要的2-3种信号之一：<ul><li>DSP研究的是时间轴上的信号变化，那么周期函数（信号）是最容易研究的—周期信号是最简单且“优美”的信号。</li><li>当我们把一个函数变成多个函数的表示，那么周期函数就可以被当做工具（分解的概念）</li><li>例：使用周期信号分析任意一个信号：方波信号</li></ul></li></ul><p>定义：</p><ul><li>对于连续函数（信号）的周期，我们有时  ，  为周期，通常  可以为任意值，而  为任意整数。</li><li>离散信号：满足  的序列，被称为具有周期  的周期序列，其中  是一个正整数，而  是任意整数。</li><li>满足  的最小  值称为基本周期。</li></ul><h3 id="基本信号"><a href="#基本信号" class="headerlink" title="基本信号"></a>基本信号</h3>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>数字信号</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字信号处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率论</title>
    <link href="/archives/155618b9.html"/>
    <url>/archives/155618b9.html</url>
    
    <content type="html"><![CDATA[<p>概率论的重要性就不用说了吧。</p><span id="more"></span><h1 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h1><h2 id="概率论的基本概念"><a href="#概率论的基本概念" class="headerlink" title="概率论的基本概念"></a>概率论的基本概念</h2><h3 id="随机试验，样本空间，随机事件"><a href="#随机试验，样本空间，随机事件" class="headerlink" title="随机试验，样本空间，随机事件"></a>随机试验，样本空间，随机事件</h3><p><strong>随机试验</strong>：满足相同条件下可重复，能事先明确试验所有可能结果，在一次试验前无法确定哪一个结果出现的试验称为随机试验。</p><p><strong>样本空间</strong>：将随机试验 $E$ 的所有可能结果组成的集合称为 $E$ 的样本空间。 $E$ 的每个结果称为样本点。</p><p><strong>随机事件</strong>：称试验 $E$ 的样本空间 $S$ 的子集为 $E$ 的随机事件。</p><p>和事件，积事件，差时间，互斥事件与对立事件</p><p>交换律，结合律，分配律，德摩根律</p><h3 id="频率与概率"><a href="#频率与概率" class="headerlink" title="频率与概率"></a>频率与概率</h3><p><strong>频率</strong>：相同条件下，进行了 $n$ 次试验，事件 $A$ 发生的次数 $n_A$ 称为事件 $A$ 发生的频数，比值 $\frac{n_A}{n}$ 称为事件 $A$ 发生的频率，记为 $f_{n}(A)$ 。</p><p><strong>概率</strong>：设 $E$ 是随机事件， $S$ 是它的样本空间。对于 $E$ 的每一个事件 $A$ 赋予一个实数，记为 $P(A)$ ，称为事件 $A$ 的概率，如果集合函数 $P(\cdot)$ 满足以下条件：</p><p>（1）非负性：对于每个事件 $A$ ，有 $P(A)\geq 0$ 。</p><p>（2）规范性：对于必然事件 $S$ ，有 $P(S)=1$ 。</p><p>（3）可列可加性：设 $A_1,A_2,\cdots$ 是两两不相容的事件，即对于 $A_{i}A_{j}=\emptyset ,i\neq j,i,j=1,2,\cdots$ ，有<br>$$<br>P(A_1\cup A_2\cup \cdots)=P(A_1)+P(A_2)+\cdots<br>$$</p><p>加法公式：对于任意两事件 $A,B$ 有</p><p>$$<br>P(A\cup B)=P(A)+P(B)-P(AB)<br>$$</p><h3 id="古典概型"><a href="#古典概型" class="headerlink" title="古典概型"></a>古典概型</h3><p>当随机试验满足样本空间内只有有限个元素，且每个基本事件发生的可能性相同，则称为<strong>等可能概型</strong>，又称<strong>古典概型</strong>。</p><p>超几何分布</p><h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><p><strong>条件概率</strong>：设 $A,B$ 是两个事件，且 $P(A)&gt;0$ ，称</p><p>$$<br>P(B|A)=\dfrac{P(AB)}{P(A)}<br>$$</p><p>为在事件 $A$ 发生的条件下事件 $B$ 发生的条件概率。</p><p><strong>乘法定理</strong>：设 $P(A)&gt;0$ ，则有 $P(AB)=P(B|A)P(A)$ 。</p><p>乘法定理可以推广到多个事件的积事件的情况。</p><p><strong>全概率公式</strong>：设试验 $E$ 的样本空间为 $S$ ， $A$ 为 $E$ 的事件， $B_1,B_2,\cdots ,B_n$ 为 $S$ 的一个划分，且 $P(B_i)&gt;0\quad (i=1,2,\cdots ,n)$ ，则<br>$$<br>P(A) = P(A|B_1)P(B_1)+P(A|B_2)P(B_2) + \cdots + P(A|B_n)P(B_n)<br>$$</p><p><strong>贝叶斯公式</strong>：设试验 $E$ 的样本空间为 $S$ ， $A$ 为 $E$ 的事件， $B_1,B_2,\cdots ,B_n$ 为 $S$ 的一个划分，且 $P(A)&gt;0,P(B_i)&gt;0\quad (i=1,2,\cdots ,n)$ ，则<br>$$<br>P(B_i|A)=\dfrac{P(A|B_i)P(B_i)}{\displaystyle\sum_{j=1}^{n}{P(A|B_j)P(B_j)}},i=1,2,\cdots,n<br>$$</p><p>其中 $P(B_i)$ 称为先验概率， $P(B_i|A)$ 称为后验概率， $P(A|B_i)$ 称为似然概率。</p><h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><p>独立：设 $A,B$ 是两事件，如果满足等式 $P(AB)=P(A)P(B)$ ，则称事件 $A,B$ 相互独立。简称 $A,B$ 独立。</p><p>设 $A,B$ 是两事件，且 $P(A)&gt;0$ 。若 $A,B$ 相互独立，则 $P(B|A)=P(B)$ 。反之亦然。</p><p>若事件 $A$ 与 $B$ 相互独立，则下边各对事件也相互独立：</p><p>$$<br>A\text{与} \overline{B} \quad \overline{A}\text{与} {B} \quad \overline{A}\text{与} \overline{B}<br>$$</p><p>一般的，设 $A_1,A_2,\cdots,A_n$ 是 $n$ 个事件，如果对于其中任意2个，任意3个，···，任意 $n$ 个事件的积事件的概率，都等于各事件概率之积，则称事件 $A_1,A_2,\cdots,A_n$ <strong>相互独立</strong>。</p><h2 id="随机变量及其分布"><a href="#随机变量及其分布" class="headerlink" title="随机变量及其分布"></a>随机变量及其分布</h2><h3 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h3><p>随机变量：设随机试验的样本空间为 $S=\{ e \}$ 。 $X=X(e)$ 是定义在样本空间 $S$ 上的实值单值函数。称 $X=X(e)$ 为随机变量。</p><h3 id="离散型随机变量及其分布律"><a href="#离散型随机变量及其分布律" class="headerlink" title="离散型随机变量及其分布律"></a>离散型随机变量及其分布律</h3><p>离散型随机变量：有些随机变量，它全部可能取到的值为有限个或可列的无限多个，这种随机变量称为离散型随机变量。</p><p>离散型随机变量的分布律</p><p>一：两点分布</p><p>设随机变量 $X$ 只可能取0与1两个值，它的分布律是<br>$$P\{X=k\}=p^k(1-p)^{1-k},k=0,1 (0&lt;p&lt;1)$$<br>则称 $X$ 服从以 $p$ 为参数的 $(0-1)$ 分布或两点分布。</p><p>二：二项分布</p><p>设试验 $E$ 只有两个可能结果： $A$ 和 $\overline{A}$ ，则称 $E$ 为伯努利试验。设 $P(A)=p(0&lt;p&lt;1)$ ，此时 $P(\overline{A})=1-p$ 。将 $E$ 独立重复地进行 $n$ 次，称这串试验为 $n$ 重伯努利试验。</p><p>以 $X$ 表示 $n$ 重伯努利试验中事件 $A$ 发生的次数， $X$ 是一个随机变量，分布律为<br>$$P\{ X=k \}=\binom{n}{k}p^k(1-p)^{n-k},k=0,1,2,\cdots,n$$<br>称随机变量 $X$ 服从参数为 $n,p$ 的二项分布，记为 $X\sim b(n,p)$ 。</p><p>三：泊松分布</p><p>设随机变量 $X$ 所有可能取的值为 $0,1,2,\cdots$ ，而取各个值的概率为</p><p>其中 $\lambda &gt;0$ 是常数。则称 $X$ 服从参数 $\lambda$ 的泊松分布，记为 $X\sim \pi(\lambda)$ 。</p><p>泊松定理：设 $\lambda &gt;0$ 是一个常数， $n$ 是任意正整数，设 $np_{n}=\lambda$ ，则对于任一固定的非负整数 $k$ ，有<br>$$\lim_{n\to \infty}{\binom {n}{k}p^{k}_{n}(1-p_n)^{n-k}=\dfrac{\lambda^ke^{-\lambda}}{k!}}$$</p><h3 id="随机变量的分布函数"><a href="#随机变量的分布函数" class="headerlink" title="随机变量的分布函数"></a>随机变量的分布函数</h3><p>分布函数：设 $X$ 是一个随机变量， $x$ 是任意实数，函数<br>$$F(x)=P\{x\leq x\},-\infty&lt;x&lt;\infty$$<br>称为 $X$ 的分布函数。</p><h3 id="连续型随机变量及其概率密度"><a href="#连续型随机变量及其概率密度" class="headerlink" title="连续型随机变量及其概率密度"></a>连续型随机变量及其概率密度</h3><p>连续型随机变量：如果对于随机变量 $X$ 的分布函数 $F(x)$ ，存在非负可积函数 $f(x)$ ，使对于任意实数 $x$ 有<br>$$F(x)=\int_{-\infty}^{x}f(t)\mathrm{d}t$$<br>则称 $X$ 为连续型随机变量， $f(x)$ 称为 $X$ 的概率密度函数，简称概率密度。</p><p>一：均匀分布</p><p>若连续型随机变量 $X$ 具有概率密度<br>$$f(x)=\begin{cases}\dfrac{1}{b-a},a&lt;x&lt;b\\ 0,\text{其他}\end{cases}$$<br>则称 $X$ 在区间 $(a,b)$ 上服从均匀分布，记为 $X\sim U(a,b)$ 。</p><p>二：指数分布</p><p>若连续型随机变量 $X$ 的概率密度为<br>$$f(x)=\begin{cases}\dfrac{1}{\theta}e^{-\frac{x}{\theta}},x&gt;0<br>\\ 0,\text{其他}\end{cases}$$<br>其中 $\theta&gt;0$ 为常数，则称 $X$ 服从参数为 $\theta$ 指数分布。</p><p>指数分布具有无记忆性。</p><p>三：正态分布</p><p>若连续型随机变量 $X$ 的概率密度为<br>$$f(x)=\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\dfrac{(x-\mu)^2}{2\sigma^2}},-\infty&lt;x&lt;+\infty$$<br>其中 $\mu ,\sigma$ 为常数，则称 $X$ 服从参数为 $\mu ,\sigma$ 的正态分布或高斯分布，记为 $X\sim N(\mu,\sigma)$ 。</p><ol><li>曲线关于 $x=\mu$ 对称，这表明对于任意 $h&gt;0$ 有<br>$$P\{ \mu -h&lt;X\leq \mu \}=P\{ \mu&lt;X\leq \mu +h \}$$</li><li>当 $x=\mu $ 时取到最大值<br>$$f(\mu)=\dfrac{1}{\sqrt{2\pi}\sigma}$$</li></ol><p>特别的，当 $\mu =0,\sigma =1$ 时，称随机变量 $X$ 服从标准正态分布。其概率密度和分布密度分别用 $\varphi ,\varPhi$ 表示，即有<br>$$\varphi(x)=\dfrac{1}{\sqrt{2\pi}}\mathrm{e}^{-\frac{x^2}{2}}$$<br>$$<br>\varPhi(x)=\dfrac{1}{\sqrt{2\pi}}\int_{-\infty}^{x}\mathrm{e}^{-\frac{t^2}{2}}\mathrm{d}t<br>$$</p><p>易知 $\varPhi(-x)=1-\varPhi(x)$ 。</p><p>引理：若 $X\sim N(\mu,\sigma ^2)$ ，则 $Z=\dfrac{X-\mu}{\sigma}\sim N(0,1)$ 。</p><h3 id="随机变量的函数的分布"><a href="#随机变量的函数的分布" class="headerlink" title="随机变量的函数的分布"></a>随机变量的函数的分布</h3><p>定理：设随机变量 $X$ 具有概率密度 $f_X(x),-\infty &lt; x&lt;\infty $ ，又设函数 $g(x)$ 处处可导且恒有 $g^{\prime}(x)&gt;0$ （或恒有 $g^{\prime}(x)&lt;0$ ），则 $Y=g(X)$ 是连续型随机变量，其概率密度为<br>$$<br>f_Y(y)=\begin{cases}<br>f_X[h(y)]|h^{\prime}(y)|,\alpha&lt;y&lt;\beta \\ 0,\text{其他}<br>\end{cases}<br>$$<br>其中 $\alpha =\min\{ g(-\infty),g(\infty) \}$ ， $\beta =\max\{ g(-\infty),g(\infty) \}$ ， $h(y)$ 是 $g(x)$ 的反函数。</p><h2 id="多维随机变量及其分布"><a href="#多维随机变量及其分布" class="headerlink" title="多维随机变量及其分布"></a>多维随机变量及其分布</h2><h3 id="二维随机变量"><a href="#二维随机变量" class="headerlink" title="二维随机变量"></a>二维随机变量</h3><p>二维随机变量：一般的，设 $E$ 是一个随机试验，它的样本空间是 $S=\{ e \}$ ，设 $X=X(e)$ 和 $Y=Y(e)$ 是定义在 $S$ 上的随机变量，由它们构成的一个向量 $(X,Y)$ ，叫做二维随机向量或二维随机变量。</p><p>定义：设 $(X,Y)$ 是二维随机变量，对于任意实数 $x,y$ ，二元函数：<br>$$<br>F(x,y)=P\{ (X\leq x)\cap (Y \leq y) \}=P\{ X\leq x,Y\leq y \}<br>$$<br>称为二维随机变量 $(X,Y)$ 的分布函数，或称为随机变量 $X$ 和 $Y$ 的联合分布函数。</p><p>分布函数 $F(x,y)$ 具有以下基本性质：</p><ol><li> $F(x,y)$ 是变量 $x$ 和 $y$ 的不减函数，即对于任意固定的 $y$ ，当 $x_2&gt;x_1$ 时 $F(x_2,y)\geq F(x_1,y)$ ；对于任意固定的 $x$ ，当 $y_2&gt;y_1$ 时 $F(x,y_2)\geq F(x,y_1)$ 。</li><li> $0\leq F(x,y)\leq 1$ ，且对于任意固定的 $y$ ， $F(-\infty ,y)=0$ 。对于任意固定的 $x$ ， $F(x,-\infty)=0$ 。 $F(-\infty,-\infty)=0$ ， $F(\infty ,\infty)=1$ 。</li><li> $F(x+0,y)=F(x,y)$ ， $F(x,y+0)=F(x,y)$ ，即 $F(x,y)$ 关于 $x$ 右连续，关于 $y$ 也右连续。</li><li>对于任意 $(x_1,y_1)$ ， $(x_2,y_2)$ ， $x_1&lt;x_2$ ， $y_1&lt;y_2$ ，下述不等式成立：<br>$$F(x_2,y_2)-F(x_2,y_1)+F(x_1,y_1)-F(x_1,y_2)\geq 0$$</li></ol><p>如果二维随机变量 $(X,Y)$ 全部可能取到的值是有限对或可列无限多对，则称 $(X,Y)$ 是离散型的随机变量。</p><p>分布律：设二维随机变量 $(X,Y)$ 所有可能取的值为 $(x_i,y_j),i,j=1,2.\cdots$ ，记 $P\{ X=x_i,Y=y_i \}=p_{ij},i,j=1,2,\cdots$ ，则由概率的定义有<br>$$<br>p_{ij}\geq 0,\sum_{i=1}^{\infty}\sum_{j=1}^{\infty}p_{ij}=1<br>$$<br>我们称 $P\{ X=x_i,Y=y_i \}=p_{ij},i,j=1,2,\cdots$ 为二维离散型随机变量 $(X,Y)$ 的分布律，或称为随机变量 $X$ 和 $Y$ 的联合分布律。</p><p>将 $(X,Y)$ 看成一个随机点的坐标，离散型随机变量 $X$ 和 $Y$ 的联合分布函数为<br>$$<br>F(x,y)=\sum_{x_i\leq x}\sum_{y_i\leq y}p_{ij}<br>$$<br>其中和式是对一切满足 $x_i\leq x,y_i\leq y$ 的 $i,j$ 来求和的。</p><p>对于二维随机变量 $(X,Y)$ 的分布函数 $F(x,y)$ ，如果存在非负的可积函数 $f(x,y)$ 使对于任意 $x,y$ 有<br>$$<br>F(x,y)=\int_{-\infty}^{y}\int_{-\infty}^{x}f(u,v)\mathrm{d}u\mathrm{d}v<br>$$<br>则称 $(X,Y)$ 是连续型的二维随机变量，函数 $f(x,y)$ 称为二维随机变量 $(X,Y)$ 的概率密度，或称为随机变量 $X$ 和 $Y$ 的联合概率密度。</p><p>概率密度 $f(x,y)$ 有以下性质：</p><ol><li> $f(x,y)\geq 0$ 。</li><li> $\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}f(x,y)\mathrm{d}x\mathrm{d}y=F(\infty,\infty)=1$ 。</li><li>设 $G$ 是 $xOy$ 平面上的区域，点 $(X,Y)$ 落在 $G$ 内的概率为：<br>$$<br>P\{ (X,Y)\in G \}=\iint_{G}f(x,y)\mathrm{d}x\mathrm{d}y<br>$$</li><li>若 $f(x,y)$ 在点 $(x,y)$ 连续，则有：<br>$$<br>\frac{\partial^2 F(x,y)}{\partial x\partial y}=f(x,y)<br>$$</li></ol><p>一般，设 $E$ 是一个随机试验，它的样本空间是 $S=\{ e \}$ ，设 $X_1=X_1(e),\cdots,X_n=X_n(e)$ 是定义在 $S$ 上的随机变量，由它们构成的一个 $n$ 维向量 $(X_1,\cdots,X_n)$ 叫做 $n$ 维随机变量。</p><p>对于任意 $n$ 个实数 $x_1,\cdots,x_n$ ， $n$ 元函数<br>$$<br>F(x_1,\cdots,x_n)=P\{ X_1\leq x_1,\cdots,X_n\leq x_n \}<br>$$<br>称为 $n$ 维随机变量 $(X_1,\cdots,X_n)$ 的分布函数或随机变量 $X_1,\cdots,X_n$ 的联合分布函数。</p><h3 id="边缘分布"><a href="#边缘分布" class="headerlink" title="边缘分布"></a>边缘分布</h3><p>边缘分布律：对于离散型随机变量 $(X,Y)$ ，记</p><p>$$<br>p_{i \cdot} =P\{X=x_i\}=\sum_{j=1}^{\infty}p_{ij} ,i = 1,2,\cdots<br>$$</p><p>$$<br>p_{\cdot j} =P\{X=x_j\}=\sum_{i=1}^{\infty}p_{ij} ,i = 1,2,\cdots<br>$$</p><p>分别称 $p_{i \cdot}$ 和 $p_{\cdot j}$ 为 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的边缘分布律。</p><p>边缘概率密度：对于连续型随机变量 $(X,Y)$ ，设它的概率密度为 $f(x,y)$ ，由于<br>$$<br>F_X(x)=F(x,\infty)=\int_{-\infty}^{x}[\int_{-\infty}^{\infty}f(x,y)\mathrm{d}y]\mathrm{d}y<br>$$<br> $X$ 是一个连续型随机变量，且其概率密度为<br>$$<br>f_X(x)=\int_{-\infty}^{\infty}f(x,y)\mathrm{d}y<br>$$</p><p> $Y$ 是一个连续型随机变量，且其概率密度为<br>$$<br>f_Y(y)=\int_{-\infty}^{\infty}f(x,y)\mathrm{d}x<br>$$</p><p> $f_X(x)$ 分别为 $f_Y(y)$ 为 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的边缘概率密度。</p><p>二维正态分布：设二维随机变量 $(X,Y)$ 的概率密度为<br>$$<br>f(x,y)=\dfrac{1}{2\pi \sigma_1 \sigma_2 \sqrt{1-\rho^2}} \exp\{ \dfrac{-1}{2(1-\rho^2)}[\dfrac{(x-\mu_1)^2}{\sigma_1 ^2}-2\rho \dfrac{(x-\mu_1)(y-\mu_2)}{\sigma_1 \sigma_2}+\dfrac{(y-\mu_2)^2}{\sigma_2 ^2}] \}<br>$$<br>其中 $\mu_1,\mu_2,\sigma_1,\sigma_2,\rho$ 都是常数，且 $\sigma_1 &gt;0,\sigma_2&gt;0,-1&lt;\rho&lt;1$ ，我们称 $(X,Y)$ 为服从参数为 $\mu_1,\mu_2,\sigma_1,\sigma_2,\rho$ 的二维正态分布，记为 $(X,Y)\sim N(\mu_1,\mu_2,\sigma_1,\sigma_2,\rho)$ 。</p><p>二维正态分布的两个边缘分布都是一维正态分布，并且都不依赖与参数 $\rho$ ，亦即对于给定的 $\mu_1,\mu_2,\sigma_1,\sigma_2$ ，不同的 $\rho$ 对于不同的二维正态分布，他们的边缘分布是一样的。</p><h3 id="条件分布"><a href="#条件分布" class="headerlink" title="条件分布"></a>条件分布</h3><p>条件分布律：设 $(X,Y)$ 是二维离散型随机变量，对于固定的 $j$ ，若 $P\{ Y=y_j \}&gt;0$ 则称<br>$$<br>P\{ X=x_i|Y=y_j \}=\dfrac{P\{ X=x_i,Y=y_j \}}{P\{ Y=y_j \}}=\dfrac{p_{ij}}{p_{\cdot j}}<br>$$<br>为在 $Y=y_i$ 条件下随机变量 $X$ 的条件分布律。</p><p>同样的，对于固定的 $i$ ，若 $P\{ X=x_i \}$ ，则称<br>$$<br>P\{ Y=y_j|X=x_i \}=\dfrac{P\{ X=x_i,Y=y_j \}}{P\{ X=x_i \}}=\dfrac{p_{ij}}{p_{i \cdot}}<br>$$<br>为在 $X=x_i$ 条件下随机变量 $Y$ 的条件分布律。</p><p>条件概率密度：设二维随机变量 $(X,Y)$ 的概率密度为 $f(x,y)$ ， $(X,Y)$ 关于 $Y$ 的边缘概率密度为 $f_Y(y)$ 。若对于固定的 $y,f_Y(y)&gt;0$ ，则称 $\dfrac{f(x,y)}{f_Y(y)}$ 为在 $Y=y$ 的条件下 $X$ 的条件概率密度，记为<br>$$<br>f_{X|Y}(x|y)=\dfrac{f(x,y)}{f_Y(y)}<br>$$<br>称 $\int_{-\infty}^{x}f_{X|Y}(x|y)\mathrm{d}x=\int_{-\infty}^{x}\dfrac{f(x,y)}{f_Y(y)}\mathrm{d}x$ 为在 $Y=y$ 的条件下 $X$ 的条件分布函数，记为 $P\{ X\leq x| Y=y \}$ 或 $F_{X|Y}(x|y)$ ，即</p><p>$$<br>F_{X|Y}(x|y)=P\{ X\leq x|Y=y \} = \int_{-\infty}^{x}\dfrac{f(x,y)}{f_Y(y)}\mathrm{d}x<br>$$</p><p>类似的，可以定义 $f_{Y|X}(y|x)=\dfrac{f(x,y)}{f_Y(x)}$ 和 $F_{Y|X}(y|x)=\int_{-\infty}^{y}\dfrac{f(x,y)}{f_X(x)}$ 。</p><h3 id="相互独立的随机变量"><a href="#相互独立的随机变量" class="headerlink" title="相互独立的随机变量"></a>相互独立的随机变量</h3><p>独立：设 $F(x,y)$ 及 $F_X(x)$ ， $F_Y(y)$ 分别是二维随机变量 $(X,Y)$ 的分布函数及边缘分布函数，若对于所有的 $x,y$ 有<br>$$<br>P\{ X\leq x,Y\leq y \}=P\{ X\leq x \}P\{ Y\leq y \}<br>$$<br>即， $F(x,y)=F_X(x)F_Y(y)$ 。<br>则称随机变量 $X$ 和 $Y$ 是相互独立的。</p><p>设 $(X,Y)$ 是连续型随机变量， $f(x,y)$ ， $f_X(x)$ ， $F_Y(y)$ 分别为 $(X,Y)$ 的概率密度和边缘概率密度，则 $X$ 和 $Y$ 相互独立的条件等价于：等式<br>$$<br>f(x,y)=f_X(x)f_Y(y)<br>$$<br>在平面上几乎处处成立（指平面上除去“面积”为零的集合）。</p><p>当 $(X,Y)$ 是离散型随机变量时， $X$ 和 $Y$ 相互独立的条件等价于：对于 $(X,Y)$ 的所有可能取的值 $(x_i,y_j)$ 有，</p><p>$$<br>P\{X=x_i,Y=y_j\}=P\{ X=x_i \}P\{ Y=y_j \}<br>$$</p><p>对于二维正态随机变量 $(X,Y)$ ， $X$ 和 $Y$ 相互独立的充要条件是参数 $\rho = 0$ 。</p><p>二维随机变量相互独立可以推广到多维形式，这里不做赘述。</p><p>定理：设 $(X_1,X_2,\cdots,X_m)$ 和 $(Y_1,Y_2,\cdots,Y_n)$ 相互独立，则 $X_i,(i=1,2,\cdots,m)$ 和 $Y_i,(j=1,2,\cdots,n)$ 相互独立。又若 $h,g$ 是连续函数，则 $h(X_1,X_2,\cdots,X_m)$ 和 $g(Y_1,Y_2,\cdots,Y_n)$ 相互独立。</p><h3 id="两个随机变量的函数分布"><a href="#两个随机变量的函数分布" class="headerlink" title="两个随机变量的函数分布"></a>两个随机变量的函数分布</h3><p>一： $Z=X+Y$ 的分布</p><p>设 $(X,Y)$ 是二维连续型随机变量，它具有概率密度 $f(x,y)$ 。则 $Z=X+Y$ 仍为连续型随机变量，其概率密度为<br>$$<br>f_{X+Y}(z)=\int_{-\infty}^{\infty}f(z-y,y)\mathrm{d}y<br>$$<br>或<br>$$<br>f_{X+Y}(z)=\int_{-\infty}^{\infty}f(x,z-x)\mathrm{d}x<br>$$<br>又若 $X$ 和 $Y$ 相互独立，设 $(X,Y)$ 关于 $X,Y$ 的边缘密度分别为 $f_X(x),f_Y(y)$ ，则<br>$$<br>f_{X+Y}(z)=\int_{-\infty}^{\infty}f_X(z-y)f_Y(y)\mathrm{d}y<br>$$<br>和<br>$$<br>f_{X+Y}(z)=\int_{-\infty}^{\infty}f_X(x)f_Y(z-x)\mathrm{d}x<br>$$<br>这两个公式称为 $f_X$ 和 $f_Y$ 的卷积公式，记为 $f_X\ast f_Y$ 。即<br>$$<br>f_X\ast f_Y=\int_{-\infty}^{\infty}f_X(z-y)f_Y(y)\mathrm{d}y=\int_{-\infty}^{\infty}f_X(x)f_Y(z-x)\mathrm{d}x<br>$$<br>若 $X_i\sim N(\mu_i,\sigma_i^2),(i=1,\cdots,n)$ ，且它们相互独立，则它们的和 $Z=X_1+\cdots+X_n$ 仍然服从正态分布，且有 $Z\sim N(\mu_1+\cdots+\mu_n,\sigma_1^2+\cdots+\sigma_n^2)$ 。</p><p>更一般的，可以证明有限个相互独立的正态随机变量的线性组合仍然服从正态分布。</p><p>二： $Z=\dfrac{Y}{X}$ 的分布， $Z=XY$ 的分布</p><p>设 $(X,Y)$ 是二维连续型随机变量，它具有概率密度 $f(x,y)$ ，则 $Z=\dfrac{Y}{X}$ ， $Z=XY$ 仍然为连续型随机变量，其概率密度为<br>$$<br>f_{\frac{Y}{X}}(z)=\int_{-\infty}^{\infty} |x| f(x,xz)\mathrm{d}x<br>$$<br>$$<br>f_{XY}(z)=\int_{-\infty}^{\infty} \frac{1}{|x|} f(x,\frac{z}{x})\mathrm{d}x<br>$$<br>又若 $X$ 和 $Y$ 相互独立，设 $(X,Y)$ 关于 $X,Y$ 的边缘密度分别为 $f_X(x),f_Y(y)$ ，则<br>$$<br>f_{\frac{Y}{X}}(z)=\int_{-\infty}^{\infty} |x| f_X(x)f_Y(xz)\mathrm{d}x<br>$$<br>$$<br>f_{XY}(z)=\int_{-\infty}^{\infty} \frac{1}{|x|} f_X(x)f_Y(\frac{z}{x})\mathrm{d}x<br>$$<br>三： $M=\max \{ X,Y \}$ 及 $N = \min \{ X,Y \}$ 的分布</p><p>设 $(X,Y)$ 是两个相互独立的随机变量，它们的分布函数分别为 $F_X(x)$ 和 $F_Y(y)$ 。现在来求 $M=\max \{ X,Y \}$ 及 $N = \min \{ X,Y \}$ 的分布函数。<br>由于 $M=\max \{ X,Y \}$ 不大于 $z$ 等价于 $X$ 和 $Y$ 都不大于 $z$ ，故有<br>$$<br>P\{ M\leq z \}=P\{ X\leq z,Y\leq z \}<br>$$<br>又由于 $X$ 和 $Y$ 相互独立，得到 $M=\max \{ X,Y \}$ 的分布函数为<br>$$<br>F_{\max}(z)=P\{ M\leq z \}=P\{ X\leq z,Y\leq z \}=P\{ X\leq z \} P\{ Y\leq z \}<br>$$<br>即有 $F_{\max}(z)=F_X(z)F_Y(z)$ 。</p><p>类似的，可得 $N = \min \{ X,Y \}$ 的分布函数为<br>$$<br>F_{\min}(z)=P\{ N\leq z \} = 1-P\{ N&gt;z \}=1-P\{ X&gt;z,Y&gt;z \}=1-P\{ X&gt;z \}P\{ Y&gt;z \}<br>$$<br>即 $F_{\min}(z)=1-[1-F_X(z)][1-F_Y(z)]$ 。</p><p>设 $X_1\cdots,X_n$ 是 $n$ 个相互独立的随机变量，它们的分布函数分别为 $F_{X_i}(x_i),(i=1,\cdots,n)$ ，则 $M=\max \{ X,Y \}$ 及 $N = \min \{ X,Y \}$ 的分布函数分别为<br>$$<br>F_{\max}(z)=F_{X_1}(z)\cdots F_{X_n}(z)<br>$$</p><p>$$<br>F_{\min}(z)=1-[1-F_{X_1}(z)]\cdots [1-F_{X_n}(z)]<br>$$<br>特别的，当 $X_1\cdots,X_n$ 相互独立且具有相同的分布函数 $F(x)$ 时有<br>$$<br>F_{\max}(z)=[F(z)]^n<br>$$</p><p>$$<br>F_{\min}(z)=1-[1-F(z)]^n<br>$$</p><h2 id="随机变量的数字特征"><a href="#随机变量的数字特征" class="headerlink" title="随机变量的数字特征"></a>随机变量的数字特征</h2><h3 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h3><p>数学期望：设离散型随机变量 $X$ 的分布律为 $P\{ X=x_k \}=p_k,k=1,2,\cdots$ 。若级数 $\sum_{k=1}^{\infty}x_kp_k$ 绝对收敛，则称级数 $\sum_{k=1}^{\infty}x_kp_k$ 的和为随机变量 $X$ 的数学期望，记为 $E(X)$ ，即 $E(X)=\sum_{k=1}^{\infty}x_kp_k$ 。<br>设连续型随机变量 $X$ 的概率密度为 $f(x)$ ，若积分 $\int_{-\infty}^{\infty}xf(x)\mathrm{d}x$ 绝对收敛，则称积分 $\int_{-\infty}^{\infty}xf(x)\mathrm{d}x$ 的值为随机变量 $X$ 的数学期望，记为 $E(X)$ ，即 $E(X)=\int_{-\infty}^{\infty}xf(x)\mathrm{d}x$ 。<br>数学期望简称期望，又称为均值。</p><p>定理：设 $Y$ 是随机变量 $X$ 的函数： $Y=g(X)$ （ $g$ 是连续函数）。</p><ol><li>如果 $X$ 是离散型随机变量，它的分布律为 $P\{ X=x_k \}=p_k,k=1,2,\cdots$ 。若 $\sum_{k=1}^{\infty}g(x_k)p_k$ 绝对收敛，则有<br>$$<br>E(Y)=E[g(X)]=\sum_{k=1}^{\infty}g(x_k)p_k<br>$$</li><li>如果 $X$ 是连续型随机变量，它的概率密度为 $f(x)$ ，若 $\int_{-\infty}^{\infty}f(x)\mathrm{d}x$ 绝对收敛，则有<br>$$<br>E(Y)=E[g(X)]=\int_{-\infty}^{\infty}g(x)f(x)\mathrm{d}x<br>$$</li></ol><p>定理：设 $Z$ 是随机变量 $X,Y$ 的函数 $Z=g(X,Y)$ （ $g$ 是连续函数），那么， $Z$ 是一个一维随机变量。若二维随机变量 $(X,Y)$ 的概率密度为 $f(x,y)$ ，则有<br>$$<br>E(Z)=E[g(X,Y)]=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}g(x,y)f(x,y)\mathrm{d}x\mathrm{d}y<br>$$<br>这里设上式右边的积分绝对收敛，又若 $(X,Y)$ 为离散型随机变量，其分布律为 $P\{ X=x_i,Y=y_i \}=p_{ij},i,j=1,2,\cdots$ ，则有<br>$$<br>E(Z)=E[g(X,Y)]=\sum_{j=1}^{\infty}\sum_{i=1}^{\infty}g(x_i,y_i)p_{ij}<br>$$<br>这里设上式右边的级数绝对收敛。</p><p>数学期望的几个重要性质：</p><ol><li>设 $C$ 是常数，则有 $E(C)=C$ 。</li><li>设 $X$ 是一个随机变量， $C$ 是常数，则有 $E(CX)=cE(X)$ 。</li><li>设 $X,Y$ 是两个随机变量，则有 $E(X+Y)=E(X)+E(Y)$ 。</li><li>设 $X,Y$ 是相互独立的随机变量，则有 $E(XY)=E(x)E(Y)$ 。</li></ol><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p>方差：设 $X$ 是一个随机变量，若 $E\{ [X-E(X)]^2 \}$ 存在，则称 $E\{ [X-E(X)]^2 \}$ 为 $X$ 的方差，记为 $D(X)$ 或 $\mathrm{Var}(X)$ ，即<br>$$<br>D(X)=\mathrm{Var}(X)=E\{[X-E(X)]^2\}<br>$$<br>在应用上还引入量 $\sqrt{D(X)}$ ，记为 $\sigma(X)$ ，称为标准差或均方差。</p><p>对于离散型随机变量，有<br>$$<br>D(X)=\sum_{k=1}^{\infty}[x_k-E(X)]^2p_k<br>$$<br>其中 $P\{ X=x_k \}=p_k,k=1,2,\cdots $ 是 $X$ 的分布律。</p><p>对于连续型随机变量，有<br>$$<br>D(X)=\int_{-\infty}^{\infty}[x-E(X)]^2f(x)\mathrm{d}x<br>$$<br>其中 $f(x)$ 是 $X$ 的概率密度。</p><p>随机变量的方差可按下列公式计算<br>$$<br>D(X)-E(X^2)-[E(X)]^2<br>$$<br>设随机变量 $X$ 具有数学期望 $E(X)=\mu$ ，方差 $D(X)=\sigma^2\neq 0$ 。记<br>$$<br>X^*=\dfrac{X-\mu}{\sigma}<br>$$<br>则<br>$$<br>E(X^*)=\dfrac{1}{\sigma}E(X-\mu)=\dfrac{1}{\sigma}[E(X)-\mu]=0<br>$$</p><p>$$<br>D(X^*)=E(X^*)-[E(X^*)]^2=E[(\dfrac{X-\mu}{\sigma})^2]=\dfrac{1}{\sigma^2}E[(X-\mu)^2]=1<br>$$<br>即 $X^*$ 的数学期望为0，方差为1. $X^*$ 称为 $X$ 的标准化变量。</p><p>方差的几个重要性质：</p><ol><li><p>设 $C$ 是常数，则 $D(C)$ 。</p></li><li><p>设 $X$ 是随机变量， $C$ 是常数，则有<br>$D(CX)=C^2D(X),D(X+c)=D(X)$  </p></li><li><p>设 $X,Y$ 是两个随机变量，则有<br>$$<br>D(X+Y)=D(X)+D(Y)+2E\{ (X-E(X))(Y-E(Y)) \}<br>$$<br>特别的，若 $X,Y$ 相互独立，则有<br>$$<br>D(X+Y)=D(X)+D(Y)<br>$$<br>这一性质可以推广到任意有限多个相互独立的随机变量之和的情况。</p></li><li><p>$D(X)=0$ 的充要条件设 $X$ 以概率1取常数 $E(X)$ ，即<br>$$<br>P\{ X=E(X) \}=1<br>$$</p></li></ol><p>切比雪夫不等式：设随机变量 $X$ 具有数学期望 $E(X)=\mu$ ，方差 $D(X)=\sigma^2$ ，则对于任意正数 $\varepsilon$ ，不等式 $P\{ |X-\mu|\geq \varepsilon \}\leq \frac{\sigma^2}{\varepsilon^2}$ 成立。</p><p>常见的概率分布：</p><table><thead><tr><th>分布</th><th>参数</th><th>分布律或概率密度</th><th>数学期望</th><th>方差</th></tr></thead><tbody><tr><td>$(0-1)$分布</td><td>$0&lt;p&lt;1$</td><td>$P\{  X=k\}=p^k(1-p)^k,k=0,1$</td><td>$p$</td><td>$p(1-p)$</td></tr><tr><td>二项分布</td><td>$n\geq 1,0&lt;p&lt;1$</td><td>$P\{ X=k \}= {n\choose k}p^k(1-p)^{n-k},k=0,1,\cdots,$</td><td>$np$</td><td>$np(1-p)$</td></tr><tr><td>帕斯卡分布</td><td>$r\geq 1,0&lt;p&lt;1$</td><td>$P\{ X=k \}={k-1\choose r-1}p^r(1-p)^{k-r},k=r,r+1,\cdots$</td><td>$\frac{1}{p}$</td><td>$\frac{1-p}{p^2}$</td></tr><tr><td>泊松分布</td><td>$\lambda&gt;0$</td><td>$P\{ X=k \}=\frac{\lambda^k\mathrm{e}^{-\lambda}}{k!},k=0,1,2,\cdots$</td><td>$\lambda$</td><td>$\lambda$</td></tr><tr><td>均匀分布</td><td>$a&lt;b$</td><td>$f(x)=\begin{cases} \frac{1}{b-a},a&lt;x&lt;b \\ 0,\text{其他}\end{cases}$</td><td>$\frac{a+b}{2}$</td><td>$\frac{(b-a)^2}{12}$</td></tr><tr><td>正态分布</td><td>$\mu , \sigma(\sigma&gt;0)$</td><td>$f(x)=\frac{1}{\sqrt{2\pi}\sigma}\mathrm{e}^{-(x-\mu)^2/(2\sigma^2)}$</td><td>$\mu$</td><td>$\sigma^2$</td></tr><tr><td>$\Gamma$分布</td><td>$\alpha,\beta&gt;0$</td><td>$f(x)=\begin{cases} \frac{1}{\beta^{\alpha}\Gamma(\alpha)}x^{\alpha-1}\mathrm{e}^{-x/\beta},x&gt;0 \\ 0,\text{其他} \end{cases}$</td><td>$\alpha \beta$</td><td>$\alpha \beta^2$</td></tr><tr><td>超几何分布</td><td>$N,M,n,(M\leq N),(n\leq N)$</td><td>$\frac{C_M^kC_{N-M}^{n-k}}{C_N^k},k\in \mathbb{Z},\mathrm{max} \{ 0,n-N+M \}\leq k\leq \mathrm{min} \{ n,M \}$</td><td>$\frac{nM}{N}$</td><td>$\frac{nM}{N}(1-\frac{M}{N})(\frac{N-n}{N-1})$</td></tr><tr><td>几何分布</td><td>$0&lt;p&lt;1$</td><td>$P\{ X=k \}=(1-p)^{k-1}p,k=1,2,\cdots$</td><td>$\frac{1}{p}$</td><td>$\frac{1-p}{p^2}$</td></tr><tr><td>指数分布</td><td>$\theta&gt;0$</td><td>$f(x)=\begin{cases} \frac{1}{\theta}\mathrm{e}^{-x/\theta},x&gt;0 \\ 0,\text{其他} \end{cases}$</td><td>$\theta$</td><td>$\theta^2$</td></tr><tr><td>$\chi^2$分布</td><td>$n\geq 1$</td><td>$f(x)=\begin{cases} \frac{1}{2^{n/2}\Gamma(n/2)}x^{n/2-1}\mathrm{e}^{-x/2},x&gt;0 \\ 0,\text{其他}\end{cases}$</td><td>$n$</td><td>$2n$</td></tr><tr><td>韦布尔分布</td><td>$\eta&gt;0,\beta&gt;0$</td><td>$f(x)=\begin{cases} \frac{\beta}{\eta}(\frac{x}{\eta})^{\beta -1}\mathrm{e}^{-(\frac{x}{\eta})^\beta},x&gt;0\\ 0,\text{其他} \end{cases}$</td><td>$\eta \Gamma(\frac{1}{\beta}+1)$</td><td>$\eta^2\{ \Gamma(\frac{2}{\beta}+1)-[\Gamma(\frac{1}{\beta}+1)]^2 \}$</td></tr><tr><td>瑞利分布</td><td>$\sigma&gt;0$</td><td>$f(x)=\begin{cases} \frac{x}{\sigma^2}\mathrm{e}^{-x^2/(2\sigma^2)},x&gt;0 \\ 0,\text{其他} \end{cases}$</td><td>$\sqrt{\frac{\pi}{2}}\sigma$</td><td>$\frac{4-\pi}{2}\sigma^2$</td></tr><tr><td>$\beta$分布</td><td>$\alpha&gt;0,\beta&gt;0$</td><td>$f(x)=\begin{cases} \frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)}x^{\alpha-1}(1-x)^{\beta-1},0&lt;x&lt;1 \\ 0,\text{其他} \end{cases}$</td><td>$\frac{\alpha}{\alpha+\beta}$</td><td>$\frac{\alpha\beta}{(\alpha+\beta)^2(\alpha+\beta+1)}$</td></tr><tr><td>对数正态分布</td><td>$\mu,\sigma(\sigma&gt;0)$</td><td>$f(x)=\begin{cases} \frac{1}{\sqrt{2\pi}\sigma x}\mathrm{e}^{-(\ln x-\mu)^2/(2\sigma^2)},x&gt;0 \\ 0,\text{其他} \end{cases}$</td><td>$\mathrm{e}^{\mu+\frac{\sigma^2}{2}}$</td><td>$\mathrm{e}^{2\mu^2+\sigma^2}(\mathrm{e}^{\sigma^2}-1)$</td></tr><tr><td>柯西分布</td><td>$a,\lambda(\lambda&gt;0)$</td><td>$f(x)=\frac{1}{\pi}\frac{\lambda}{\lambda^2+(x-a)^2}$</td><td>不存在</td><td>不存在</td></tr><tr><td>$t$分布</td><td>$n\geq 1$</td><td>$f(x)=\frac{\Gamma(\frac{n+1}{2})}{\sqrt{n\pi}\Gamma(n/2)}(1+\frac{x^2}{n})^{-(n+1)/2}$</td><td>$0,n&gt;1$</td><td>$\frac{n}{n-2},n&gt;2$</td></tr><tr><td>$F$分布</td><td>$n_1,n_2$</td><td>$f(x)=\begin{cases} \frac{\Gamma[(n_1+n_2)/2]}{\Gamma(n_1/2)\Gamma(n_2/2)}(\frac{n_1}{n_2})(\frac{n_1}{n_2}x)^{n_1/2-1}\times (1+\frac{n_1}{n_2}x)^{-(n_1+n_2)/2},x&gt;0 \\ 0.\text{其他} \end{cases}$</td><td>$\frac{n_2}{n_2-2},n&gt;2$</td><td>$\frac{2n_2^2(n_1+n_2-2)}{n_1(n_2-2)^2(n_2-4)},n_2&gt;4$</td></tr></tbody></table><h3 id="协方差及相关系数"><a href="#协方差及相关系数" class="headerlink" title="协方差及相关系数"></a>协方差及相关系数</h3><p>协方差与相关系数：量 $E\{ [X-E(X)][Y-E(Y)] \}$ 称为随机变量 $X$ 与 $Y$ 的协方差。记为 $\mathrm{Cov}(X,Y)$ ，即<br>$$<br>\mathrm{Cov}(X,Y)=E\{ [X-E(X)][Y-E(Y)] \}<br>$$<br>而<br>$$<br>\rho_{XY}=\frac{\mathrm{Cov}(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}<br>$$<br>称为随机变量 $X$ 与 $Y$ 的相关系数。</p><p>由定义，可以知道：<br>$$<br>\mathrm{Cov}(X,Y)=\mathrm{Cov}(Y,X),\mathrm{Cov}(X,X)=D(X)<br>$$<br>对于任意两个随机变量 $X$ 和 $Y$ ，下列等式成立：<br>$$<br>D(X+Y)=D(X)+D(Y)+2\mathrm{Cov}(X,Y)<br>$$<br>将 $\mathrm{Cov}(X,Y)$ 的定义式展开，易得<br>$$<br>\mathrm{Cov}(X,Y)=E(XY)-E(X)-E(Y)<br>$$<br>这一式子常常用于计算协方差。</p><p>协方差的性质：</p><ol><li> $\mathrm{Cov}(aX,bY)=ab\mathrm{Cov}(X,Y)$ ， $a,b$ 是常数。</li><li>$$\mathrm{Cov}(X_1+X_2,Y)=\mathrm{Cov}(X_1,Y)+\mathrm{Cov}(X_2,Y)$$</li></ol><p>考虑以 $X$ 的线性函数 $a+bX$ 来近似表示 $Y$ ，我们以均方误差<br>$$<br>e=E[(Y-(a+bX))^2]=E(Y^2)+b^2E(X^2)+a^2-2bE(XY)+2abE(X)-2aE(Y)<br>$$<br>来衡量以 $a+bX$ 近似表达 $Y$ 的好坏程度。 $e$ 的值越小表示 $a+bX$ 与 $Y$ 的近似程度越好。这样，我们就取 $a,b$ 使 $e$ 取到最小，将 $e$ 分别关于 $a,b$ 求偏导数，并令它们等于零，得<br>$$<br>\begin{cases} \dfrac{\partial e}{\partial a}=2a+2bE(X)-2E(Y)=0 \\  \dfrac{\partial e}{\partial b}=2bE(X^2)-2E(XY)+2aE(X)=0  \end{cases}<br>$$<br>解得<br>$$<br>b_0=\dfrac{\mathrm{Cov}(X,Y)}{D(X)},a_0=E(Y)-b_0E(X)=E(Y)-E(X)\dfrac{\mathrm{Cov}(X,Y)}{D(X)}<br>$$<br>将 $A_0,b_0$ 代入 $e$ 的定义式中，有<br>$$<br>\min E\{ [Y-(a+bX)]^2 \}=(1-\rho_{XY}^2)D(Y)<br>$$</p><p>定理： $|\rho_{XY}|\leq 1$ 。</p><p>定理： $|\rho_{XY}|=1$ 的充要条件是，存在常数 $a,b$ 使 $P\{ Y=a+bX \}=1$ 。</p><p>当 $|\rho_{XY}|$ 较大时，称 $X,Y$ 线性相关的程度较好，当 $|\rho_{XY}|$ 较小时， $X,Y$ 线性相关的程度较差。当 $|\rho_{XY}|=1$ 时，称 $X$ 与 $Y$ 不相关。</p><p>当 $X,Y$ 服从二维正态分布时， $X$ 和 $Y$ 不相关与 $X$ 和 $Y$ 相互独立是等价的。</p><h3 id="矩，协方差矩阵"><a href="#矩，协方差矩阵" class="headerlink" title="矩，协方差矩阵"></a>矩，协方差矩阵</h3><p>原点矩：设 $X$ 和 $Y$ 是随机变量，若<br>$$<br>E(X^k),k=1,2,\cdots<br>$$<br>存在，称它为 $X$ 的 $k$ 阶原点矩，简称 $k$ 阶矩。</p><p>中心矩：若<br>$$<br>E\{ [X-E(X)]^k \},k=1,2,3,\cdots<br>$$<br>存在，称它为 $X$ 的 $k$ 阶中心矩。</p><p>混合矩：若<br>$$<br>E(X^kY^l),k,l=1,2,\cdots<br>$$</p><p>存在，称它为 $X$ 和 $Y$ 的 $k+l$ 阶混合矩。</p><p>混合中心矩：若<br>$$<br>E\{ [X-E(X)]^k[Y-E(Y)]^l \},k,l=1,2,\cdots<br>$$<br>存在，称它为 $X$ 和 $Y$ 的 $k+l$ 阶混合中心矩。</p><p>协方差矩阵：设 $n$ 维随机变量 $(X_1,\cdots,X_n)$ 的二阶混合中心矩<br>$$<br>c_{ij}=\mathrm{Cov}(X_i,X_j)=E\{ [X_i-E(X_i)][X_j-E(X_j)] \}<br>$$<br>都存在，则称矩阵<br>$$<br>C=\begin{pmatrix}c_{11}&amp;c_{12}&amp;\cdots &amp;c_{1n} \\ c_{21}&amp;c_{22}&amp;\cdots &amp;c_{2n} \\ \vdots &amp;\vdots &amp;\ddots &amp;\vdots \\ c_{n1}&amp;c_{n2}&amp;\cdots &amp;c_{nn}\end{pmatrix}<br>$$<br>为 $n$ 维随机变量 $(X_1,\cdots,X_n)$ 的协方差矩阵。</p><h2 id="大数定律及中心极限定理"><a href="#大数定律及中心极限定理" class="headerlink" title="大数定律及中心极限定理"></a>大数定律及中心极限定理</h2><h3 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h3><p>弱大数定理（辛钦大数定理）：设 $X_1,X_2,\cdots$ 是相互独立的，服从同一分布的随机变量序列，且具有数学期望 $E(X_k)=\mu (k=1,2,\cdots)$ 。作前 $n$ 个变量的算术平均 $\frac{1}{n}\sum_{k=1}^nX_k$ ，则对于任意 $\varepsilon&gt;0 $ ，有<br>$$<br>\lim_{n\to \infty}P\{ |\frac{1}{n}\sum_{k=1}^nX_k-\mu| &lt;\varepsilon \}=1<br>$$</p><p>设 $Y_1,Y_2,\cdots$ 是一个随机变量序列， $a$ 是一个常数。若对于任意正数 $\varepsilon$ ，有<br>$$<br>\lim_{n\to \infty}P\{ |Y_n-a|&lt; \varepsilon \}=1<br>$$<br>则称序列 $Y_1,Y_2,\cdots$ 依概率收敛于 $a$ ，记为<br>$$<br>Y_n\stackrel{P}{\longrightarrow} a<br>$$<br>依概率收敛的序列具有以下性质：</p><p>设 $X_n\stackrel{P}{\longrightarrow} a$ ， $Y_n\stackrel{P}{\longrightarrow} b$ ，又设函数 $g(x,y)$ 在点 $(a,b)$ 连续，则<br>$$<br>g(X_n,Y_n)\stackrel{P}{\longrightarrow} g(a,b)<br>$$<br>弱大数定理（辛钦大数定理）：设随机变量 $X_1,X_2,\cdots$ ，相互独立，服从同一分布且具有数学期望 $E(X_k)=\mu (k=1,2,\cdots)$ ，则序列 $\overline{X}=\frac{1}{n}\sum_{k=1}^nX_k$ 依概率收敛于 $\mu $ ，即 $\overline{X} \stackrel{P}{\longrightarrow} \mu $ 。</p><p>伯努利大数定理：设 $f_A$ 是 $n$ 次独立重复试验中事件 $A$ 发生的次数， $p$ 是事件 $A$ 在每次试验中发生的概率，则对于任意正数 $\varepsilon &gt;0$ ，有<br>$$<br>\lim_{n\to \infty}P\{ |\frac{f_A}{n}-p|&lt;\varepsilon \}=1<br>$$<br>或<br>$$<br>\lim_{n\to \infty}P\{ |\frac{f_A}{n}-p|\geq \varepsilon \}=0<br>$$</p><h3 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h3><p>独立同分布的中心极限定理：设随机变量 $X_1,X_2,\cdots$ 相互独立，且服从同一分布，且具有数学期望和方差： $E(X_k)=\mu $ ， $D(X_k)=\sigma^2&gt;0$ ， $(k=1,2,\cdots)$ ，则随机变量之和 $\sum_{k=1}^nX_k$ 的标准化变量<br>$$<br>Y_n=\dfrac{\sum_{k=1}^nX_k-E(\sum_{k=1}^nX_k)}{\sqrt{D(\sum_{k=1}^nX_k)}}<br>$$<br>的分布函数 $F_{n}(x)$ 对于任意 $x$ 满足<br>$$<br>\lim_{n\to \infty}F_n(x)=\lim_{n\to \infty}P\{ \frac{\sum_{k=1}X_k-n\mu}{\sqrt{n}\sigma} \}<br>$$<br>李雅普诺夫定理：设随机变量 $X_1,X_2,\cdots$ 相互独立，它们具有数学期望和方差<br>$$<br>E(X_k)=\mu_k,D(X_k)=\sigma_k^2&gt;0,k=1,2,\cdots<br>$$<br>记<br>$$<br>B_n^2=\sum_{k=1}^n\sigma_k^2<br>$$<br>若存在正数 $\delta$ ，使得当 $n\rightarrow \infty$ 时，<br>$$<br>\frac{1}{B_{n}^{2+\delta}}\sum_{k=1}^nE\{ |X_k-\mu_k|^{2+\delta} \}\rightarrow 0<br>$$<br>则随机变量之和 $\sum_{k=1}^nX_k$ 的标准化变量<br>$$<br>Z_n=\dfrac{\sum_{k=1}^nX_k-\sum_{k=1}^n\mu_k}{B_n}<br>$$<br>的分布函数 $F_n(x)$ 对于任意 $x$ ，满足<br>$$<br>\lim_{n\to \infty}F_n{x}=\lim_{n\to \infty}=\lim_{n\to \infty}P\{ \dfrac{\sum_{k=1}^nX_k-\sum_{k=1}^n\mu_k}{B_n}\leq x \}=\int_{-\infty}^{x}\dfrac{1}{\sqrt{2\pi}}\mathrm{e}^{-t^2/2}\mathrm{d}t=\varPhi(x)<br>$$</p><p>棣莫弗——拉普拉斯定理：设随机变量 $\eta$ 服从参数为 $n,p(0&lt;p&lt;1)$ 的二项分布，则对于任意 $x$ ，有<br>$$<br>\lim_{n\to \infty}P\{ \dfrac{\eta_n-np}{\sqrt{np(1-p)}}\leq x \}=\int_{-\infty}^{x}\dfrac{1}{\sqrt{2\pi}}\mathrm{e}^{-t^2/2}\mathrm{d}t=\varPhi(x)<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>概统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合论</title>
    <link href="/archives/ea132d69.html"/>
    <url>/archives/ea132d69.html</url>
    
    <content type="html"><![CDATA[<p>数学是各个学科的基础，集合论是数学的基础。这不是别人说的，这是我说的。</p><span id="more"></span><h1 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h1><h2 id="集合的基本概念"><a href="#集合的基本概念" class="headerlink" title="集合的基本概念"></a>集合的基本概念</h2><h3 id="集合的定义与表示"><a href="#集合的定义与表示" class="headerlink" title="集合的定义与表示"></a>集合的定义与表示</h3><p>集合：没有精确的数学定义，可以理解为一些离散个体组成的全体，组成集合的个体称为它的元素或成员</p><p>集合的表示</p><ul><li><p>列元素法 $A={ a, b, c, d }$</p></li><li><p>谓词表示法  $B=\{ x | P(x) \}$,$B$ 由使得 $P(x)$ 为真的 $x$ 构成。</p></li></ul><p>常用数集：<br>$\mathbb{N}, \mathbb{Z}, \mathbb{Q}, \mathbb{R}, \mathbb{C}$ 分别表示自然数、整数、有理数、实数和复数集合，注意 0 是自然数. </p><h3 id="集合与元素"><a href="#集合与元素" class="headerlink" title="集合与元素"></a>集合与元素</h3><p>元素与集合的关系：隶属关系</p><p>属于 $\in$ ，不属于 $\notin$ </p><h3 id="集合之间的关系"><a href="#集合之间的关系" class="headerlink" title="集合之间的关系"></a>集合之间的关系</h3><p>包含（子集）： $A\subseteq B\Leftrightarrow \forall x(x\in A \rightarrow x\in B)$<br>不包含： $A\not \subseteq B\Leftrightarrow \exists x(x\in A\wedge x\notin B)$<br>相等： $A=B\Leftrightarrow A\subseteq B \wedge B\subseteq A$<br>不相等： $A\neq B$<br>真包含： $A\subset B\Leftrightarrow A\subseteq B\wedge A\neq B$<br>不真包含：$A\not\subset B$ </p><h3 id="空集"><a href="#空集" class="headerlink" title="空集"></a>空集</h3><p>空集：不含任何元素的集合。$\varnothing$</p><p>空集是任何集合的子集。</p><p>空集是唯一的。</p><h3 id="全集"><a href="#全集" class="headerlink" title="全集"></a>全集</h3><p>全集：在给定问题中，全集包含任何集合，即 $\forall A(A\subseteq E)$ 。</p><p>相对性</p><h3 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h3><p>幂集： $P(A)=\{ x|x\subseteq A \}$ 。<br>计数：如果 $|A|=n$ ，则 $|P(A)|=2^n$ 。</p><h3 id="集合的基本运算"><a href="#集合的基本运算" class="headerlink" title="集合的基本运算"></a>集合的基本运算</h3><h4 id="集合基本运算的定义"><a href="#集合基本运算的定义" class="headerlink" title="集合基本运算的定义"></a>集合基本运算的定义</h4><p>并： $A\cup B =\{ x|x\in A\vee x\in B \}$<br>交： $A\cap B =\{ x|x\in A\wedge x\in B \}$<br>相对补： $A-B=\{ x|x\in A\wedge x\notin B \}$<br>对称差： $A\oplus B=(A-B)\cup(B-A)$ $=$ $(A\cup B)-(A\cap B)$<br>绝对补： $\sim A=E-A$</p><p>运算顺序： $\sim $ 和幂集优先，其他由括号决定。</p><p>并和交运算可以推广到有穷个集合上，即<br>$$<br>A_1\cup A_2\cup \cdots A_n=\{ x|x\in A_1\vee x\in A_2\vee<br>\cdots \vee x\in A_n \}<br>$$<br>$$<br>A_1\cap A_2\cap \cdots A_n=\{ x|x\in A_1\wedge x\in A_2\wedge \cdots \wedge x\in A_n \}<br>$$<br>一些结果：<br>$$<br>\varnothing \subseteq A-B \subseteq A<br>$$<br>$$<br>A\subseteq B\Leftrightarrow A-B=\varnothing<br>$$<br>$$<br>A\cap B=\varnothing \Leftrightarrow A-B=A<br>$$</p><h4 id="文氏图"><a href="#文氏图" class="headerlink" title="文氏图"></a>文氏图</h4><p><img src="ea132d69/%E6%96%87%E6%B0%8F%E5%9B%BE.jpg" alt="文氏图"></p><h4 id="集合运算的算律"><a href="#集合运算的算律" class="headerlink" title="集合运算的算律"></a>集合运算的算律</h4><table><thead><tr><th>运算律</th><th>$\cup$</th><th>$\cap$</th><th>$\oplus$</th></tr></thead><tbody><tr><td>交换</td><td>$A\cup B =B\cup A$</td><td>$A\cap B =B\cap A$</td><td>$A\oplus B=B\oplus A$</td></tr><tr><td>结合</td><td>$(A\cup B)\cup C=A\cup (B\cup C)$</td><td>$(A\cap B)\cap C=A\cap (B\cap C)$</td><td>$(A\oplus B)\oplus C=A\oplus (B\oplus C)$</td></tr><tr><td>幂等</td><td>$A\cup A=A$</td><td>$A\cap A=A$</td><td></td></tr></tbody></table><table><thead><tr><th>运算律</th><th>$\cup $ 与 $\cap $</th><th>$\cap $ 与 $\oplus$</th></tr></thead><tbody><tr><td>分配</td><td>$A\cup(B\cap C)=(A\cup B)\cap (A\cup C)$,$A\cap (B\cup C)=(A\cap B)\cup (A\cap C)$</td><td>$A\cap(B\oplus C)=(A\cap B)\oplus(A\cap C)$</td></tr><tr><td>吸收</td><td>$A\cup (A\cap B)=A$,$A\cap (A\cup B)=A$</td><td></td></tr></tbody></table><table><thead><tr><th>运算律</th><th>$-$</th><th>$\sim$</th></tr></thead><tbody><tr><td>D.M律</td><td>$A-(B\cup C)=(A-B)\cap (A-C)$,$A-(B\cap C)=(A-B)\cup (A-C)$</td><td>$\sim (B\cup C)=\sim B\cap \sim C$,$\sim(B\cap C)=\sim B\cup \sim C$</td></tr><tr><td>双重否定</td><td></td><td>$\sim \sim A=A$</td></tr></tbody></table><table><thead><tr><th>运算律</th><th>$\varnothing$</th><th>$E$</th></tr></thead><tbody><tr><td>补元律</td><td>$A\cap \sim A = \varnothing$</td><td>$A\cup \sim A = E$</td></tr><tr><td>零律</td><td>$A\cap \varnothing = \varnothing$</td><td>$A\cup E =E$</td></tr><tr><td>同一律</td><td>$A\cup \varnothing =A$</td><td>$A\cap E =A$</td></tr><tr><td>否定</td><td>$\sim \varnothing =E$</td><td>$\sim E=\varnothing$</td></tr></tbody></table><h4 id="集合包含或恒等式的证明"><a href="#集合包含或恒等式的证明" class="headerlink" title="集合包含或恒等式的证明"></a>集合包含或恒等式的证明</h4><ol><li>证明 $X\subseteq Y$</li></ol><ul><li>命题演算法</li><li>包含传递法</li><li>等价条件法</li><li>反证法</li><li>并交运算法</li></ul><ol start="2"><li>证明 $X=Y$</li></ol><ul><li>命题演算法</li><li>等式代入法</li><li>反证法</li><li>运算法</li></ul><h3 id="集合中元素的计数"><a href="#集合中元素的计数" class="headerlink" title="集合中元素的计数"></a>集合中元素的计数</h3><h3 id="集合的基数与有穷集合"><a href="#集合的基数与有穷集合" class="headerlink" title="集合的基数与有穷集合"></a>集合的基数与有穷集合</h3><p>集合 $A$ 的基数：集合 $A$ 中的元素数，记作 $\mathrm{card}A$<br>有穷集 $A$： $\mathrm{card}A=|A|=n$，$n$ 为自然数.</p><h3 id="包含排斥原理-容斥原理"><a href="#包含排斥原理-容斥原理" class="headerlink" title="包含排斥原理(容斥原理)"></a>包含排斥原理(容斥原理)</h3><p>容斥原理：设 $S$ 为有穷集，$P_1, P_2,\cdots, P_m$ 是 $m$ 种性质， $A_i$ 是 $S$ 中具有性质 $P_i$ 的元素构成的子集，$i=1, 2,\cdots , m$ 。则 $S$ 中不具有性质 $P_1, P_2,\cdots, P_m$ 的元素数为<br>$$<br>|\overline{A_1}\cap \cdots\cap \overline{A_m}|=|S|-\sum_{i=1}^m|A_i|+\sum_{1\leq i&lt;j\leq m}|A_i\cap A_j|-\sum_{1\leq i&lt;j&lt;k\leq m}|A_i\cap A_j \cap A_k|+\cdots+(-1)^m|A_1\cap A_2\cap \cdots \cap A_m|<br>$$</p><p>推论： $S$ 中至少具有一条性质的元素数为<br>$$<br>|A_1\cup A_2\cup \cdots \cup A_m|=\sum_{i=1}^{m}|A_i|-\sum_{1 \leq i&lt;j\leq m}|A_i\cap A_j\cap A_k|+\cdots+(-1)^{m-1}|A_1\cap A_2\cap \cdots \cap A_m|<br>$$</p><h3 id="有穷集的计数"><a href="#有穷集的计数" class="headerlink" title="有穷集的计数"></a>有穷集的计数</h3><h2 id="集合的笛卡儿积和二元关系"><a href="#集合的笛卡儿积和二元关系" class="headerlink" title="集合的笛卡儿积和二元关系"></a>集合的笛卡儿积和二元关系</h2><h3 id="有序对"><a href="#有序对" class="headerlink" title="有序对"></a>有序对</h3><p>有序对：由两个元素 $x$ 和 $y$，按照一定的顺序组成的二元组称为有序对（也称序偶），记作$&lt;x,y&gt;$</p><p>有序对性质<br>有序性:$&lt;x,y&gt;\neq &lt;y,x&gt;$ （当$x\neq  y$时）$&lt;x,y&gt;$ 与 $&lt;u,v&gt;$ 相等的充分必要条件是$&lt;x,y&gt;=&lt;u,v&gt; \Leftrightarrow x=u \wedge y=v$</p><p>有序 $n$ 元组：一个有序 $n (n\leq 3)$ 元组 $&lt;x_1, x_2, …, x_n&gt;$ 是一个有序对，其中第一个元素是一个有序 $n-1$元组，即$$&lt;x_1, x_2, …, x_n&gt; = &lt; &lt;x_1, x_2, …, x_{n-1}&gt;, x_n&gt;$$<br>当 $n=1$时, $ &lt; x &gt; $ 形式上可以看成有序 1 元组。</p><h3 id="笛卡尔积及其性质"><a href="#笛卡尔积及其性质" class="headerlink" title="笛卡尔积及其性质"></a>笛卡尔积及其性质</h3><p>笛卡尔积：设$A,B$为集合，$A$与$B$ 的笛卡儿积记作$A\times B$， 定义为 $A\times B =\{ &lt;x,y&gt; | x\in A \wedge y\in B \}$</p><p>笛卡尔积的性质：</p><ul><li>若 $A$ 或 $B$ 中有一个为空集，则 $A\times B$ 就是空集。</li><li>不适合交换律。</li><li>不适合结合律。</li><li>对于并或交运算满足分配律</li><li>若$|A|=m, |B|=n$, 则 $|A\times B|=mn $</li></ul><h3 id="二元关系的定义"><a href="#二元关系的定义" class="headerlink" title="二元关系的定义"></a>二元关系的定义</h3><p>二元关系：如果一个集合满足以下条件之一：<br>（1）集合非空, 且它的元素都是有序对<br>（2）集合是空集<br>则称该集合为一个二元关系, 简称为关系，记作$R$。<br>如$&lt;x,y&gt;\in R$, 可记作 $xRy$。</p><p>从$A$到$B$的关系与$A$上的关系：设$A,B$为集合, $A\times B$的任何子集所定义的二元关系叫做从$A$到$B$的二元关系, 当$A=B$时则叫做$A$上的二元关系.</p><p>$A$上重要关系：</p><p>设 $A$ 为任意集合，<br> $\varnothing$ 是 $A$ 上的关系，称为空关系<br>$E_A, I_A$ 分别称为全域关系与恒等关系，定义如下：<br>$$E_A={&lt;x,y&gt;|x\in A\wedge y\in A}=A\times A \\  I_A={&lt;x,x&gt;|x\in A}$$</p><p>小于等于关系 $L_A$, 整除关系$D_A$, 包含关系$R_{\subseteq}$定义：<br>$L_A=\{&lt;x,y&gt;| x,y\in A\wedge x\leq y\}$, 这里$A\subseteq R$，$R$为实数集合。<br>$D_B=\{&lt;x,y&gt;| x,y\in B\wedge x|y\}$, 这里$B\subseteq Z^*$, $Z^*$为非0整数集。<br>$R_{\subseteq}=\{&lt;x,y&gt;| x,y\in A\wedge x\subseteq y\}$, 这里$A$是集合族.<br>类似的还可以定义大于等于关系, 小于关系, 大于关系, 真包含关系等等。</p><h3 id="二元关系的表示"><a href="#二元关系的表示" class="headerlink" title="二元关系的表示"></a>二元关系的表示</h3><p>表示方式：关系的集合表达式、关系矩阵、关系图。</p><p>关系图：若$A= {x_1, x_2, \cdots, x_m}$，$R$是$A$上的关系，$R$的关系图是$G_R=&lt;V, E&gt;$, 其中$V=A$为顶点集，$E$为边集.如果$&lt;x_i,x_j&gt;$属于关系R，在图中就有一条从 $x_i$ 到 $x_j$ 的有向边。</p><p>注意：$A, B$为有穷集，关系矩阵适于表示从$A$到$B$的关系或者$A$上的关系，关系图适于表示$A$上的关系。</p><h3 id="关系的运算"><a href="#关系的运算" class="headerlink" title="关系的运算"></a>关系的运算</h3><h4 id="基本运算定义"><a href="#基本运算定义" class="headerlink" title="基本运算定义"></a>基本运算定义</h4><p>定义域：$\mathrm{dom}R=\{ x|\exists y(&lt;x,y&gt;\in R) \}$<br>值域：$\mathrm{ran}R=\{ y|\exists x(&lt;x,y&gt;\in R) \}$<br>域：$\mathrm{fld}R=\mathrm{dom}R\cup \mathrm{ran}R$<br>逆：$R^{-1}=\{ &lt;y,x&gt;|&lt;x,y&gt;\in R \}$<br>合成：$$R\circ S=\{ &lt;x,z&gt;| \exists y(&lt;x,y&gt;\in R\wedge &lt;y,z&gt;\in S)\}$$</p><p>合成运算的图示方法: 利用图示（不是关系图）方法求合成。</p><p>限制：$F$ 在 $A$ 上的限制 $F\upharpoonright A = \{&lt;x,y&gt; | xFy \wedge x\in A\}$<br>像：$A$ 在 $F$ 下的像，$F[A] = \mathrm{ran}(F\upharpoonright A)$</p><p>注意： $F\upharpoonright A\subseteq F,F[A]\subseteq \mathrm{ran} F$</p><h4 id="基本运算的性质"><a href="#基本运算的性质" class="headerlink" title="基本运算的性质"></a>基本运算的性质</h4><p>定理：设$F$是任意的关系, 则<br>(1) $(F^{-1})^{-1}=F$<br>(2) $\mathrm{dom}F^{-1}=\mathrm{ran}F^{-1}, \mathrm{ran}F^{-1}=\mathrm{dom}F$</p><p>令 $R,S\subseteq A\times B$ 则有<br>性质1：<br>$$<br>\mathrm{dom}(R\cup S)=\mathrm{dom}R\cup \mathrm{dom}S<br>$$<br>$$ \mathrm{ran}(R\cup S)=\mathrm{ran}R\cup \mathrm{ran}S<br>$$<br>$$ \mathrm{dom}(R\cap S)=\mathrm{dom}R\cap \mathrm{dom}S<br>$$<br>$$ \mathrm{ran}(R\cap S)=\mathrm{ran}R\cap \mathrm{ran}S<br>$$</p><p>性质2：<br>$$<br>(R\cup S)^{-1}=R^{-1}\cup S^{-1}<br>$$</p><p>$$<br>(R\cap S)^{-1}=R^{-1}\cap S^{-1}<br>$$</p><p>$$<br>(R - S)^{-1}=R^{-1} - S^{-1}<br>$$</p><p>$$<br>R\subseteq S\Rightarrow R^{-1}\subseteq S^{-1}<br>$$</p><p>定理：设 $F,G,H$ 是任意关系，则<br>(1)$(F\circ G)\circ H=F\circ (G\circ H)$<br>(2)$(F\circ G)^{-1}=G^{-1}\circ F^{-1}$</p><p>$$<br>F\circ (G\cup H)=(F\circ G)\cup (F\circ H)<br>$$<br>$$<br>F\circ (G\cap H) \subseteq (F\circ G)\cap (F\circ H)<br>$$</p><h4 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h4><p>幂：设$R$为$A$上的关系, $n$为自然数, 则 $R$ 的 $n$次幂定义为：<br>(1) $R_0=\{&lt;x,x&gt; | x\in A \}=I_A$<br>(2) $R^{n+1} = R^n\circ R$</p><p>注意：<br>对于$A$上的任何关系$R_1$和$R_2$都有 $R_1^0 = R_2^0 = I_A$<br>对于$A$上的任何关系 $R$ 都有 $R^1 = R$ </p><p>幂的求法：对于集合表示的关系$R$，计算 $R^n$ 就是$n$个$R$右复合。矩阵表示就是$n$个矩阵相乘, 其中相加采用逻辑加。 </p><p>定理：设$A$为$n$元集, $R$是$A$上的关系, 则存在自然数$ s$ 和 $t$,使得$R^s = R^t$。</p><p>定理：设 $R$ 是 $A$ 上的关系, $m, n\in N$, 则<br>(1)  $R^m\circ R^n=R^{m+n}$<br>(2)  $(R^m)^n=R^{mn}$  </p><p>定理：设$R$ 是$A$上的关系, 若存在自然数 $s, t (s&lt;t)$ 使得 $R^s = R^t$, 则<br>(1) 对任何 $k\in N$ 有 $R^{s+k} = R^{t+k}$<br>(2) 对任何 $k, i\in N$ 有$R^{s+kp+i} = R^{s+i}$, 其中$p = t-s$<br>(3) 令$S=\{R^0,R^1,\cdots, R^{t-1}\}$, 则对于任意的 $q\in N$有 $R^q\in S$</p><h2 id="二元关系的性质"><a href="#二元关系的性质" class="headerlink" title="二元关系的性质"></a>二元关系的性质</h2><h3 id="自反性与反自反性"><a href="#自反性与反自反性" class="headerlink" title="自反性与反自反性"></a>自反性与反自反性</h3><p>自反性：设 $R$ 为 $A$ 上的关系，若 $$\forall x(x\in A\rightarrow &lt; x,x &gt;\in R)$$ ，则称 $R$ 在 $A$ 上是自反的。<br>反自反性：设 $R$ 为 $A$ 上的关系，若 $$\forall x(x\in A\rightarrow &lt; x,x &gt;\notin R)$$ ，则称 $R$ 在 $A$ 上是反自反的。</p><h3 id="对称性与反对称性"><a href="#对称性与反对称性" class="headerlink" title="对称性与反对称性"></a>对称性与反对称性</h3><p>对称性：设 $R$ 为 $A$ 上的关系，若 $$\forall x\forall y(x,y\in A\wedge &lt; x,y &gt;\in R\rightarrow &lt; y,x &gt;\in R)$$ ，则称 $R$ 为 $A$ 上对称的关系。</p><p>反对称性：设 $R$ 为 $A$ 上的关系，若 $$\forall x\forall y(x,y\in A\wedge &lt; x,y &gt;\in R\wedge &lt; y,x &gt;\in R\rightarrow x=y)$$ ，则称 $R$ 为 $A$ 上反对称的关系。</p><h3 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h3><p>传递性：设 $R$ 为 $A$ 上的关系, 若 $$\forall x\forall y\forall z(x,y,z\in A\wedge &lt; x,y &gt;\in R\wedge &lt; y,z &gt;\in R\rightarrow &lt; x,z &gt;\in R)$$ ，则称 $R$ 是 $A$ 上的传递关系。</p><h3 id="关系性质的充要条件"><a href="#关系性质的充要条件" class="headerlink" title="关系性质的充要条件"></a>关系性质的充要条件</h3><p>设 $R$ 为 $A$ 上的关系，则</p><ol><li> $R$ 在 $A$ 上自反当且仅当 $I_A \subseteq R$ 。</li><li> $R$ 在 $A$ 上反自反当且仅当 $R\cap A=\varnothing$ 。</li><li> $R$ 在 $A$ 上对称当且仅当 $R=R^{-1}$ 。</li><li> $R$ 在 $A$ 上反对称当且仅当 $R\cap R^{-1}\subseteq I_A$ 。</li><li> $R$ 在 $A$ 上传递当且仅当 $R\circ R\subseteq R$ 。</li></ol><h3 id="关系性质判别"><a href="#关系性质判别" class="headerlink" title="关系性质判别"></a>关系性质判别</h3><table><thead><tr><th></th><th>自反</th><th>反自反</th><th>对称</th><th>反对称</th><th>传递</th></tr></thead><tbody><tr><td>表达式</td><td>$I_A \subseteq R$</td><td>$R\cap A=\varnothing$</td><td>$R=R^{-1}$</td><td>$R\cap R^{-1}\subseteq I_A$</td><td>$R\circ R\subseteq R$</td></tr><tr><td>关系矩阵</td><td>主对角线元素全是1</td><td>主对角线元素全是0</td><td>矩阵是对称矩阵</td><td>若 $r_{ij}=1$ , 且 $i\neq j$ , 则 $r_{ji}=0$</td><td>对 $M^2$ 中1所在位置, $M$ 中相应位置都是1</td></tr><tr><td>关系图</td><td>每个顶点都有环</td><td>每个顶点都没有环</td><td>如果两个顶点之间有边, 是一对方向相反的边(无单边)</td><td>如果两点之间有边, 是一条有向边(无双向边)</td><td>如果顶点 $x_i$ 连通到 $x_k$ , 则从 $x_i$ 到 $x_k$ 有边</td></tr></tbody></table><h3 id="运算与性质的关系"><a href="#运算与性质的关系" class="headerlink" title="运算与性质的关系"></a>运算与性质的关系</h3><table><thead><tr><th></th><th>自反性</th><th>反自反性</th><th>对称性</th><th>反对称性</th><th>传递性</th></tr></thead><tbody><tr><td>$R_1^{-1}$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td></tr><tr><td>$R_1 \cap R_2$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td></tr><tr><td>$R_1 \cup R_2$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\times$</td><td>$\times$</td></tr><tr><td>$R_1- R_2$</td><td>$\times$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\times$</td></tr><tr><td>$R_1 \circ R_2$</td><td>$\checkmark$</td><td>$\times$</td><td>$\times$</td><td>$\times$</td><td>$\times $</td></tr></tbody></table><h3 id="关系的闭包"><a href="#关系的闭包" class="headerlink" title="关系的闭包"></a>关系的闭包</h3><h4 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h4><p>闭包：设$R$是非空集合$A$上的关系, $R$的自反（对称或传递）闭包是$A$上的关系$R^{\prime}$, 使得$R^{\prime}$满足以下条件：<br>（1）$R^{\prime}$是自反的（对称的或传递的）。<br>（2）$R\subseteq R^{\prime}$<br>（3）对$A$上任何包含$R$的自反（对称或传递）关系 $R^{\prime \prime}$ 有 $R^{\prime}\subseteq R^{\prime \prime} $。</p><p>一般将 $R$ 的自反闭包记作 $r(R)$, 对称闭包记作 $s(R)$, 传递闭包记作 $t(R)$。</p><p>定理(不动点)：若 $R\subseteq A\times A$ ，则</p><ol><li>$R$是自反的当且仅当 $r(R)=R$</li><li>$R$是对称的当且仅当 $s(R)=R$</li><li>$R$是传递的当且仅当 $t(R)=R$</li></ol><p>定理(单调性)：若 $R,S\subseteq A\times A$ ，且 $R\subseteq S$ ，则</p><ol><li>$r(R)\subseteq r(S)$</li><li>$s(R)\subseteq s(S)$</li><li>$t(R)\subseteq t(S)$</li></ol><h4 id="闭包的构造方法"><a href="#闭包的构造方法" class="headerlink" title="闭包的构造方法"></a>闭包的构造方法</h4><p>定理：设 $R$ 为 $A$ 上的关系, 则有</p><ol><li>$r(R)=R\cup R^0$</li><li>$s(R)=R\cup R^{-1}$</li><li>$t(R)=R\cup R^2\cup \cdots$</li></ol><p>对于有穷集合 $A (|A|=n)$ 上的关系, (3)中的并最多不超过 $R^n$ 。</p><h4 id="闭包运算与性质的关系"><a href="#闭包运算与性质的关系" class="headerlink" title="闭包运算与性质的关系"></a>闭包运算与性质的关系</h4><table><thead><tr><th></th><th>自反性</th><th>对称性</th><th>传递性</th></tr></thead><tbody><tr><td>$r(R)$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td></tr><tr><td>$s(R)$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\times$</td></tr><tr><td>$t(R)$</td><td>$\checkmark$</td><td>$\checkmark$</td><td>$\checkmark$</td></tr></tbody></table><p>定理：若 $R\subseteq A\times A$ ，则</p><ol><li>$rs(R)=sr(R)$</li><li>$rt(R)=tr(R)$ </li><li>$st(R)\subseteq ts(R)$</li></ol><p>设关系 $R,r(R),s(R),t(R)$ 的关系矩阵分别为 $M, M_r, M_s$ 和 $M_t$ , 则<br>$$M_r = M + E$$<br>$$M_s = M + M^{\prime}$$<br>$$M_t = M + M^2 + M^3 + \cdots$$<br>$E$ 是和 $M$ 同阶的单位矩阵, $M^{\prime}$是 $M$ 的转置矩阵。<br>注意在上述等式中矩阵的元素相加时使用逻辑加。</p><p>设关系$R, r(R), s(R), t(R)$的关系图分别记为$G, G_r, G_s, G_t$ , 则$G_r, G_s, G_t$ 的顶点集与 $G$ 的顶点集相等. 除了 $G$ 的边以外, 以下述方法添加新边：<br>考察$G$的每个顶点, 如果没有环就加上一个环，最终得到$G_r$ 。考察$G$的每条边, 如果有一条 $x_i$ 到 $x_j$ 的单向边, $i\neq j$, 则在$G$中加一条 $x_j$ 到 $x_i$ 的反方向边，最终得到$G_s$。考察$G$的每个顶点 $x_i$, 找从 $x_i$ 出发的每一条路径，如果从 $x_i$ 到路径中任何结点 $x_j$ 没有边，就加上这条边。当检查完所有的顶点后就得到图$G_t$。</p><h4 id="传递闭包的计算——Warshall算法"><a href="#传递闭包的计算——Warshall算法" class="headerlink" title="传递闭包的计算——Warshall算法"></a>传递闭包的计算——Warshall算法</h4><p>算法思路：<br>考虑 $n+1$个矩阵的序列$M_0, M_1,\cdots , M_n$, 将矩阵 $M_k$ 的 $i$ 行$ j$<br>列的元素记作$M_k[i,j]$. 对于$k=0,1\cdots,n, M_k[i,j]=1$当且仅当在$R$ 的关系图中存在一条从 $x_i$ 到 $x_j$ 的路径，并且这条路径除端点外中间只经过 $\{x_1, x_2,\cdots, x_k\}$ 中的顶点。不难证明 $M_0$ 就是 $R$ 的关系矩阵，而 $M_n$ 就对应了 $R$ 的传递闭包。</p><p>Warshall算法：<br>从$M_0$开始，顺序计算 $M_1, M_2,\cdots,$ 直到 $M_n$ 为止。</p><h2 id="等价关系与偏序关系"><a href="#等价关系与偏序关系" class="headerlink" title="等价关系与偏序关系"></a>等价关系与偏序关系</h2><h3 id="等价关系的定义"><a href="#等价关系的定义" class="headerlink" title="等价关系的定义"></a>等价关系的定义</h3><p>等价关系：设 $R$ 为非空集合上的关系. 如果 $R$ 是自反的、<br>对称的和传递的, 则称 $R$ 为 $A$ 上的等价关系. 设 $R$<br>是一个等价关系, 若 $&lt;x,y&gt;\in R$, 称 $x$ 等价于$y$, 记做<br>$x\sim y$</p><h3 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h3><p>等价类：设$R$为非空集合A上的等价关系, $\forall x\in A$，令<br>$[x]_R = \{ y | y\in A\wedge xRy \}$<br>称 $[x]_R$ 为 $x$ 关于 $R$ 的等价类, 简称为 $x$ 的等价类, 简记为 $[x]$ 。</p><h3 id="等价类的性质"><a href="#等价类的性质" class="headerlink" title="等价类的性质"></a>等价类的性质</h3><p>定理：设$R$是非空集合$A$上的等价关系, 则<br>(1) $\forall x\in A, [x]$ 是A的非空子集.<br>(2) $\forall x, y\in A,$ 如果 $x R y$, 则 $[x]=[y]$。<br>(3) $∀x, y\in A$, 如果 $x \not Ry$, 则 $[x]$与$[y]$不交.<br>(4) $\cup \{ [x] | x\in A\}=A$，即所有等价类的并集就<br>是 $A$。</p><h3 id="商集"><a href="#商集" class="headerlink" title="商集"></a>商集</h3><p>商集：设$R$为非空集合$A$上的等价关系, 以$R$的所有等价类作为元素的集合称为$A$关于$R$的商集, 记做$A/R$, $A/R = \{ [x]R | x∈A \}$</p><h3 id="集合的划分"><a href="#集合的划分" class="headerlink" title="集合的划分"></a>集合的划分</h3><p>集合的划分：设$A$为非空集合, 若$A$的子集族$\pi (\pi \subseteq P(A))$<br>满足下面条件：<br>(1) $$\varnothing \notin \pi$$<br>(2) $$\forall x\forall y(x,y\in \pi \wedge x\neq y\rightarrow x\cap y=\varnothing)$$<br>(3) $$\cup \pi =A$$<br>则称$\pi $是$A$的一个划分, 称$\pi $中的元素为$A$的划分<br>块。</p><h3 id="等价关系与划分的一一对应"><a href="#等价关系与划分的一一对应" class="headerlink" title="等价关系与划分的一一对应"></a>等价关系与划分的一一对应</h3><p>商集 $A/R$ 就是 $A$ 的一个划分<br>不同的商集对应于不同的划分<br>任给 $A$ 的一个划分$\pi $, 如下定义 $A$ 上的关系 $$R:R = {&lt;x,y&gt; | x,y\in A\wedge x 与 y \text{在}\pi \text{的同一划分块中}}$$ 则 $R$ 为 $A$ 上的等价关系, 且该等价关系确定的商集就是 $\pi $。</p><h3 id="等价关系的计数"><a href="#等价关系的计数" class="headerlink" title="等价关系的计数"></a>等价关系的计数</h3><p>$A$ 上的等价关系计数<br>$$<br>\sum_{m=1}^n\begin{Bmatrix} n \\ m \end{Bmatrix}<br>$$<br>这里$m$表示分成$m$个等价类。 $|A|=n$。</p><p>第二类Stirling数的定义：$n$ 个不同的球恰好放到 $r$ 个相同的盒子里的方法数称为第二类 Stirling 数，记作<br>$$<br>\begin{Bmatrix} n \\ m \end{Bmatrix}<br>$$<br>递推方程：<br>$$<br>\begin{Bmatrix} n \\ r \end{Bmatrix}=r \begin{Bmatrix} n-1 \\ r \end{Bmatrix}+\begin{Bmatrix} n-1 \\ r-1 \end{Bmatrix},\begin{Bmatrix} n \\ 0 \end{Bmatrix}=0,\begin{Bmatrix} n \\ 1 \end{Bmatrix}=1<br>$$</p><p>$$<br>\begin{Bmatrix} n \\ 2 \end{Bmatrix}=2^{n-1}-1,\begin{Bmatrix} n \\ n-1 \end{Bmatrix}=\begin{Bmatrix} n \\ 2 \end{Bmatrix}<br>$$</p><h3 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h3><p>偏序关系：非空集合$A$上的自反、反对称和传递的关系，称为$A$上的偏序关系，记作$\preccurlyeq $。 设$\preccurlyeq $为偏序关系, 如<br>果$&lt;x, y&gt;\in \preccurlyeq $, 则记作 $x\preccurlyeq y$, 读作 $x$“小于或等于”$y$。</p><p>$x$与 $y$ 可比：设$R$为非空集合$A$上的偏序关系,<br>$x,y\in A,$ $x$与$y$可比 $\Leftrightarrow  x\preccurlyeq y \vee y\preccurlyeq x$。</p><p>全序关系：$R$为非空集合$A$上的偏序, $\forall x,y\in A$, $x$与 $y$ 都是可比的，则称 $R$ 为全序（或 线序）。</p><p>覆盖：设$R$为非空集合A上的偏序关系, $x, y\in A$, 如<br>果 $x \preccurlyeq y$且不存在 $z\in A$ 使得 $x \preccurlyeq  z \preccurlyeq  y$, 则称 $y$ 覆盖 $x$ 。</p><h3 id="偏序集与哈斯图"><a href="#偏序集与哈斯图" class="headerlink" title="偏序集与哈斯图"></a>偏序集与哈斯图</h3><p>偏序集：集合$A$和$A$上的偏序关系$\preccurlyeq $一起叫做偏序集, 记作 $&lt;A,\preccurlyeq &gt;$。</p><p>哈斯图：利用偏序自反、反对称、传递性简化的关系图。</p><h3 id="偏序集的特定元素"><a href="#偏序集的特定元素" class="headerlink" title="偏序集的特定元素"></a>偏序集的特定元素</h3><p>定义 设$&lt;A,\preccurlyeq &gt;$为偏序集, $B\subseteq A, y\in B$。<br>(1) 若$\forall x(x\in B\rightarrow y\preccurlyeq x)$ 成立, 则称 $y$ 为 $B$ 的最小元。<br>(2) 若$\forall x(x\in B→x\preccurlyeq y)$ 成立, 则称 $y$ 为 $B$ 的最大元。<br>(3) 若$\neg \exists x (x\in B\wedge x&lt; y) $成立, 则称 $y$ 为$B$的极小元。<br>(4) 若$\neg \exists x (x\in B\wedge y&lt;x)$ 成立, 则称 $y$ 为$B$的极大元。</p><p>定义 设$&lt;A, \leq&gt;$为偏序集, $B\subseteq A$, $y\in A$。<br>(1) 若$\forall x(x\in B\rightarrow x\preccurlyeq y)$ 成立, 则称 $y$ 为 $B$ 的上界。<br>(2) 若$\forall x(x\in B\rightarrow y\preccurlyeq x)$ 成立, 则称 $y$ 为 $B$ 的下界.<br>(3) 令 $C＝\{y | y\text{为}B\text{的上界}\}$ , 则称$C$的最小元为$B$的最小上界或上确界。<br>(4) 令 $D＝\{y | y\text{为}B\text{的下界}\}$, 则称$D$的最大元为$B$的最大下界或下确界。</p><h3 id="特殊元素的性质"><a href="#特殊元素的性质" class="headerlink" title="特殊元素的性质"></a>特殊元素的性质</h3><ul><li>对于有穷集，极小元和极大元必存在，可能存在多个。</li><li>最小元和最大元不一定存在，如果存在一定惟一。</li><li>最小元一定是极小元；最大元一定是极大元。</li><li>孤立结点既是极小元，也是极大元。</li><li>下界、上界、下确界、上确界不一定存在。</li><li>下界、上界存在不一定惟一。</li><li>下确界、上确界如果存在，则惟一。</li><li>集合的最小元就是它的下确界，最大元就是它的上确界；反之不对。</li></ul><h3 id="偏序集的特殊子集"><a href="#偏序集的特殊子集" class="headerlink" title="偏序集的特殊子集"></a>偏序集的特殊子集</h3><p>定义：设$&lt;A,\preccurlyeq &gt;$为偏序集, $B\subseteq A$。<br>(1) 如果$\forall x,y\in B$，$x$与$y$都是可比的，则称$B$是$A$中的一条链，$B$中的元素个数称为链的长度；<br>(2) 如果$\forall x,y\in B$，$x\neq y$，$x$与$y$都是不可比的，则称$B$是$A$中的一条反链，$B$中的元素个数称为反链的长度。</p><h3 id="分解为反链"><a href="#分解为反链" class="headerlink" title="分解为反链"></a>分解为反链</h3><p>定理：设$&lt;A,\preccurlyeq &gt;$为偏序集，如果$A$中最长的链长度为$n$, 则<br>$A$中存在极大元，且该偏序集可以分解为 $n$ 条不相交的反链。</p><p>定理：设$&lt;A,\preccurlyeq &gt;$为含$mn+1$个元素的偏序集，则$A$中存在长<br>度为$m+1$的反链, 或长度为$n+1$的链。</p><h3 id="拟序关系"><a href="#拟序关系" class="headerlink" title="拟序关系"></a>拟序关系</h3><p>拟序关系：设 $A\neq \varnothing$ ， $R\subseteq A\times A$ 。若 $R$ 是反自反，传递的，就称 $R$ 为 $A$ 上的拟序关系，常用 $\prec$ 表示拟序关系，称 $&lt;A,\prec&gt;$ 为拟序集。</p><h3 id="拟序和偏序"><a href="#拟序和偏序" class="headerlink" title="拟序和偏序"></a>拟序和偏序</h3><p>定理：设 $\preccurlyeq$ 是非空集合 $A$ 上的偏序关系， $\prec $ 是 $A$ 上的拟序关系，则</p><ol><li> $\prec $ 是反对称的。</li><li> $\preccurlyeq -I_A$ 是 $A$ 上的拟序关系。</li><li> $\prec \cup I_A$ 是 $$ 上的偏序关系。</li></ol><h3 id="三歧性，拟线序"><a href="#三歧性，拟线序" class="headerlink" title="三歧性，拟线序"></a>三歧性，拟线序</h3><p>三歧性：设 $A\neq \varnothing$ ， $\prec $ 是 $A$ 上拟序关系，若<br>$$<br>x\prec y,x=y,y\prec x<br>$$<br>中有且仅有一式成立，则称 $\prec $ 具有三歧性。同时称 $\prec $ 为 $A$ 上的拟线序关系（拟全序关系），称 $&lt;A,\prec &gt;$ 为拟线序集。</p><h3 id="良序关系"><a href="#良序关系" class="headerlink" title="良序关系"></a>良序关系</h3><p>良序集：设 $&lt;A,\prec &gt;$ 为（拟）全序集，若 $A$ 任何非空子集 $B$ 均有最小元，则称 $\prec $ 为 $A$ 上的良序关系，称 $&lt;A,\prec &gt;$ 为良序集。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>函数：设 $F$ 为二元关系, 若 $x\in \mathrm{dom}F$ 都存在唯一 $y\in \mathrm{ran}F$ 使 $xFy$ 成立, 则称 $F$ 为函数。对于函数 $F$ , 如果有 $xFy$ , 则记作 $y=F(x)$, 并称 $y$ 为 $F$ 在 $x$ 的值. </p><p>函数相等:设$F, G$为函数, 则 $F=G\Leftrightarrow F\subseteq G\vee G\subseteq F$<br>如果两个函数 $F$ 和 $G$ 相等, 一定满足下面两个条件：<br>(1) $\mathrm{dom}F = \mathrm{dom}G$<br>(2) $\forall x\in \mathrm{dom}F=\mathrm{dom}G$ 都有 $F(x) = G(x)$。</p><p>从 $A$ 到 $B$ 的函数：设$A, B$为集合, 如果 $f$ 为函数 $\mathrm{dom}f = A$ ，$\mathrm{ran}f = B$, 则称 $f$ 为从$A$到$B$的函数, 记作 $f：A\rightarrow B$</p><p>$B$上$A$：所有从 $A$ 到 $B$ 的函数的集合记作 $B^A$, 读作“$B$上$A$”，符号化表示为 $B^A=\{ f|f:A\rightarrow B \}$</p><p>函数的像：设函数 $f：A\rightarrow B,A_1\subseteq A$在 $f$ 下的像： $f(A_1) = \{ f(x) | x\in A_1 \}$ 函数的像 $f(A)$。</p><h3 id="函数的性质"><a href="#函数的性质" class="headerlink" title="函数的性质"></a>函数的性质</h3><p>定义：设 $f:A\rightarrow B$ ，</p><ol><li>若 $\mathrm{ran}f=B$ ，则称 $f:A\rightarrow B$ 是满射。</li><li>若 $\forall y\in \mathrm{ran}f$ 都存在唯一的 $x\in A$ 使得 $f(x)=y$ ，则称 $f:A\rightarrow B$ 是单射的。</li><li>若 $f:A\rightarrow B$ 既是满射又是单射的，则称 $f:A\rightarrow B$ 是双射的。</li></ol><p> $f$ 满射意味着： $\forall y \in B$ ，都存在 $x\in A$ 使得 $f(x)=y$ 。<br> $f$ 单射意味着： $f(x_1)=f(x_2)\Rightarrow x_1=x_2$ 。</p><p>常函数：设 $f:A\rightarrow B$ ，若存在 $c\in B$ 使得 $\forall x\in A$ 都有 $f(x)=c$ ，则称 $f:A\rightarrow B$ 是常函数。</p><p>恒等函数：称 $A$ 上的恒等关系 $I_A$ 为 $A$ 上的恒等函数，对于所有的 $x\in A$ 都有 $I_A(x)=x$ 。</p><p>单调性：设 $f:R\rightarrow$ ，如果对于任意的 $x_1,x_2\in R$ ， $x_1&lt;x_2$ ，就有 $f(x_1)\leq f(x_2)$ ，则称 $f$ 为单调递增的；如果对于任意的 $x_1,x_2\in R$ ， $x_1&lt;x_2$ ，就有 $f(x_1)&lt; f(x_2)$ ，则称 $f$ 为严格单调递增的。类似的可以定义单调递减和严格单调递减的函数。</p><p>集合的特征函数：设 $A$ 为集合， $\forall A^{\prime}\subseteq A$ ， $A^{\prime}$ 的特征函数 $\chi_{A^{\prime}}:A\rightarrow \{ 0,1 \}$ 定义为<br>$$<br>\chi_{A^{\prime}}(a)=\begin{cases} 1,a\in A^{\prime} \\ 0,a\in A-A^{\prime} \end{cases}<br>$$</p><p>自然映射：设 $R$ 是 $A$ 上的等价关系，令<br>$$<br>g:A\rightarrow A/R \quad g(\alpha)=[\alpha],\forall \alpha \in A<br>$$<br>称 $g$ 是从 $A$ 到商集 $A/R$ 的自然映射。</p><h3 id="函数的复合与反函数"><a href="#函数的复合与反函数" class="headerlink" title="函数的复合与反函数"></a>函数的复合与反函数</h3><p>定理：设 $F,G$ 是函数，则 $F\circ G$ 也是函数，且满足<br> (1) $$\mathrm{dom}(F\circ G)={ x | x\in \marthm{dom}F \wedge F(x)\in \mathrm{dom} G}$$<br> (2) $\forall x\in \mathrm{dom}(F\circ G)$ 有 $F\circ G(x) = G(F(x))$</p><p>推论：设 $F,G,H$ 为函数，则 $(F\circ G)\circ H$ 和 $F\circ (G\circ H)$ 都是函数，且 $(F\circ G)\circ H=F\circ (G\circ H)$ 。</p><p>推论：设 $f:A\rightarrow B$ ， $g:B\rightarrow C$ ，则 $f\circ g:A\rightarrow C$ ，且 $\forall x\in A$ 都有 $f\circ g(x)=g(f(x))$ 。</p><p>定理：设 $f:A\rightarrow B$ ， $g:B\rightarrow C$ </p><ol><li>如果 $f:A\rightarrow B$ ， $g:B\rightarrow C$ 都是满射的，则 $f\circ g:A\rightarrow C$ 也是满射的。</li><li>如果 $f:A\rightarrow B$ ， $g:B\rightarrow C$ 都是单射的，则 $f\circ g:A\rightarrow C$ 也是单射的。</li><li>如果 $f:A\rightarrow B$ ， $g:B\rightarrow C$ 都是双射的，则 $f\circ g:A\rightarrow C$ 也是双射的。</li></ol><p>定理：设 $f:A\rightarrow B$ 是双射的，则 $f^{-1}:B\rightarrow A$ 也是双射的。</p><p>反函数：对于双射函数 $f:A\rightarrow B$ ，称 $f^{-1}:B\rightarrow A$ 是它的反函数。</p><p>定理：设 $f:A\rightarrow B$ 是双射的，则<br>$$<br>f^{-1}\circ f=I_B,f\circ f^{-1}=I_A<br>$$<br>定理：设 $f:A\rightarrow B$ ， $g:B\rightarrow C$ </p><ol><li>如果 $f\circ g$ 是满射的，则 $g$ 是满射的。</li><li>如果 $f\circ g$ 是单射的，则 $f$ 是单射的。</li><li>如果 $f\circ g$ 是双射的，则 $g$ 是满射的， $f$ 是单射的。</li></ol><p>左逆右逆：设 $f:A\rightarrow B$ ， $g:B\rightarrow A$ ，若 $f\circ g=I_A$ ，则称 $g$ 为 $f$ 的右逆函数， $f$ 为 $g$ 的左逆函数。</p><p>定理：</p><p>设 $f:A\rightarrow B$,<br>(1) $f$有右逆函数，当且仅当$f$是单射的。<br>(2) $f$有左逆函数，当且仅当$f$是满射的。<br>(3) $f$有左逆和右逆函数，当且仅当$f$是双射的。<br>(4) 如果$f$是双射函数，则$f$的左逆和右逆函数相等。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字逻辑</title>
    <link href="/archives/812c5abc.html"/>
    <url>/archives/812c5abc.html</url>
    
    <content type="html"><![CDATA[<p>数字逻辑其实就是数字电路。数字电路隔壁电光专业要大二下学期才学，我们计算机科学与技术的却要大二上学期就学。（虽然我们学的应该比较简单）。这门课主要就是教我们设计数字电路的，对今后计算机组成等方面的学习还是有很大的帮助的。</p><span id="more"></span><h1 id="数字逻辑"><a href="#数字逻辑" class="headerlink" title="数字逻辑"></a>数字逻辑</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>数字信号</strong>：若信号的变化在时间上和数值上都是离散的，或者说断续的，则称为<strong>离散信号</strong>。离散信号的变化可以用不同的数字反映，所以又称为<strong>数字信号</strong>，简称为<strong>数字量</strong>。</p><p><strong>数字电路</strong>： 用来处理数字信号的电子线路称为<strong>数字电路</strong>。 用来处理数字信号的电子线路称为<strong>数字电路</strong>。</p><p><strong>数字逻辑电路的类型</strong>（根据一个电路是否具有<strong>记忆</strong>功能）：</p><ul><li>组合逻辑电路</li></ul><p>组合逻辑电路 : 如果一个逻辑电路在任何时刻的稳定输出仅取决于该时刻的输入，而与电路过去的输入无关，则称为组合逻辑(Combinational Logic)电路。</p><ul><li>时序逻辑电路</li></ul><p>时序逻辑电路:  如果一个逻辑电路在任何时刻的稳定输出不仅取决于该时刻的输入，而且与过去的输入相关，则称为时序逻辑(Sequential Logic)电路。</p><p>时序逻辑电路按照是否有统一的时钟信号进行同步，又可进一步分为<strong>同步时序逻辑电路</strong>和<strong>异步时序逻辑电路</strong>。</p><h3 id="数制及其转换"><a href="#数制及其转换" class="headerlink" title="数制及其转换"></a>数制及其转换</h3><p><strong>R进制</strong>：</p><p>广义地说，一种进位计数制包含着<strong>基数</strong>和<strong>位权</strong>两个基本的因素：</p><p><strong>基数</strong>: 指计数制中所用到的数字符号的个数。在基数为R计数制中，包含0、1、…、R-1共R个数字符号，进位规律是“逢R进一”。称为<strong>R进位计数制</strong>，简称<strong>R进制</strong>。</p><p><strong>位权</strong>: 是指在一种进位计数制表示的数中，用来表明不同数位上数值大小的一个固定常数。不同数位有不同的位权，某一个数位的数值等于这一位的数字符号乘上与该位对应的位权。<strong>R进制数的位权是R的整数次幂。</strong></p><p>一个R进制数N可以有两种表示方法：</p><ul><li><strong>并列表示法</strong>（位置计数法）</li></ul><p>$$<br>N_R=(K_{n-1} K_{n-2} \cdots K_1 K_0.K_{-1} K_{-2} \cdots K_{-m})_R<br>$$</p><ul><li><strong>多项式表示法</strong>（按权展开法）</li></ul><p>$$<br>N_R = (K_{n-1} \times R^{n-1}+K_{n-2} \times R^{n-2}+ \cdots K_{1} \times R^{1}+K_{0} \times R^{0}+K_{-1} \times R^{-1}+ \cdots K_{-m} \times R^{-m})_R<br>$$</p><p>基数<strong>R=2</strong>的进位计数制称为二进制。二进制数中只有0和1两个基本数字符号，进位规律是“逢二进一”。二进制数的位权是2的整数次幂。</p><p>数字系统中普遍采用二进制,通常采用八进制数和十六进制数作为二进制数的缩写。</p><p>基数<strong>R=8</strong>的进位计数制称为八进制。八进制数中有0、1、…、7共8个基本数字符号，进位规律是“逢八进一”。八进制数的位权是8的整数次幂。</p><p>基数<strong>R=16</strong>的进位计数制称为十六进制。十六进制数中有0、1、…、9、A、B、C、D、E、F共16个数字符号，其中，A～F分别表示十进制数的10～15。进位规律为“逢十六进一”。十六进制数的位权是16的整数次幂。</p><p>数制转换</p><ol><li>二进制与十进制之间的转换</li></ol><ul><li><p><strong>二进制转十进制</strong><br>多项式替代法：将二进制数表示成按权展开式，并按十进制运算法则进行计算，所得结果即为该数对应的十进制数。</p></li><li><p><strong>十进制转二进制</strong><br>基数乘除法：十进制数转换成二进制数时，应对整数和小数分别进行处理。<br>整数转换——采用“除2取余”的方法；<br>小数转换——采用“乘2取整”的方法。</p></li></ul><ol start="2"><li>二进制数与八进制数、十六进制数之间的转换</li></ol><ul><li><strong>二进制数转换成八进制数</strong>：以小数点为界，分别往高、往低每3位为一组，最后不足3位时用0补充，然后写出每组对应的八进制字符，即为相应八进制数。</li><li><strong>二进制数转换成十六进制数</strong>：以小数点为界，分别往高、往低每4位为一组，最后不足4位时用0补充，然后写出每组对应的十六进制字符即可。 </li></ul><h3 id="带符号二进制数的代码表示"><a href="#带符号二进制数的代码表示" class="headerlink" title="带符号二进制数的代码表示"></a>带符号二进制数的代码表示</h3><p><strong>原码</strong>：<br>符号位用0表示正，1表示负；数值位保持不变。原码表示法又称为<strong>符号—数值表示法</strong>。</p><p><strong>反码</strong>：</p><p>带符号二进制数的反码表示：</p><p>符号位———用0表示正，用1表示负；</p><p>数值位———正数反码的数值位和真值的数值位相同；而负数反码的数值位是真值的数值位按位变反。</p><p>加减运算：</p><p>$$［X_1 + X_2］_反 =［X_1］_反 +［X_2］_反$$<br>$$［X_1 – X_2］_反 =［X_1］_反 +［-X_2］_反$$</p><p><strong>补码</strong>：</p><p>带符号二进制数的补码表示：</p><p>符号位——用0表示正，用1表示负；</p><p>数值位——正数补码的数值位与真值相同；负数补码的数值位是真值的数值位按位变反，并在最低位加1。</p><p>加减运算：</p><p>$$［X_1 + X_2］_补 =［X_1］_补 +［X_2］_补$$<br>$$［X_1 – X_2］_补 =［X_1］_补 +［-X_2］_补$$</p><h3 id="几种常用的编码"><a href="#几种常用的编码" class="headerlink" title="几种常用的编码"></a>几种常用的编码</h3><p><strong>十进制数的二进制编码（BCD码）</strong>：用4位二进制代码对十进制数字符号进行编码，简称为二–十进制代码，或称BCD(Binary Coded Decimal)码。</p><ul><li><p><strong>8421码</strong>：是用4位二进制码表示一位十进制字符的一种有权码，4位二进制码从高位至低位的权依次为23、22、21、20，即为8、4、2、1,故称为8421码。<br>8421码与十进制数之间的转换是按位进行的，即十进制数的每一位与4位二进制编码对应。</p></li><li><p><strong>2421码</strong>: 是用4位二进制码表示一位十进制字符的另一种有权码，4位二进制码从高位至低位的权依次为2、4、2、1,故称为2421码。<br>2421码与十进制数之间的转换同样是按位进行的。</p><ol><li>2421码不具备单值性。例如，0101和1011都对应十进制数字5。为了与十进制字符一一对应，2421码不允许出现0101～1010的6种状态。</li><li>2421码是一种对9的自补代码。即一个数的2421码只要自身按位变反，便可得到该数对9的补数的2421码。</li></ol></li><li><p><strong>余3码</strong>：是由8421码加上0011形成的一种无权码，由于它的每个字符编码比相应8421码多3，故称为余3码。</p><ol><li>余3码中不允许出现0000、0001、0010、1101、1110和1111六种状态。</li><li>余3码与十进制数进行转换时，每位十进制数字的编码都应余3。</li><li>余3码是一种对9的自补代码。</li></ol></li></ul><p><strong>可靠性编码</strong></p><ul><li><p>格雷码：</p><p>转换规则：</p><p>设二进制码为 $B=B_{n-1}B_{n-2} \cdots B_{i+1}B_i \cdots B_1B_0$</p><p>对应格雷码为 $G=G_{n-1}G_{n-2} \cdots G_{i+1}G_i \cdots G_1G_0$</p></li></ul><p>$$<br>G_{n-1} = B_{n-1}<br>$$</p><p>$$<br>G_i = B_{i+1}⊕B_i  \quad  0 ≤  i≤ n-2<br>$$</p><p>  其中，运算“⊕”称为“<strong>异或</strong>”运算，运算规则是：</p><p>  0⊕0=0；  0⊕1=1； </p><p>  1⊕0=1；  1⊕1=0。</p><ul><li><p>奇偶检验码：</p><p>组成：<strong>信息位</strong>——位数不限的一组二进制代码+<strong>奇偶检验位</strong>——仅有一位。</p><p>编码方式：有两种编码方式.</p><p>奇检验:使信息位和检验位中“1”的个数共计为奇数；</p><p>偶检验:使信息位和检验位中“1”的个数共计为偶数。</p></li></ul><ul><li>字符编码：<br>最常用的字符编码是美国信息交换标准码，简称<strong>ASCII码</strong>(American Standard Code for Information Interchange)。ASCII码用7位二进制码表示128种字符，由于数字系统中实际是用一个字节表示一个字符，所以使用ASCII码时，通常在最左边增加一位奇偶检验位。 </li></ul><h2 id="逻辑代数基础"><a href="#逻辑代数基础" class="headerlink" title="逻辑代数基础"></a>逻辑代数基础</h2><h3 id="逻辑代数的基本概念"><a href="#逻辑代数的基本概念" class="headerlink" title="逻辑代数的基本概念"></a>逻辑代数的基本概念</h3><p>逻辑代数L是一个封闭的代数系统，它由一个逻辑变量集K，常量0和1以及“或”、“与”、“非”三种基本运算所构成，记为 $L=\{K,+,·, ¯,0,1\}$ 。该系统应满足下列公理</p><ul><li><p>交换律：对于任意逻辑变量 $A,B$ ，有 $A + B = B + A$ ； $A·B = B ·A$ </p></li><li><p>结合律：对于任意的逻辑变量 $A,B,C$ ，有 $(A + B) + C = A + ( B + C )$ ， $( A·B )· C = A·( B· C )$</p></li><li><p>分配律：对于任意的逻辑变量 $A,B,C$ ，有 $A + ( B·C ) = (A + B)·(A + C) $ ； $A·( B + C) = A·B + A·C$</p></li><li><p>0─1 律：对于任意逻辑变量 $A$ ，有 $A + 0 = A$  ； $A \cdot 1 = A$ $A + 1 = 1$  ； $A \cdot 0 = 0$ </p></li><li><p>互补律：对于任意逻辑变量 $A$ ，存在唯一的 $\overline{A}$ ，使得 $\overline{A}+A=1 \quad \overline{A}\cdot A=0$ 。</p></li></ul><p>逻辑代数中定义了“或”、“与” 、“非”三种基本运算。<br>1．“或”运算<br>　　如果决定某一事件是否发生的多个条件中，只要有一个或一个以上条件成立，事件便可发生，则这种因果关系称之为“或”逻辑。</p><p>2．“与” 运算<br>　　如果决定某一事件发生的多个条件必须同时具备，事<br>件才能发生，则这种因果关系称之为“与”逻辑。</p><p>3．“非” 运算<br>　　如果某一事件的发生取决于条件的否定，即事件与事件发生的条件之间构成矛盾，则这种因果关系称为“非”逻辑。</p><p>设某一逻辑电路的输入逻辑变量为 $A_1,A_2,\cdots,A_n$ ，输出逻辑变量为 $F$ ， $F$ 被称为 $A_1,A_2,\cdots,A_n$ 的逻辑函数，记为 $F = f( A1，A2，…，An )$ 。</p><p>逻辑函数的表示法：</p><ul><li>逻辑表达式：是由逻辑变量和“或”、“与”、“非”3种运算符以及括号所构成的式子。</li><li>真值表：依次列出一个逻辑函数的所有输入变量取值组合及其相应函数值的表格称为真值表。一个 $n$ 个变量的逻辑函数，其真值表有 $2^n$ 行。</li><li>卡诺图：卡诺图是由表示逻辑变量所有取值组合的小方格所构成的平面图。</li></ul><h3 id="逻辑代数的基本定理和规则"><a href="#逻辑代数的基本定理和规则" class="headerlink" title="逻辑代数的基本定理和规则"></a>逻辑代数的基本定理和规则</h3><h4 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理:"></a>基本定理:</h4><ul><li>定理1<br>$$0 + 0 = 0　1 + 0 = 1$$<br>$$0 \cdot 0 = 0　1 \cdot 0 = 0$$<br>$$0 + 1 = 1　1 + 1 = 1$$<br>$$0 \cdot 1 = 0　1 \cdot 1 = 1$$</li><li>定理2<br>$$A + A = A $$<br>$$ A \cdot A = A$$</li><li>定理3<br>$$A + A \cdot B = A $$<br>$$ A \cdot ( A + B ) = A$$</li><li>定理4<br>$$A+A·B = A+B $$<br>$$ A·(A+B) = A·B$$</li><li>定理5<br>$$\overline{\overline{A}}=A$$</li><li>定理6<br>$$\overline{A+B}=\overline{A}\cdot \overline{B} $$<br>$$\overline{A\cdot B}=\overline{A} + \overline{B}$$</li><li>定理7<br>$$A\cdot B+A\cdot \overline{B} = A  $$<br>$$( A + B ) \cdot ( A+ \overline{B}) = A$$</li><li>定理8<br>$$A\cdot B+\overline{A}\cdot C+B\cdot C=A\cdot B+\overline{A}\cdot C $$ $$ (A+B)\cdot (\overline{A}+C)\cdot (B+C)=(A+B)\cdot \overline{A}+C)$$</li></ul><h4 id="重要规则："><a href="#重要规则：" class="headerlink" title="重要规则："></a>重要规则：</h4><ul><li>代入规则：任何一个含有变量$A$的逻辑等式,如果将所有出现A的位置都代之以同一个逻辑函数$F$，则等式仍然成立。这个规则<br>称为代入规则。</li><li>反演规则：若将逻辑函数表达式F中所有的“·”变成“+”，“+”变<br>成“·”,“0”变成“1”,“1”变成“0”,原变量变成反变量，反变<br>量变成原变量，并保持原函数中的运算顺序不变，则所<br>得到的新的函数 $\overline{F}$ 为原函数$F$的反函数。</li><li>对偶规则：如果将逻辑函数表达式F中所有的“·”变成“+”,“+”变成“·”，“0”变成“1”，“1”变成“0”，并保持原函数中的运算顺序不变，则所得到的新的逻辑表达式称为函数F的对偶式，并记作$F^{\prime}$。</li></ul><h4 id="复合逻辑"><a href="#复合逻辑" class="headerlink" title="复合逻辑"></a>复合逻辑</h4><ul><li>与非逻辑<br>与非逻辑是由与、非两种逻辑复合形成的，可用逻辑函数表示为 $F=\overline{A\cdot B\cdot C\cdots}$ 。<br>逻辑功能：只要变量 $A,B,C,\cdots$ 中有一个为0，则函数 $F$ 为1；仅当变量 $A,B,C,\cdots$ 全部为1时，函数 $F$ 为0。<br>实现与非逻辑的门电路称为“与非”门。<br>只要有了与非门便可组成实现各种逻辑功能的电路，通常称与非门为通用门。</li></ul><ul><li>或非逻辑<br>或非逻辑是由或、非两种逻辑复合形成的，可表示为 $F=\overline{A+B+C+\cdots}$ 。<br>逻辑功能：只要变量 $A,B,C,\cdots$ 中有一个为1，则函数 $F$ 为0；仅当变量 $A,B,C,\cdots$ 全部为0时，函数 $F$ 为1。实现或非逻辑的门电路称为“或非”门。<br>或非门同样可实现各种逻辑功能，是一种通用门。</li></ul><ul><li><p>与或非逻辑<br>与或非逻辑是由3种基本逻辑复合形成的，逻辑函数表达式的形式为 $F=\overline{AB+CD+\cdots}$ 。<br>逻辑功能：仅当每一个“与项”均为0时，才能使F为1，否则F为0。<br>　实现与或非功能的门电路称为“与或非”门。</p></li><li><p>异或逻辑及同或逻辑</p><ol><li>异或逻辑<br>异或逻辑是一种两变量逻辑关系，可用逻辑函数表示为 $S=A\oplus B=\overline{A}B+A \overline{B}$ 。<br>逻辑功能：变量 $A,B$ 取值相同， $F$ 为0；变量 $A,B$ 取值相异， $F$ 为1。<br>实现异或运算的逻辑门称为“异或门”。<br>在进行异或运算的多个变量中，若有奇数个变量的值为1，则运算结果为1；若有偶数个变量的值为1，则运算结果为0。</li><li>同或逻辑<br>同或逻辑也是一种两变量逻辑关系，其逻辑函数表达式为 $F=A \odot B=\overline{A}\cdot \overline{B}+AB$ 。<br>功能逻辑：变量 $A,B$ 取值相同， $F$ 为1；变量 $A,B$ 取值相异， $F$ 为0。<br>实现同或运算的逻辑门称为“同或门”。<br>当多个变量进行同或运算时，若有奇数个变量的值为0，则运算结果为0；反之，若有偶数个变量的值为0，则运算结果为1。 </li></ol><p>同或逻辑与异或逻辑的关系既互为相反，又互为对偶。<br>$$<br>\overline{A\oplus B}=\overline{A\overline{B}+\overline{A}B}=(\overline{A}+B)(A+\overline{B})=AB+\overline{A}\cdot \overline{B}=A\odot B<br>$$</p><p>$$<br>(A\oplus B)^{\prime} = (A\overline{B}+\overline{A}B)^{\prime}=(A+\overline{B})(\overline{A}+B)=\overline{A} \cdot \overline{B}+AB=A\odot B<br>$$</p></li></ul><h3 id="逻辑函数表达式的形式与变换"><a href="#逻辑函数表达式的形式与变换" class="headerlink" title="逻辑函数表达式的形式与变换"></a>逻辑函数表达式的形式与变换</h3><h4 id="逻辑函数表达式的两种基本形式"><a href="#逻辑函数表达式的两种基本形式" class="headerlink" title="逻辑函数表达式的两种基本形式"></a>逻辑函数表达式的两种基本形式</h4><p>两种基本形式：指“与-或”表达式和“或-与”表达式。</p><p>“与-或”表达式：是指由若干“与项”进行“或”运算构成的表达式。</p><p>“或-与”表达式：是指由若干“或项”进行“与”运算构成的表达式。</p><p>逻辑函数表达式可以被表示成任意的混合形式。</p><p>逻辑函数的基本形式都不是唯一的。</p><h4 id="逻辑函数表达式的标准形式"><a href="#逻辑函数表达式的标准形式" class="headerlink" title="逻辑函数表达式的标准形式"></a>逻辑函数表达式的标准形式</h4><p>一、最小项和最大项</p><p>最小项：如果一个具有 $n$ 个变量的函数的“与项”包含全部 $n$ 个变量，每个变量都以原变量或反变量形式出现一次，且仅出现一次，则该“与项”被称为最小项。有时又将最小项称为标准“与项”。</p><p>最小项的数目： $n$ 个变量可以构成 $2^n$ 个最小项。</p><p>简写：用 $m_i$ 表示最小项。下标 $i$ 的取值规则是：按照变量顺序将最小项中的原变量用1表示，反变量用0表示，由此得到一个二进制数，与该二进制数对应的十进制数即下标 $i$ 的值。</p><p>性质——最小项具有如下四条性质。</p><p>性质1：任意一个最小项，其相应变量有且仅有一种取值使这个最小项的值为1。并且，最小项不同，使其值为1的变量取值不同。</p><p>性质2：相同变量构成的两个不同最小项相“与” 为0。因为任何一种变量取值都不可能使两个不同最小项同时为1，故相“与”为0。即 $m_i\cdot m_j =0$ 。</p><p>性质3： $n$ 个变量的全部最小项相“或”为1。通常借用数学中的累加符号，将其记为 $\sum_{i=0}^{2^n-1}m_i=1$ 。</p><p>性质4： $n$ 个变量构成的最小项有 $n$ 个相邻最小项。相邻最小项：是指除一个变量互为相反外，其余部分均相同的最小项。例如，三变量最小项 $ABC$ 和相邻 $\overline{A}BC$ 。</p><p>最大项：如果一个具有n个变量函数的“或项”包含全部n个变量，每个变量都以原变量或反变量形式出现一次，且仅出现一次，则该“或项”被称为最大项。有时又将最大项称为标准“或项”。</p><p>最大项的数目： $n$ 个变量可以构成 $2^n$ 个最大项。</p><p>简写：用 $M_i$ 表示最大项。下标 $i$ 的取值规则是：将最大项中的原变量用0表示，反变量用1表示，由此得到一个二进制数，与该二进制数对应的十进制数即下标 $i$ 的值。</p><p>性质：最大项具有如下四条性质。</p><p>性质1  任意一个最大项，其相应变量有且仅有一种取值使这个最大项的值为0。并且，最大项不同，使其值为0的变量取值不同。在 $n$ 个变量构成的任意“或项”中，最大项是使其值为1的变量取值组合数最多的一种“或项”，因而将其称为最大项。</p><p>性质2  相同变量构成的两个不同最大项相“或”为1。<br>因为任何一种变量取值都不可能使两个不同最大项同时为<br>0，故相“或”为1。即 $M_i+M_j=1$ 。</p><p>性质3  $n$ 个变量的全部最大项相“与”为0。通常借用数学中的累乘符号将其记为 $\prod_{i=0}^{2^n-1}M_i=0$ 。</p><p>性质4  $n$ 个变量构成的最大项有 $n$ 个相邻最大项。相邻最大项是指除一个变量互为相反外，其余变量均相同的最大项。</p><p>最小项和最大项的关系：在同一问题中，下标相同的最小项和最大项互为反函数。或者说，相同变量构成的最小项mi和最大项Mi之间存在互补关系。即 $m_i = \overline{M_i}$ 。</p><h4 id="逻辑函数表达式的标准形式-1"><a href="#逻辑函数表达式的标准形式-1" class="headerlink" title="逻辑函数表达式的标准形式"></a>逻辑函数表达式的标准形式</h4><p>逻辑函数表达式的标准形式有标准“与-或”表达式和标准“或-与”表达式两种类型。</p><p>1．标准“与 - 或”表达式<br>由若干最小项相“或”构成的逻辑表达式称为标准“与-或”表达式，也叫做最小项表达式。</p><p>2．标准“或-与”表达式<br>由若干最大项相“与”构成的逻辑表达式称为标准“或-与”表达式，也叫做最大项表达式 。</p><h4 id="逻辑函数表达式的转换"><a href="#逻辑函数表达式的转换" class="headerlink" title="逻辑函数表达式的转换"></a>逻辑函数表达式的转换</h4><p>一、代数转换法 </p><p>所谓代数转换法，就是利用逻辑代数的公理、定理和规则进行逻辑变换，将函数表达式从一种形式变换为另一种形式。 </p><p>1 . 求标准“与-或” 式</p><p>一般步骤如下：<br>第一步：将函数表达式变换成一般“与-或”表达式。<br>第二步：反复使用 $X=X(Y+\overline{Y})$ 将表达式中所有非<br>最小项的“与项”扩展成最小项。</p><p>2 . 求一个函数的标准“或-与” 式<br>一般步骤：<br>第一步：将函数表达式转换成一般“或-与”表达式。<br>第二步：反复利用定理 $A+(A+B)(A+\overline{B})$ 把表达式中<br>所有非最大项的“或项”扩展成最大项。</p><p>二、真值表转换法</p><p>1 . 求标准“与-或” 式<br>逻辑函数的最小项表达式与真值表具有一一对应的关系。假定函数 $F$ 的真值表中有 $k$ 组变量取值使 $F$ 的值为1，其他变量取值下F的值为0，那么，函数F的最小项表达式由这k组变量取值对应的k个最小项相或组成。<br>真值表上使函数值为1的变量取值组合对应的最小项相“或”,即可构成一个函数的标准“与-或”式 。</p><p>2 . 求一个函数的标准“或-与” 式<br>逻辑函数的最大项表达式与真值表之间同样具有一一<br>对应的关系。<br>假定在函数 $F$ 的真值表中有 $p$ 组变量取值使 $F$ 的值为0，其他变量取值下 $F$ 的值为1，那么，函数 $F$ 的最大项表达式由这 $p$ 组变量取值对应的p个最大项“相与”组成。真值表上使函数值为0的变量取值组合对应的最大项相“与”即可构成一个函数的标准“或-与”式 。</p><p>由于函数的真值表与函数的两种标准表达式之间存在一一对应的关系，而任何一个逻辑函数的真值表是唯一的，可见，任何一个逻辑函数的两种标准形式也是唯一的。</p><h3 id="逻辑函数化简"><a href="#逻辑函数化简" class="headerlink" title="逻辑函数化简"></a>逻辑函数化简</h3><p>实现某一逻辑功能的逻辑电路的复杂性与描述该功能的逻辑表达式的复杂性直接相关。为了降低系统成本、减小复杂度、提高可靠性，必须对逻辑函数进行化简。</p><p>逻辑函数化简有3种常用方法。即：代数化简法、卡诺图化简法和列表化简法。</p><h4 id="代数化简法"><a href="#代数化简法" class="headerlink" title="代数化简法"></a>代数化简法</h4><p>代数化简法就是运用逻辑代数的公理、定理和规则对逻辑函数进行化简的方法。</p><p>一、“与-或”表达式的化简</p><p>1．表达式中的“与”项个数最少；<br>2．在满足上述条件的前提下，每个“与”项中的变量个数最少。</p><p>几种常用方法如下：</p><p>1．并项法<br>2．吸收法<br>3．消去法<br>4．配项法 </p><p>二、“或-与”表达式的化简</p><p>1．表达式中的“或”项个数最少；<br>2．在满足上述条件的前提下，每个“或”项中的变量个数最少。</p><p>用代数化简法化简“或-与”表达式可直接运用公理、定理中的“或-与”形式，并综合运用前面介绍“与-或”表达式化简时提出的各种方法进行化简。</p><p>代数化简法的优点是：不受变量数目的约束；当对公理、定理和规则十分熟练时，化简比较方便。<br>缺点是：没有一定的规律和步骤，技巧性很强，而且在很多情况下难以判断化简结果是否最简。</p><h4 id="卡诺图化简法"><a href="#卡诺图化简法" class="headerlink" title="卡诺图化简法"></a>卡诺图化简法</h4><p>卡诺图化简法具有简单、直观、容易掌握等优点，在逻辑设计中得到广泛应用。</p><p>一、卡诺图的构成 </p><p>卡诺图是一种平面方格图，每个小方格代表一个最小项，故又称为最小项方格图。</p><p>结构特点：<br>(1)  $n$ 个变量的卡诺图由 $2^n$ 个小方格构成；<br>(2) 几何图形上处在相邻、相对、相重位置的小方格所代表的最小项为相邻最小项。<br><img src="812c5abc/%E5%8D%A1%E8%AF%BA%E5%9B%BE.jpg" alt="卡诺图"><br>在n个变量的卡诺图中，能从图形上直观、方便地找到每个最小项的n个相邻最小项。</p><p>二、卡诺图的性质</p><p>性质：可以从图形上直观地找出相邻最小项合并。合并的理论依据是并项定理： $A\overline{B}+AB=A$ 。</p><p>用卡诺图化简逻辑函数的基本原理：把卡诺图上表征相邻最小项的相邻小方格“圈”在一起进行合并，达到用一个简单“与”项代替若干最小项的目的。通常把用来包围那些能由一个简单“与”项代替的若干最小项的“圈”称为卡诺圈。 </p><p><img src="812c5abc/%E5%8D%A1%E8%AF%BA%E5%9C%88.jpg" alt="卡诺圈"></p><p>三、逻辑函数在卡诺图上的表示</p><p>1．给定逻辑函数为标准“与-或”表达式<br>当逻辑函数为标准“与-或”表达式时，只需在卡诺图上找出和表达式中最小项对应的小方格填上1，其余小方格填上0，即可得到该函数的卡诺图。</p><p>2．逻辑函数为一般“与-或”表达式<br>当逻辑函数为一般“与-或”表达式时，可根据“与”的公共性和“或”的叠加性作出相应卡诺图。</p><p>为了叙述的方便，通常将卡诺图上填1的小方格称为1方格，填0的小方格称为0方格。0方格有时用空格表示。</p><p>四、卡诺图上最小项的合并规律</p><p>1．两个小方格相邻, 或处于某行(列)两端时，所代表的最小项可以合并，合并后可消去一个变量。</p><p>2．四个小方格组成一个大方格、或组成一行（列）、或处于相邻两行（列）的两端、或处于四角时，所代表的最小项可以合并，合并后可消去两个变量。</p><p>4变量卡诺图上四个相邻最小项合并的典型情况：</p><p><img src="812c5abc/%E5%9B%9B%E4%B8%AA%E7%9B%B8%E9%82%BB%E6%9C%80%E5%B0%8F%E9%A1%B9%E5%90%88%E5%B9%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5.jpg" alt="四个相邻最小项合并的几种情况"></p><p>3．八个小方格组成一个大方格、或组成相邻的两行(列)、或处于两个边行(列)时，所代表的最小项可以合并，合并后可消去三个变量。</p><p> $n$ 个变量卡诺图中最小项的合并规律归纳如下：<br> (1) 卡诺圈中小方格的个数必须为 $2^m$ 个， $m$ 为小于或等于 $n$ 的整数。<br> (2) 卡诺圈中的 $2^m$ 个小方格有一定的排列规律，具体地说，它们含有 $m$ 个不同变量， $(n-m)$ 个相同变量。<br> (3) 卡诺圈中的 $2^m$ 个小方格对应的最小项可用 $(n-m)$ 个变量的“与”项表示，该“与”项由这些最小项中的相同变量构成。<br> (4) 当 $m=n$ 时，卡诺圈包围了整个卡诺图，可用1表示，即 $n$ 个变量的全部最小项之和为1。</p><p>五、卡诺图化简逻辑函数的步骤</p><p>1．几个定义<br>蕴涵项:在函数的“与-或”表达式中，每个“与”项被称为该函数的蕴涵项(Implicant)。<br>在函数卡诺图中，任何一个1方格所对应的最小项或者卡诺圈中的2m个1方格所对应的“与”项都是函数的蕴涵项。</p><p>质蕴涵项:若函数的一个蕴涵项不是该函数中其他蕴涵项的子集，则此蕴涵项称为质蕴涵项(Prime Implicant),简称为质项。<br>在函数卡诺图中，按照最小项合并规律，如果某个卡诺圈不可能被其他更大的卡诺圈包含，那么，该卡诺圈所对应的“与”项为质蕴涵项。</p><p>必要质蕴涵项：若函数的一个质蕴涵项包含有不被函数的其他任何质蕴涵项所包含的最小项，则此质蕴涵项被称为必要质蕴涵项(Essential Prime Implicant)，简称为必要质项。<br>在函数卡诺图中，若某个卡诺圈包含了不可能被任何其他卡诺圈包含的1方格，那么，该卡诺圈所对应的“与”项为必要质蕴涵项。</p><p>2．求逻辑函数最简“与-或”表达式的一般步骤 </p><p>第一步：作出函数的卡诺图；<br>第二步：在卡诺图上圈出函数的全部质蕴涵项；<br>第三步：从全部质蕴涵项中找出所有必要质蕴涵项；<br>第四步：求函数的最简质蕴涵项集。<br>当函数的所有必要质蕴涵项尚不能覆盖卡诺图上的所有1方格时，则从剩余质蕴涵项中找出最简的所需质蕴涵项，使它和必要质蕴涵项一起构成函数的最小覆盖。</p><p>用卡诺图化简总的原则是：<br>(1) 在覆盖函数中所有最小项的前提下，卡诺圈的个数应达到最少；<br>(2) 在满足合并规律的前题下卡诺圈应达到最大；<br>(3) 根据合并的需要，每个最小项可以被多个卡诺圈包围。 </p><ol><li>求逻辑函数最简“或-与”表达式的一般步骤</li></ol><p>当给定逻辑函数为“与—或”表达式或标准“与—或”<br>表达式时，通常采用“两次取反法”。具体如下：<br>(1)作出 $F$ 的卡诺图，求出反函数 $\overline{F}$ 的最简“与-或”表<br>达式(合并卡诺图上的0方格)；<br>(2)对 $\overline{F}$ 的最简“与-或”表达式取反，得到函数F的<br>最简“或-与”表达式。</p><p>当给定逻辑函数为“或—与”表达式或标准“或—与”表达式时，通常采用“两次对偶法”。具体如下：</p><p>(1) 作出 $F$ 对偶式 $F^{\prime}$ 的卡诺图，并求出 $F^{\prime}$ 的最简“与-或”表达式；<br>(2) 对 $F^{\prime}$ 的最简“与-或”表达式取对偶，得到函数F的最简“或-与”表达式。</p><p>卡诺图化简逻辑函数具有方便、直观、容易掌握等优点。 但受到变量个数的约束，当变量个数大于6时，画图以及对图形的识别都变得相当复杂。 </p><h4 id="列表化简法"><a href="#列表化简法" class="headerlink" title="列表化简法"></a>列表化简法</h4><p>略</p><h2 id="集成门电路与触发器"><a href="#集成门电路与触发器" class="headerlink" title="集成门电路与触发器"></a>集成门电路与触发器</h2><p>集成门电路和触发器等逻辑器件是实现数字系统功能的物质基础。</p><p>随着微电子技术的发展，人们把实现各种逻辑功能的元器件及其连线都集中制造在同一块半导体材料小片上，并封装在一个壳体中，通过引线与外界联系，即构成所谓的集成电路块，通常又称为集成电路芯片。</p><p>采用集成电路进行数字系统设计的优点：</p><p>　　可靠性高、可维性好、功耗低、成本低等优点，可以大大简化设计和调试过程。</p><h3 id="数字集成电路的分类"><a href="#数字集成电路的分类" class="headerlink" title="数字集成电路的分类"></a>数字集成电路的分类</h3><p>一、根据所采用的半导体器件进行分类 </p><p>根据所采用的半导体器件，数字集成电路可以分为两大类。<br>　　1.双极型集成电路：采用双极型半导体器件作为元件。主要特点是速度快、负载能力强，但功耗较大、 集成度较低。<br>　　2.单极型集成电路(又称为MOS集成电路): 采用金属-氧化<br>物半导体场效应管(Metel Oxide Semiconductor Field  Effect<br>Transister)作为元件。主要特点是结构简单、制造方便、集<br>成度高、功耗低，但速度较慢。</p><p>二、根据集成电路规模的大小进行分类</p><p>通常根据一片集成电路芯片上包含的逻辑门个数或元件个数，分为 SSI 、MSI 、LSI 、VLSI。 </p><ol><li>SSI (Small Scale Integration ) 小规模集成电路:<br>逻辑门数小于10 门(或元件数小于100个)；</li><li>MSI (Medium Scale Integration ) 中规模集成电路:<br>逻辑门数为10 门～99 门(或元件数100个～999个)；</li><li>LSI (Large  Scale Integration ) 大规模集成电路:<br>逻辑门数为100 门～9999 门(或元件数1000个～99999个)；</li><li>VLSI (Very Large Scale Integration) 超大规模集成电路:<br>逻辑门数大于10000 门(或元件数大于100000个)。</li></ol><h3 id="半导体器件的开关特性"><a href="#半导体器件的开关特性" class="headerlink" title="半导体器件的开关特性"></a>半导体器件的开关特性</h3><p>数字电路中的晶体二极管、三极管和MOS管等器件一般是以开关方式运用的，其工作状态相当于开关的“接通”与“断开”。<br>数字系统中的半导体器件运用在开关频率十分高的电路中(通常开关状态变化的速度可高达每秒百万次数量级甚至千万次数量级)，研究这些器件的开关特性时，不仅要研究它们的静止特性，而且还要分析它们的动态特性。</p><h4 id="晶体二极管的开关特性"><a href="#晶体二极管的开关特性" class="headerlink" title="晶体二极管的开关特性"></a>晶体二极管的开关特性</h4><p>一、静态特性 </p><p>静态特性是指二极管在导通和截止两种稳定状态下的特性。</p><p>典型二极管的静态特性曲线(又称伏安特性曲线) ：<br><img src="812c5abc/%E5%85%B8%E5%9E%8B%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E9%9D%99%E6%80%81%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF.png" alt="典型二极管的静态特性曲线"></p><ol><li>正向特性<br>门槛电压 ( $V_{TH}$ )：使二极管开始导通的正向电压，又称为阈值电压 (一般锗管约0.1V，硅管约0.5V)。</li></ol><ul><li>正向电压 $V_D ≤ V_{TH}$  ：管子截止，电阻很大、正向电流 $I_F$ 接近于 0， 二极管类似于开关的断开状态 ；</li><li>正向电压 $V_D  = V_{TH}$  ：管子开始导通，正向电流 $I_F$ 开始上升；</li><li>正向电压 $V_D ＞V_{TH}$ (一般锗管为0.3V，硅管为0.7V) ：管子充分导通，电阻很小，正向电流$I_F$ 急剧增加，二极管类似于开关的接通状态。使二极管充分导通的电压为导通电压，用$V_F$表示。</li></ul><p>2．反向特性<br>二极管在反向电压 $V_R$ 作用下，处于截止状态，反向电阻很大，反向电流 $I_R$ 很小（将其称为反向饱和电流，用 $I_S$ 表示，通常可忽略不计 ），二极管的状态类似于开关断开。而且反向电压在一定范围内变化基本不引起反向电流的变化。</p><p>注意事项：</p><ul><li>正向导通时可能因电流过大而导致二极管烧坏。组成实际电路时通常要串接一只电阻 $R$，以限制二极管的正向电流；</li><li>反向电压超过某个极限值时，将使反向电流$I_R$突然猛增，致使二极管被击穿（通常将该反向电压极限值称为反向击穿电压$V_{BR}$），一般不允许反向电压超过此值。</li></ul><p>由于二极管的单向导电性，所以在数字电路中经常把它当作开关使用。</p><p>二极管组成的开关电路图如图（a）所示。二极管导通状态下的等效电路如图(b)所示，截止状态下的等效电路如图(c)所示，图中忽略了二极管的正向压降。</p><p><img src="812c5abc/%E4%BA%8C%E6%9E%81%E7%AE%A1%E5%BC%80%E5%85%B3%E7%94%B5%E8%B7%AF%E5%8F%8A%E5%85%B6%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF.png" alt="二极管开关电路及其等效电路"></p><p>二、动态特性</p><p>二极管的动态特性是指二极管在导通与截止两种状态转换过程中的特性，它表现在完成两种状态之间的转换需要一定的时间。为此，引入了反向恢复时间和开通时间的概念。</p><ol><li><p>反向恢复时间<br>反向恢复时间：二极管从正向导通到反向截止所需要的时间称为反向恢复时间。<br>反向恢复时间$t_{re}$=存储时间$t_s$+渡越时间$t_t$</p></li><li><p>开通时间<br>开通时间：二极管从反向截止到正向导通的时间称为开通时间。<br>二极管的开通时间很短，对开关速度影响很小，相对反向恢复时间而言几乎可以忽略不计。</p></li></ol><p><img src="812c5abc/%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7.png" alt="二极管的动态特性"></p><h4 id="晶体三极管的开关特性"><a href="#晶体三极管的开关特性" class="headerlink" title="晶体三极管的开关特性"></a>晶体三极管的开关特性</h4><p>一、静态特性</p><p>晶体三极管由集电结和发射结两个PN结构成。根据两个PN结的偏置极性，三极管有截止、放大、饱和3种工作状态。　　</p><p><img src="812c5abc/%E4%B8%89%E6%9E%81%E7%AE%A1%E5%BC%80%E5%85%B3%E7%94%B5%E8%B7%AF%E5%8F%8A%E5%85%B6%E8%BE%93%E5%87%BA%E7%89%B9%E6%80%A7.png" alt="三极管开关电路及其输出特性"></p><p>在数字逻辑电路中，三极管相当于一个由基极信号控制的无触点开关，其作用对应于触点开关的“闭合”与“断开”。<br>电路在三极管截止与饱和状态下的等效电路如下:</p><p><img src="812c5abc/%E4%B8%89%E6%9E%81%E7%AE%A1%E6%88%AA%E6%AD%A2%E4%B8%8E%E9%A5%B1%E5%92%8C%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF.png" alt="三极管截止与饱和状态下的等效电路"></p><p>晶体三极管在截止与饱和这两种稳态下的特性称为三极管的静态开关特性。</p><p>二、动态特性</p><p>晶体三极管在饱和与截止两种状态转换过程中具有的特性称为三极管的动态特性。<br>三极管的开关过程和二极管一样，管子内部也存在着电荷的建立与消失过程。因此，两种状态的转换也需要一定的时间才能完成。</p><p>1．开通时间（ $t_{on}$ ）<br>开通时间：三极管从截止状态到饱和状态所需要的时间。<br>时间$t_{on}$ =延迟时间$t_d$ +上升时间$t_r$<br>　　<br>2. 关闭时间（ $t_{off}$ ）<br>关闭时间 ：三极管从饱和状态到截止状态所需要的时间。<br>关闭时间$t_{off} $=存储时间$t_s$ +下降时间 $t_f$ </p><p>开通时间和关闭时间是影响电路工作速度的主要因素。（光/电惯性/机械惯性！）</p><p><img src="812c5abc/%E4%B8%89%E6%9E%81%E7%AE%A1%E7%9A%84%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7.png" alt="三极管的动态特性"></p><h4 id="MOS管的开关特性"><a href="#MOS管的开关特性" class="headerlink" title="MOS管的开关特性"></a>MOS管的开关特性</h4><p>一、静态特性<br>MOS管作为开关元件，同样是工作在截止或导通两种状态。MOS管是电压控制元件，主要由栅源电压$V_{GS}$决定其工作状态。</p><p>工作特性如下：<br>当$V_{GS}$＜开启电压$V_{TN}$时：MOS管工作在截止区，输出电压$V_{DS} ≈V_{DD}$，MOS管处于“断开”状态;</p><p>当$V_{DS}≥V_{GS}－V_{TN}$时：MOS管工作在导通区，输出电压$V_{DS}≈ 0V$，MOS管处于“接通”状态。</p><p>二、动态特性</p><p>MOS管本身导通和截止时电荷积累和消散的时间很小。<br>动态特性主要取决于电路中杂散电容充、放电所需的时间。</p><p>为了提高MOS器件的工作速度，引入了CMOS电路。<br>在CMOS电路中，由于充电电路和放电电路都是低阻电路，因此，其充、放电过程都比较快，从而使CMOS电路有较高的开关速度</p><h3 id="逻辑门电路"><a href="#逻辑门电路" class="headerlink" title="逻辑门电路"></a>逻辑门电路</h3><h4 id="简单的逻辑门电路"><a href="#简单的逻辑门电路" class="headerlink" title="简单的逻辑门电路"></a>简单的逻辑门电路</h4><ol><li><p>与门<br><img src="812c5abc/%E4%B8%8E%E9%97%A8.jpg" alt="与门"></p></li><li><p>或门<br><img src="812c5abc/%E6%88%96%E9%97%A8.jpg" alt="或门"></p></li><li><p>非门<br><img src="812c5abc/%E9%9D%9E%E9%97%A8.jpg" alt="非门"></p></li></ol><h4 id="TTL-集成逻辑门电路"><a href="#TTL-集成逻辑门电路" class="headerlink" title="TTL 集成逻辑门电路"></a>TTL 集成逻辑门电路</h4><p>TTL(Transistor Transistor Logic)电路是晶体管-晶体管逻辑电路的简称。<br>TTL电路的功耗大、线路较复杂，使其集成度受到一定的限制，故广泛应用于中小规模逻辑电路中。</p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是一种具有记忆功能的电子器件。</p><p>触发器的特点：</p><ul><li>有两个互补的输出端 $Q$ 和 $\overline{Q}$</li><li>有两个稳定状态。通常将 $Q=1$ 和 $\overline{Q}=0$ 称为“1”状态，而把 $Q=0$ 和 $\overline{Q}=1$ 称为“0” 状态。当输入信号不发生变化时，触发器状态稳定不变。</li><li>在一定输入信号作用下（触发），触发器可以从一个稳定状态转移到另一个稳定状态。</li></ul><p>现态与次态的概念：</p><p>现态:输入信号作用前的状态，记作 $Q^n$ 和 $\overline{Q^n}$ , 一般简记为 $Q$ 和 $\overline{Q}$ ；<br>次态:输入信号作用后的状态，记作 $Q^{n+1}$ 和 $\overline{Q^{n+1}}$ 。<br>显然，次态是现态和输入的函数。</p><h4 id="基本的-R-S-触发器"><a href="#基本的-R-S-触发器" class="headerlink" title="基本的$R-S$触发器"></a>基本的$R-S$触发器</h4><p>基本$R-S$触发器是直接复位、置位触发器的简称，由于它是构成各种功能触发器的基本部件，故称为基本$R-S$触发器。</p><p>一、 用与非门构成的基本$R-S$触发器</p><p>1.组成：由两个与非门交叉耦合构成，其逻辑图和逻辑符号分别如下图 (a)和(b)所示。</p><p><img src="812c5abc/%E4%B8%8E%E9%9D%9E%E9%97%A8%E6%9E%84%E6%88%90%E7%9A%84R-S%E8%A7%A6%E5%8F%91%E5%99%A8.png"></p><p>$R$(Reset)称为置0端或者复位端;<br>$S$(Set)称为置1端或置位端；<br>逻辑符号输入端加的小圆圈表示低电平或负脉冲有效。</p><ol start="2"><li>工作原理</li></ol><p>(1)若$R=1,S=1$，则触发器保持原来状态不变；<br>(2)若$R=1,S=0$,则触发器置为1状态；（$S$置1端）<br>(3)若$R=0,S=1$,则触发器置为0状态；（$R$置0端）<br>(4)不允许出现$R=0,S=0$。（约束条件！）</p><ol start="3"><li>逻辑功能及其描述</li></ol><p>由与非门构成的$R-S$触发器的逻辑功能如下表所示。</p><p><img src="812c5abc/%E4%B8%8E%E9%9D%9E%E9%97%A8%E5%9F%BA%E6%9C%ACR-S%E8%A7%A6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E8%A1%A8.png" alt="与非门基本R-S触发器功能表"></p><p>表中”d”表示触发器次态不确定。该表又称为次态真值表。</p><p>状态表、状态转移图、激励表:</p><p><img src="812c5abc/%E7%8A%B6%E6%80%81%E8%A1%A8%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE%E6%BF%80%E5%8A%B1%E8%A1%A8.jpg"></p><p>用卡诺图化简后，可得到该触发器的次态方程</p><p>$$<br>Q^{n+1}=\overline{S}+RQ<br>$$</p><p>用卡诺图化简后，可得到该触发器的次态方程： $Q^{n+1}$ 。</p><p>因为R、S不允许同时为0，所以输入必须满足约束条件：$R+S=1$</p><p>二、用或非门构成的基本R-S触发器</p><ol><li>组成：由两个或非门交叉耦合组成，其逻辑图和逻辑符号分别如图(a)和图(b)所示。</li></ol><p><img src="812c5abc/%E6%88%96%E9%9D%9E%E9%97%A8%E6%9E%84%E6%88%90%E7%9A%84R-S%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="或非门构成的R-S触发器"></p><p>该电路的输入是正脉冲或高电平有效，故逻辑符号的输入端未加小圆圈。</p><ol start="2"><li>逻辑功能</li></ol><p><img src="812c5abc/%E6%88%96%E9%9D%9E%E9%97%A8%E5%9F%BA%E6%9C%ACR-S%E8%A7%A6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E8%A1%A8.png" alt="或非门基本R-S触发器功能表"></p><p>次态方程：<br>$$<br>Q^{n+1}=S+\overline{R}Q<br>$$<br>约束方程：<br>$$<br>R\cdot S=0<br>$$</p><p>基本R-S触发器的优点是结构简单。它不仅可作为记忆元件独立用，而且由于它具有直接复位、置位功能，因而被作为各种性能完善的触发器的基本组成部分。但由于R、S之间的约束关系，以及不能进行定时控制，使它的使用受到一定限制。</p><h4 id="几种常用的时钟控制触发器"><a href="#几种常用的时钟控制触发器" class="headerlink" title="几种常用的时钟控制触发器"></a>几种常用的时钟控制触发器</h4><p>具有时钟脉冲控制的触发器称为“时钟控制触发器”或者“定时触发器”。</p><p>时钟脉冲控制触发器的工作特点：</p><ul><li>由时钟脉冲确定状态转换的时刻 (即何时转换？) ；</li><li>由输入信号确定触发器状态转换的方向 (即如何转换？)。</li></ul><p>一、时钟控制R-S触发器</p><p>时钟控制R-S触发器的逻辑图和逻辑符号如图(a)、（b）所示。</p><p><img src="812c5abc/%E6%97%B6%E9%92%9F%E6%8E%A7%E5%88%B6R-S%E8%A7%A6%E5%8F%91%E5%99%A8.png" alt="时钟控制R-S触发器"></p><ol><li>组成：<br>　　由四个与非门构成。其中，与非门G1、G2构成基本R-S触发器；与非门G3、G4组成控制电路，通常称为控制门。</li></ol><p>2．工作原理 </p><ul><li><p>当时钟脉冲没有到来（即C=0）时，不管R、S端为何值，两个控制门的输出均为1，触发器状态保持不变。</p></li><li><p>当时钟脉冲到来（即C=1，注意C=1的意义！）时，输入端R、S的值 可以通过控制门作用于基本R-S触发器。</p></li></ul><p>具体如下：</p><ul><li>$R=0, S=0$：控制门G3、G4的输出均为1，触发器状态保持不变；</li><li>$R=0, S=1$：控制门G3、G4的输出分别为1和0，触发器状态置成1状态；</li><li>$R=1, S=0$：控制门G3、G4的输出分别为0和1，触发器状态置成0状态；</li><li>$R=1，S=1$：控制门G3、G4的输出均为0，触发器状态不确定，这是不允许的。</li></ul><p>由分析可知：时钟控制$R-S$触发器的工作过程是由时钟信号$C$和输入信号$R$、$S$共同作用的；时钟$C$控制转换时间，输入$R$和$S$确定转换后的状态。</p><p>3．逻辑功能<br>时钟控制$R-S$触发器的功能表、次态方程和约束条件与由或非门构成的$R-S$触发器相同。<br>在时钟控制触发器中，时钟信号$C$是一种固定的时间基准，通常不作为输入信号列入表中。对触发器功能进行描述时，均只考虑时钟作用$(C=1)$时的情况。</p><p>注意！时钟控制R-S触发器虽然解决了对触发器工作进行定时控制的问题，而且具有结构简单等优点，但依然存在如下不足：</p><ul><li>输入信号依然存在约束条件，即$R$、$S$不能同时为1；</li></ul><p><img src="812c5abc/%E9%92%9F%E6%8E%A7R-S%E8%A7%A6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E8%A1%A8%E7%8A%B6%E6%80%81%E8%A1%A8%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE%E6%BF%80%E5%8A%B1%E8%A1%A8.png"></p><p><img src="812c5abc/%E9%92%9F%E6%8E%A7R-S%E8%A7%A6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E8%A1%A8%E7%8A%B6%E6%80%81%E8%A1%A8%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE%E6%BF%80%E5%8A%B1%E8%A1%A82.png"></p><p>二、 D触发器</p><p>对时钟控制R-S触发器的控制电路稍加修改，使之变成如下图(a)所示的形式，这样便形成了只有一个输入端的D触发器。其逻辑符号如图 (b)所示。</p><p><img src="812c5abc/D%E8%A7%A6%E5%8F%91%E5%99%A8.png"></p><p>修改后，控制电路在时钟脉冲作用期间($C=1$时)，将输入信号D转换成一对互补信号送至基本$R-S$触发器的两个输入端，使基本R-S触发器的两个输入信号只可能是01或者10两种组合，从而消除了状态不确定现象，解决了对输入的约束问题。</p><p>工作原理如下：<br>当无时钟脉冲作用（即$C=0$）时，控制电路被封锁，无论D为何值，与非门G3、G4输出均为1，触发器状态保持不变。<br>当时钟脉冲作用（即$C=1$ ）时，若$D=0$，则门G4输出为1，门G3输出为0，触发器状态被置0；若D=1，则门G4输出为0，门G3输出为1，触发器状态被置1。</p><p>在时钟作用时，D触发器状态的变化仅取决于输入信号D，而与现态无关。其次态方程为<br>$$<br>Q^{n+1}=D<br>$$</p><p>三 、$J-K$触发器</p><p>在时钟控制$R-S$触发器中增加两条反馈线，将触发器的输出$Q$和$\overline{Q}$交叉反馈到两个控制门的输入端，并把原来的输入端S改成J，R改成K，即可改进成$J-K$触发器。$J-K$触发器的逻辑图和逻辑符号如下图所示。</p><p><img src="812c5abc/J-K%E8%A7%A6%E5%8F%91%E5%99%A8.png"></p><p>该触发器利用触发器两个输出端信号始终互补的特点，有效地解决了时钟控制$R-S$触发器在时钟脉冲作用期间两个输入同时为1将导致触发器状态不确定的问题。</p><p>四、$T$触发器</p><p>$T$触发器又称为计数触发器。如果把$J-K$触发器的两个输入端$J$和$K$连接起来，并把连接在一起的输入端用符号$T$表示，就构成了$T$触发器。相应的逻辑图和逻辑符号分别如图(a)和图(b)所示。</p><p><img src="812c5abc/T%E8%A7%A6%E5%8F%91%E5%99%A8.png"></p><p>T触发器的逻辑功能可直接由$J-K$触发器的次态方程导出。$J-K$触发器的次态方程为<br>$$<br>Q^{n+1}=J\overline{Q}+\overline{K}Q<br>$$<br>将该方程中的$J$和$K$均用$T$代替后，即可得到$T$触发器的次态方程：<br>$$<br>Q^{n+1}=T\overline{Q}+\overline{T}Q<br>$$</p><p><img src="812c5abc/T%E8%A7%A6%E5%8F%91%E5%99%A8%E5%8A%9F%E8%83%BD%E8%A1%A8.png"></p><p>功能：</p><ul><li>当T=0时，触发器状态保持不变；</li><li>当T=1时，在时钟脉冲作用下状态翻转，相当于一位二进制计数器。</li></ul><p>上述由四个逻辑门构成的触发器存在空翻问题，所谓“空翻”是指在同一个时钟脉冲作用期间触发器状态发生两次或两次以上变化的现象。</p><p>引起空翻的原因：因为在时钟脉冲作用期间，输入信号直接控制着触发器状态的变化。即当时钟C为1时，输入信号R、S发生变化，触发器状态会跟着变化，从而使得一个时钟脉冲作用期间引起多次翻转。</p><p>为了克服“空翻”现象，实际数字电路中使用的集成T触发器通常采用主从式结构或者维持阻塞结构。它们除了在性能方面的改进外，逻辑功能与上述触发器完全相同。</p><p>思路：缩短开门时间，提高抗扰性。<br>(1) 主从钟控触发器<br>    主从$R-S$ 触发器（P86-87）<br>    主从$J-K$ 触发器（P88-89）<br>(2) 维持-阻塞钟控触发器（P89-91）</p><h4 id="不同类型触发器之间的转换"><a href="#不同类型触发器之间的转换" class="headerlink" title="不同类型触发器之间的转换"></a>不同类型触发器之间的转换</h4><p>略</p><h2 id="组合逻辑电路"><a href="#组合逻辑电路" class="headerlink" title="组合逻辑电路"></a>组合逻辑电路</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>若逻辑电路在任何时刻产生的稳定输出值仅仅取决于该时刻各输入值的组合，而与过去的输入值无关，则称为组合逻辑电路。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="812c5abc/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF.png" alt="组合逻辑电路"></p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>可用一组逻辑函数表达式进行描述其逻辑功能，函数表达式可表示为 $F_i=f_i(X_1,X_2,\cdots,X_n)$ 。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>组合电路具有两个特点：</p><ul><li>由逻辑门电路组成，不包含任何记忆元件；</li><li>信号是单向传输的，不存在反馈回路。</li></ul><h3 id="组合逻辑电路分析"><a href="#组合逻辑电路分析" class="headerlink" title="组合逻辑电路分析"></a>组合逻辑电路分析</h3><h4 id="分析的一般步骤"><a href="#分析的一般步骤" class="headerlink" title="分析的一般步骤"></a>分析的一般步骤</h4><ol><li>根据逻辑电路图写出输出函数表达式</li><li>化简输出函数表达式</li><li>列出输出函数真值表</li><li>功能评述与评价</li></ol><h3 id="组合逻辑电路的设计"><a href="#组合逻辑电路的设计" class="headerlink" title="组合逻辑电路的设计"></a>组合逻辑电路的设计</h3><p>设计的一般过程：(与工程实现或实施之间还存在距离！）</p><ol><li>建立给定问题的逻辑描述<br>这一步的关键是弄清楚电路的输入和输出，建立输入和输出之间的逻辑关系，得到描述给定问题的逻辑表达式。求逻辑表达式有两种常用方法，即真值表法和分析法。</li><li>求出逻辑函数的最简表达式<br>为了使逻辑电路中包含的逻辑门最少且连线最少，要对逻辑表达式进行化简，求出描述设计问题的最简表达式 。</li><li>选择逻辑门类型并将逻辑函数变换成相应形式<br>根据简化后的逻辑表达式及问题的具体要求，选择合适的逻辑门，并将逻辑表达式变换成与所选逻辑门对应的形式。</li><li>画出逻辑电路图根据实际问题的难易程度和设计者熟练程度，有时可跳过其中的某些步骤。设计过程可视具体情况灵活掌握。</li></ol><p>一、 包含无关条件的组合逻辑电路设计</p><p>无关最小项的概念：由于输入变量之间存在的相互制约或问题的某种特殊限定，使输出函数与某些变量取值无关，这些输入取值组合对应的最小项称为无关最小项，简称为无关项或者任意项。<br>当采用“最小项之和”表达式描述一个包含无关条件的逻辑问题时，函数表达式中是否包含无关项，以及对无关项是令其值为1还是为0，并不影响函数的实际逻辑功能。<br>注意：在化简这类逻辑函数时，利用无关项的随意性往往可以使逻辑函数得到更好地简化，从而使设计的电路达到更简！</p><p>二 、多输出函数的组合逻辑电路设计</p><p>实际问题中，大量存在着由同一组输入变量产生多个输出函数的问题，实现这类问题的组合逻辑电路称为多输出函数的组合逻辑电路。</p><p>多输出组合电路达到最简的关键是在函数化简时找出各输出函数的公用项，使之在逻辑电路中实现对逻辑门的“共享”，从而达到电路整体结构最简。</p><p>三 、 无反变量提供的组合逻辑电路设计</p><p>在某些问题的设计中，为了减少各部件之间的连线，在逻辑电路的输入端只提供原变量，不提供反变量。</p><p>设计这类电路时，若直截用非门将原变量转换成相应的反变量，则处理结果往往是不经济的。因此，通常进行适当的变换，以便尽可能减少非门数量。</p><h3 id="组合逻辑电路的险象"><a href="#组合逻辑电路的险象" class="headerlink" title="组合逻辑电路的险象"></a>组合逻辑电路的险象</h3><h4 id="竞争现象与险象的产生"><a href="#竞争现象与险象的产生" class="headerlink" title="竞争现象与险象的产生"></a>竞争现象与险象的产生</h4><p>逻辑电路中各路径上延迟时间的长短与信号经过的门的级数有关，与具体逻辑门的时延大小有关，还与导线的长短有关，因此，输入信号经过不同路径到达输出端的时间有先有后，这种现象称为竞争现象 。</p><p>竞争：由于延迟时间的影响，使得输入信号经过不同路径到达输出端的时间有先有后，这一现象称为竞争。</p><p>竟争的类型：<br>非临界竞争——-不产生错误输出的竞争称为非临界竞争。<br>临界竞争——–导致错误输出的竞争称为临界竞争。</p><p>险象：由竞争导至的错误输出信号。</p><p>注意！组合电路中的险象是一种瞬态现象，它表现为在输出端产生不应有的尖脉冲，暂时地破坏正常逻辑关系。一旦瞬态过程结束，即可恢复正常逻辑关系。</p><h4 id="险象的分类"><a href="#险象的分类" class="headerlink" title="险象的分类"></a>险象的分类</h4><p>组合电路中的险象可分为静态险象和动态险象。<br>静态险象：如果在输入变化而输出不应发生变化的情况下，输出端产生了短暂的错误输出，则称为静态险象。<br>动态险象：如果在输入变化而输出应该发生变化的情况下，输出在变化过程中产生了短暂的错误输出，则称为动态险象。</p><p>按错误输出脉冲信号的极性可分为“0”型险象与“1”型险象。</p><ul><li>“0”型险象：错误输出信号为负脉冲。</li><li>“1”型险象：错误输出信号为正脉冲。</li></ul><h4 id="险象的判断"><a href="#险象的判断" class="headerlink" title="险象的判断"></a>险象的判断</h4><p>判断电路是否可能产生险象的方法有代数法和卡诺图法。</p><p>代数法：</p><ul><li>检查函数表达式中是否存在具备竞争条件的变量，即<br>是否有某个变量$X$同时以原变量和反变量的形式出现在函数表达式中。</li><li>若存在具备竞争条件的变量$X$，则消去函数式中的其<br>他变量,看函数表达式是否会变为 $X+\overline{X}$ 或者 $X\cdot \overline{X}$ 的形式。若会，则说明对应的逻辑电路可能产生险象。</li></ul><p>卡诺图法：作出函数卡诺图，并画出和函数表达式中各“与”项对应的卡诺圈。若卡诺圈之间存在“相切”关系，即两卡诺圈之间存在不被同一卡诺圈包含的相邻最小项，则该电路可能产生险象。</p><h4 id="险象的消除"><a href="#险象的消除" class="headerlink" title="险象的消除"></a>险象的消除</h4><p>一、 用增加冗余项的方法消除险象</p><p>增加冗余项的方法是，通过在函数表达式中“或”上冗余的“与”项或者“与”上冗余的“或”项，消除可能产生的险象。<br>冗余项的选择可以采用代数法或者卡诺图法确定。</p><p>二、  增加惯性延时环节</p><p>三、 选通法</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>数字电路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数理逻辑</title>
    <link href="/archives/70bba3ec.html"/>
    <url>/archives/70bba3ec.html</url>
    
    <content type="html"><![CDATA[<p>说真的，作为离散数学的一部分的数理逻辑其实内容不是很多，深度也不够。今后想深入学习时再补充吧！</p><span id="more"></span><h1 id="数理逻辑"><a href="#数理逻辑" class="headerlink" title="数理逻辑"></a>数理逻辑</h1><h2 id="数理逻辑的简介"><a href="#数理逻辑的简介" class="headerlink" title="数理逻辑的简介"></a>数理逻辑的简介</h2><p><strong>逻辑学</strong>是探索阐述和确立有效推理原则的学科，最早由亚里士多德创立。</p><p>三段论：一个包括有大前提，小前提和结论的论证。</p><ul><li>大前提： $S$ 中的所有元有 $R$ 性质</li><li>小前提： $a$ 没有 $R$ 性质</li><li>结论： $a$ 不是 $S$ 中的元</li></ul><p>用数学的方法研究关于推理、证明等问题的学科就叫做<strong>数理逻辑</strong>。</p><p><strong>数理逻辑的四个分支</strong>：</p><ul><li>公理集合论</li><li>证明论</li><li>递归论</li><li>模型论</li></ul><p><strong>命题演算</strong>与<strong>谓词演算</strong></p><h2 id="命题逻辑"><a href="#命题逻辑" class="headerlink" title="命题逻辑"></a>命题逻辑</h2><h3 id="命题逻辑基本概念"><a href="#命题逻辑基本概念" class="headerlink" title="命题逻辑基本概念"></a>命题逻辑基本概念</h3><h4 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h4><p>命题：能判断真假的陈述句叫命题。</p><p>悖论（自我指谓）、疑问句、祈使句、感叹句，无确定真值的句子都不是命题。</p><p>一般用 $p,q,r,s,\cdots$ 表示命题，1为真，0为假。</p><h4 id="联结词"><a href="#联结词" class="headerlink" title="联结词"></a>联结词</h4><p>联结词的种类：</p><ul><li>否定联结词： $\neg$ ，例如： $\neg p$ ，真假与 $p$ 相反</li><li>合取联结词： $\wedge$ ，例如： $p \wedge q$ ，一假即假</li><li>析取联结词： $\vee$ ，例如： $p \vee q$ ，一真即真</li><li>蕴涵联结词： $\rightarrow$ ，例如： $p \rightarrow q$ ， $p \rightarrow q$ 为假当且仅当 $p$ 为真且 $q$ 为假。</li><li>等价联结词： $\leftrightarrow$ ，例如： $p \leftrightarrow q$ ，当且仅当 $p,q$ 真值相同时， $p \leftrightarrow q$ 为真。</li><li>除此之外还有： $\uparrow, \downarrow$ 等。</li></ul><p>简单命题与复合命题</p><h3 id="命题逻辑等值演算"><a href="#命题逻辑等值演算" class="headerlink" title="命题逻辑等值演算"></a>命题逻辑等值演算</h3><h4 id="等值式"><a href="#等值式" class="headerlink" title="等值式"></a>等值式</h4><p><strong>等值</strong>：设 $A,B$ 是两个命题公式，若 $A,B$ 构成的等价式 $A\leftrightarrow B$ 为<strong>重言式</strong>，则称A与B是<strong>等值</strong>的，记为 $A\Leftrightarrow B$ 。</p><p><strong>基本等值式</strong>：</p><ol><li>双重否定律<br>$$A\Leftrightarrow \neg \neg A$$</li><li>幂等律<br>$$A\Leftrightarrow A\vee A,A\Leftrightarrow A\wedge A$$</li><li>交换律<br>$$A\vee B\Leftrightarrow B\vee A,A\wedge B\Leftrightarrow B\wedge A$$</li><li>结合律<br>$$(A\vee B)\vee C\Leftrightarrow A\vee (B\vee C),(A\wedge B)\wedge C\Leftrightarrow A\wedge (B\wedge C)$$</li><li>分配律<br>$$A\vee (B\wedge C)\Leftrightarrow (A\vee B)\wedge (A\vee C),A\wedge (B\vee C)\Leftrightarrow (A\wedge B)\vee (A\wedge C)$$</li><li>德摩根律<br>$$\neg (A\vee B)\Leftrightarrow \neg A\wedge \neg B,\neg (A\wedge B)\Leftrightarrow \neg A\vee \neg B$$ </li><li>吸收律<br>$$A\vee (A\wedge B)\Leftrightarrow A,A\wedge (A\vee B)\Leftrightarrow A$$</li><li>零律<br>$$A\vee 1\Leftrightarrow 1,A\wedge 0\Leftrightarrow 0$$</li><li>同一律<br> $$A\vee 0\Leftrightarrow A,A\wedge 1\Leftrightarrow A$$</li><li>排中律<br>$$A\vee \neg A\Leftrightarrow 1$$</li><li>矛盾律<br>$$A\wedge \neg A\Leftrightarrow 0$$</li><li>蕴涵等值式<br>$$A\rightarrow B\Leftrightarrow \neg A\vee B$$</li><li>等价等值式<br>$$A\leftrightarrow B\Leftrightarrow (A\rightarrow B)\wedge(B\rightarrow A)$$</li><li>假言易位<br>$$A\rightarrow B\Leftrightarrow \neg B\rightarrow \neg A$$</li><li>等价否定等值式<br>$$A\leftrightarrow B\Leftrightarrow \neg A\leftrightarrow\neg B$$</li><li>归谬论<br>$$(A\rightarrow B)\wedge (A\rightarrow \neg B)\Leftrightarrow \neg A$$</li></ol><p><strong>对偶原理</strong>：一个逻辑等值式，如果只含有 $\neg ,\vee,\wedge,0,1$ 那么同时把 $\vee$ 和 $\wedge$ 互换，把0和1互换得到的还是等值式。</p><h4 id="析取范式与合取范式"><a href="#析取范式与合取范式" class="headerlink" title="析取范式与合取范式"></a>析取范式与合取范式</h4><p>命题变项及其否定统称作<strong>文字（letters）</strong>。</p><p>仅由有限个文字构成的<strong>析取式</strong>称作<strong>简单析取式</strong>。</p><p>仅由有限个文字构成的<strong>合取式</strong>称作<strong>简单合取式</strong>。</p><p>设 $A_i$ 是含 $n$ 个文字的简单析取式，若 $A_i$ 中既含某个命题变项 $p_j$ ，又含它的否定式 $\neg p_j$ ， 即含 $p_j\vee \neg p_j$ ，则 $A_i$ 为重言式。</p><p>一个简单析取式是<strong>重言式</strong>当且仅当它同时含有某个命题变项及它的否定式。一个简单合取式是<strong>矛盾式</strong>当且仅当它同时含有某个命题变项及它的否定式。</p><p><strong>范式</strong>：由有限个简单合取式构成的析取式称为<strong>析取范式</strong>（disjunctive normal form）。<br>由有限个简单析取式构成的合取式称为<strong>合取范式</strong>（conjunctive normal form）。<br>析取范式与合取范式统称为<strong>范式</strong>。</p><p><strong>范式存在定理</strong>：任一命题公式都存在与之逻辑等价的析取范式与合取范式。</p><p>一个析取范式是<strong>矛盾式</strong>当且仅当它的每个简单合取式都是矛盾式。一个合取范式是<strong>重言式</strong>当且仅当它的每个简单析取式都是重言式。</p><p><strong>极小项（极大项）</strong>：在含有 $n$ 个命题变元的简单合取式（简单析取式），若每个命题变元和它的否定式不同时出现，而二者之一必出现且仅出现一次，且第 $i$ 个命题变元或它的否定式出现在从左算起的第 $i$ 位，则称这样的简单合取式（简单析取式）为极小项（极大项）。</p><p>设 $m_i$ 和 $M_i$ 是命题变元 $P_1,P_2,\cdots ,P_n$ 形成的极小项和极大项，则：</p><p>$$<br>\neg m_{i} \Leftrightarrow M_{i} \quad \neg M_{i} \Leftrightarrow m_{i}<br>$$</p><p><strong>主范式</strong>：由有限个极小项构成的析取式称为<strong>主析取范式</strong>。<br>由有限个极大项构成的合取式称为<strong>主合取范式</strong>。<br>主析取范式和主合取范式统称<strong>主范式</strong>。</p><p><strong>范式定理</strong>：任何命题公式都存在着与之逻辑等价的主析取范式和主合取范式，并且是唯一的。</p><h4 id="真值函数"><a href="#真值函数" class="headerlink" title="真值函数"></a>真值函数</h4><p><strong>真值函数</strong>：称定义域为$\{ 00···0,00···1,···,11···1 \}$，值域为$\{ 0,1 \}$的函数是 $n$ 元真值函数，定义域中的元素是长为 $n$ 的0,1串。常用 $F:\{ 0,1 \}^n \rightarrow \{ 0,1 \}$ 表示 $F$ 是 $n$ 元真值函数。</p><p>共有 $2^{2^n}$ 个 $n$ 元真值函数。</p><p>对于任意一个含 $n$ 个命题变项的命题公式 $A$ ，都存在唯一的一个 $n$ 元真值函数 $F$ 为 $A$ 的真值表。</p><h4 id="联结词功能完备集"><a href="#联结词功能完备集" class="headerlink" title="联结词功能完备集"></a>联结词功能完备集</h4><p>联结词全功能集：设 $S$ 是一个联结词集合，如果任何 $n(n\geq 1)$ 元真值函数都可以由仅含 $S$ 中的联结词构成的公式表示，则称 $S$ 是联结词全功能集。</p><p>若 $S$ 是联结词全功能集，则任何命题公式都可用 $S$ 中的联结词表示。</p><p>定理： $\{  \neg,\wedge,\vee  \} , \{  \neg,\wedge  \} , \{  \neg,\vee  \} , \{  \neg,\rightarrow  \}$ 都是联结词全功能集。</p><p>其他联结词：</p><p>与非式：</p><p>$$<br>p \uparrow q \Leftrightarrow \neg(p\wedge q)<br>$$</p><p>或非式：</p><p>$$<br>p \downarrow q \Leftrightarrow \neg(p\vee q)<br>$$</p><p>定理： $\{  \uparrow  \} , \{  \downarrow  \} $ 都是联结词全功能集。</p><h4 id="命题逻辑推理理论"><a href="#命题逻辑推理理论" class="headerlink" title="命题逻辑推理理论"></a>命题逻辑推理理论</h4><p>逻辑蕴涵关系：设 $A$ 和 $B$ 为两个命题公式，若 $A\rightarrow B$ 是一个重言式，则称 $A$ （逻辑）蕴涵 $B$ ，或称 $A$ 永真蕴涵 $B$ ，记作 $A\Rightarrow B$ 。即：若 $A\rightarrow B\Leftrightarrow 1$ ，则称 $A\Rightarrow B$ 。</p><p><strong>蕴涵关系的性质</strong>：</p><ul><li>自反性：即对任意的公式 $A$ ，有 $A\Rightarrow A$ 。</li><li>反对称性：对任意的公式 $A$ 和 $B$ ，若 $A\Rightarrow B$ ，且 $B\Rightarrow A$ ，则有 $A\Leftrightarrow B$ 。</li><li>传递性：对任意的公式 $A,B,C$ ，若 $A\Rightarrow B$ ，且 $B\Rightarrow C$ ，则 $A\Rightarrow C$ 。</li></ul><p><strong>蕴涵关系的证明</strong>：</p><ul><li>前真导后真法</li><li>后假导前假法</li></ul><p><strong>推理的形式结构</strong>:若对于每组赋值，或者 $A_1\wedge A_2\wedge \cdots \wedge A_k$ 为假，或者当 $A_1\wedge A_2\wedge \cdots \wedge A_k$ 为真时， $B$ 也为真, 则称由 $A_1\wedge A_2\wedge \cdots \wedge A_k$ 推 $B$ 的推理正确, 否则推理不正确（错误）。</p><p><strong>推理的形式结构</strong>： $A_1\wedge A_2\wedge \cdots \wedge A_k\rightarrow B$ 。</p><p>上述推理正确等价于： $A_1\wedge A_2\wedge \cdots \wedge A_k\Rightarrow B$ 。</p><p>判断推理是否正确：</p><ul><li>真值表法</li><li>等值演算法</li><li>主析取范式法</li><li>构造证明法</li></ul><p><strong>推理定律</strong>：</p><ul><li>附加律<br>$$A\Rightarrow (A\vee B)$$</li><li>化简律<br>$$(A\wedge B)\Rightarrow A$$</li><li>假言推理<br>$$(A\rightarrow B)\wedge A\Rightarrow B$$</li><li>拒取式<br>$$(A\rightarrow B)\wedge \neg B\Rightarrow \neg A$$</li><li>析取三段论<br>$$(A\vee B)\wedge \neg B\Rightarrow A$$</li><li>假言三段论<br>$$(A\rightarrow B)\wedge (B\rightarrow C)\Rightarrow (A\rightarrow C)$$</li><li>等价三段论<br>$$(A\leftrightarrow B)\wedge (B\leftrightarrow C)\Rightarrow (A\leftrightarrow C)$$</li><li>构造性二难<br>$$(A\rightarrow B)\wedge (C\rightarrow D)\wedge (A\vee C)\Rightarrow (B\vee D)$$</li><li>构造性二难（特殊形式）<br>$$(A\rightarrow B)\wedge (\neg A\rightarrow \neg B)\Rightarrow B$$</li><li>破坏性二难<br>$$(A\rightarrow B)\wedge (C\rightarrow D)\wedge (\neg B\vee \neg D)\Rightarrow (\neg A\vee \neg C)$$</li></ul><p><strong>推理规则</strong>：</p><ol><li>前提引入规则 $P$ 。</li><li>结论引入规则 $T$ 。</li><li>置换规则</li><li>假言推理规则</li><li>附加规则</li><li>化简规则</li><li>拒取式规则</li><li>假言三段论规则</li><li>析取三段论规则</li><li>构造性二难推理规则</li><li>破坏性二难推理规则</li><li>合取引入规则</li></ol><p><strong>证明方法</strong>：</p><ul><li>直接证明法</li><li>附加前提证明法</li><li>归谬法（反证法）</li></ul><h2 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h2><h3 id="谓词的概念与表示法"><a href="#谓词的概念与表示法" class="headerlink" title="谓词的概念与表示法"></a>谓词的概念与表示法</h3><p>谓词：在反映判断的句子中，用以刻划客体的性质或关系的即是谓词。表示特定谓词，称为谓词常元，<br>表示不确定的谓词，称为谓词变元，都用大写英文字母，如 $P,Q,R,\cdots$ 来表示。</p><p>客体，是指可以独立存在的事物，它可以是具体的，也可以是抽象的，如张明，计算机，精神等。<br>表示特定的个体，称为客体常元，以 $a,b,c,\cdots$ 或带下标的 $a_i,b_i,c_i,\cdots$ 表示；<br>表示不确定的个体，称为客体变元，以 $x,y,z,\cdots$ 或$x_i,y_i,z_i,\cdots$表示。</p><h3 id="命题函数与量词"><a href="#命题函数与量词" class="headerlink" title="命题函数与量词"></a>命题函数与量词</h3><h4 id="命题函数"><a href="#命题函数" class="headerlink" title="命题函数"></a>命题函数</h4><p>命题函数：由一个谓词和一些客体变元组成的表达式，称为简单命题函数。 $n$ 元谓词，就是有 $n$ 个客体变元的命题函数。由一个或 $n$ 个简单命题函数以及逻辑联结词组成的表达式，称为复合命题函数。</p><p>个体域：在命题函数中，客体变元的取值范围（讨论范围）叫个体域或论述域。</p><p>全总个体域：把各种个体域综合在一起作为论述范围的域。</p><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><p>全称量词： $\forall$<br>存在量词： $\exists$<br>存在唯一量词： $\exists !$ </p><h3 id="谓词公式与翻译"><a href="#谓词公式与翻译" class="headerlink" title="谓词公式与翻译"></a>谓词公式与翻译</h3><p>原子谓词公式：不出现命题联结词和量词的谓词表达式称为原子谓词公式，并用 $P(x_1,\cdots,x_n)$ 来表示。<br>其中： $P$ 称为 $n$ 元谓词， $x_1,\cdots,x_n$ 称为客体变元，当 $n=0$ 时称为零元谓词公式。</p><p>谓词公式的归纳法定义<br>（1）原子谓词公式是谓词公式；<br>（2）若 $A$ 是谓词公式，则 $\neg A$ 也是谓词公式；<br>（3）若 $A, B$ 都是谓词公式，则 $A\vee B,A\wedge B$， $A\rightarrow B,A\leftrightarrow B$ 都是谓词公式；<br>（4）若 $A$ 是谓词公式，x是任何变元，则 $(\forall x)A,(\exists x)A,$ 也都是谓词公式；<br>（5）只有按⑴-⑷所求得的那些公式才是谓词公式（谓词公式又简称“公式”）。</p><h3 id="变元的约束"><a href="#变元的约束" class="headerlink" title="变元的约束"></a>变元的约束</h3><p>指导变元：给定 $x$ 为一个谓词公式，其中一部分公式形式为 $(\forall x)P(x)$ 或 $(\exists x)P(x)$ ，这里的 $\forall$ ， $\exists$ 后面所跟的 $x$ 称为相应的量词的指导变元。</p><p>辖域： $P(x)$ 称为相应量词的作用域或辖域。（紧接在量词后面括号内的谓词公式。）</p><p>约束变元：在量词的辖域内，且与量词下标相同的变元。（在作用域中的 $x$ ）</p><p>自由变元：除去约束变元以外所出现的变元称作自由变元。（不受量词的约束的变元）。 </p><p>自由变元的代入:对公式中的自由变元的更改叫做代入。<br>规则：(a)对公式中出现该自由变元的每一处进行代入。(b)用以代入的变元与原公式中所有变元的名称不能相同。</p><p>(1)当个体域的元素有限时，客体变元的所有可能的取代是可枚举的。</p><p>(2)量词对变元的约束，往往与量词的次序有关。约定：多个量词时的读出顺序为从左到右，不能颠倒。</p><h3 id="谓词演算的等价式与蕴含式"><a href="#谓词演算的等价式与蕴含式" class="headerlink" title="谓词演算的等价式与蕴含式"></a>谓词演算的等价式与蕴含式</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>赋值：在谓词公式中，当客体变元由确定的客体所取代，谓词变元用确定的谓词所取代时，就称对谓词公式赋值。</p><p>等价：给定两个谓词公式 $\mathrm{wff} A$ 和 $\mathrm{wff} B$ ， $E$ 为它们共同个体域，若对 $A$ 和 $B$ 的变元的任意赋值，使得 $A$ 和 $B$ 的值相同，则称谓词公式 $A$ 和 $B$ 在 $E$ 上是互为等价的，记为 $A\Leftrightarrow$ .</p><p>给定任意 $\mathrm{wff} A$ ， $E$ 是 $A$ 的个体域。若给 $A$ 中客体变元指派 $E$ 中的每一个客体,  $\mathrm{wff} A$ 值均为真，则称 $A$ 在 $E$ 中是有效的（永真的）。</p><p>一个 $\mathrm{wff} A$ ，若在所有赋值下均为“F”，则称该 $\mathrm{wff} A$  为不可满足的。</p><p>给定 $\mathrm{wff} A$ ， $E$ 是 $A$ 的个体域。若至少一种赋值下为真，则称 $A$ 是可满足的。</p><h4 id="谓词演算的一些等价式与蕴含式"><a href="#谓词演算的一些等价式与蕴含式" class="headerlink" title="谓词演算的一些等价式与蕴含式"></a>谓词演算的一些等价式与蕴含式</h4><ol><li>命题公式的推广</li></ol><p>谓词演算中的公式代替命题演算中的永真公式的变元时，所得的谓词公式即为永真式。</p><ol start="2"><li>量词转换律</li></ol><p>出现在量词之前的否定，不是否定该量词，而是否定被量化了的整个命题。</p><ol start="3"><li><p>量词辖域的扩张及其收缩律</p></li><li><p>量词与命题联结词之间的一些等价式</p></li><li><p>量词与命题联结词之间的一些蕴含式</p></li><li><p>多个量词的使用</p></li></ol><p>（a）量词出现的次序直接关系到命题的含义<br>（b）在含有多个量词的谓词公式中,xy, xy的位置是可以改变的,且不影响命题的真值。<br>（c）量词转换律的推广应用:把¬深入到谓词公式前面去的方法。<br>（d）两个量词, 所组成的谓词公式的等价式和永真蕴含式（8个）</p><h3 id="前束范式"><a href="#前束范式" class="headerlink" title="前束范式"></a>前束范式</h3><h4 id="前束范式-1"><a href="#前束范式-1" class="headerlink" title="前束范式"></a>前束范式</h4><p>前束范式：一个公式，如果量词均非否定地在全式的开头，它们的作用域延伸到整个公式的末尾，则称此公式叫前束范式。</p><p>定理：任何一个谓词公式均和一个前束范式等价。</p><p>化前束范式的步骤：</p><p>（1）否定深入（量词转化式）<br>（2）量词前提（必要时需换名）</p><h4 id="前束合取范式"><a href="#前束合取范式" class="headerlink" title="前束合取范式"></a>前束合取范式</h4><p>前束合取范式：一个谓词公式若具有如下形式称为前束合取范式。</p><p>定理：每一个谓词公式都可以转化为与其等价的前束合取范式。</p><p>化前束合取范式的步骤：<br>（1）消多余量词<br>（2）换名<br>（3）消去条件联结词<br>（4）将 $\neg $ 深入<br>（5）将量词提出</p><h4 id="前束析取范式"><a href="#前束析取范式" class="headerlink" title="前束析取范式"></a>前束析取范式</h4><p>前束析取范式：一个谓词公式具有如下形式称为前束析取范式。</p><p>定理：每一个谓词公式都可以转化为与其等价的前束析取范式。</p><h3 id="谓词演算的推理理论"><a href="#谓词演算的推理理论" class="headerlink" title="谓词演算的推理理论"></a>谓词演算的推理理论</h3><h4 id="四个推理规则"><a href="#四个推理规则" class="headerlink" title="四个推理规则"></a>四个推理规则</h4><ol><li><p>全称指定规则（US规则）<br>如果对个体域中所有客体$x, P(x)$成立，则对个体域中某个任意客体$u，P(u) $成立。<br>该规则表示成： $(\forall x)P(x)\Rightarrow P(u)$</p></li><li><p>全称推广规则（UG规则）<br>如果能够证明对个体域中每一个客体$u$，命题$P(u)$ 都成立，则可得到结论$(\forall x)P(x)$成立。<br>该规则表示成：$P(u)\Rightarrow (\forall x)P(x)$</p></li><li><p>存在指定规则（ES规则）如果对于个体域中某些客体$P(x)$成立，则必有某个特定的客体$c$，使$P(c)$成立。<br>该规则表示成： $(\exists x)P(x)\Rightarrow P(c)$</p></li><li><p>存在推广规则（EG规则）<br>如果对个体域中某个特定客体$c$，有$P(c) $成立，则在个体域中，必存在$x$，使$P(x)$成立。<br>该规则表示成：$P(c)\Rightarrow (\exists x)P(x)$</p></li></ol><h4 id="推论规则及使用说明"><a href="#推论规则及使用说明" class="headerlink" title="推论规则及使用说明"></a>推论规则及使用说明</h4><p>命题逻辑中的$P，T，CP$规则和间接证明法，都可引用到谓词逻辑的推论规则中来，但要注意对量词做适当处理。<br>方法：用US，ES在推导中去掉量词；<br>用UG，EG使结论量化。</p><p>规则使用说明：<br>（1）在使用ES、US时，量词一定在最前面。<br>（2）推导中连续使用US规则，可用相同变元。<br>$$<br>(\forall x)P(x)\Rightarrow P(a) \\ (\forall x)Q(x)\Rightarrow Q(a)<br>$$<br>（3）推导中既用ES又用US时，必须先用ES后用US，方可取相同变元，反之不行。</p><p>$$<br>(\exists x)P(x)\Rightarrow P(a) \\ (\forall x)Q(x)\Rightarrow Q(a)<br>$$<br>注意：在推理中，不能在量词后面的辖域范围内进行蕴含推证或等价变换。必须消去量词后，才能对谓词公式进行蕴含或等价推证。</p><h2 id="非经典逻辑简介"><a href="#非经典逻辑简介" class="headerlink" title="非经典逻辑简介"></a>非经典逻辑简介</h2><h3 id="模态逻辑基础"><a href="#模态逻辑基础" class="headerlink" title="模态逻辑基础"></a>模态逻辑基础</h3><ol><li>可能世界语义学</li></ol><p>一个表达式的内涵是指该表达式的概念内容，而一个表达式的外延则是指该概念内容囊括的全体实例，内涵逻辑强调的是表达式在不同的语境可以有不同的指称（外延）。</p><ol start="2"><li>模态逻辑的非形式讨论</li></ol><p>必然：必然 $\Box$ ，记为 $\Box A$ ，即无论在什么场合（现实的场合或者可以想象到的非现实的场合）均有事实 $A$ 。<br>可能：可能 $\lozenge$ ，记为 $\lozenge A$ ，即对某些场合（也许只有一个，甚至只是想象到的某个场合）有事实 $A$ 。</p><p>根据以上定义，显然有以下的性质：<br> $\Box A\Leftrightarrow \neg \lozenge \neg A$ ，必然 $A$ 当且仅当不可能 $\neg A$ 。<br> $\lozenge A\Leftrightarrow \neg \Box \neg A$ ，可能 $A$ 当且仅当并非必然 $\neg A$ 。<br> $\lozenge A\vee \lozenge \neg A$ ，可能 $A$ 或者可能 $\neg A$ 。<br> $\neg(\Box A\wedge \Box \neg A)$ ，决不能既有必然 $A$ ，又有必然 $\neg A$ 。<br> $\Box (A\vee \neg A)$ ，必然地“ $A$ 成立或者不成立”。<br> $\neg \lozenge (A\wedge \neg A)$ ，不可能 $A$ 与 $\neg A$ 同时成立。<br> $\Box(A\wedge B)\Leftrightarrow(\Box A\wedge\Box B)$ ，必然有 $A$ 并且 $B$ 的充要条件为必然 $A$ 并且必然 $B$ 。<br> $(\Box A\vee\Box B)\rightarrow \Box(A\vee B)$ ，如果必然 $A$ 和必然 $B$ 有一为真，那么必然有“ $A$ 真或 $B$ 真”。<br> $\lozenge(A\vee B)\Leftrightarrow(\lozenge A\vee \lozenge B)$ ，可能“ $A$ 或者 $B$ ”当且仅当可能 $A$ 或者可能 $B$ 。<br> $\lozenge(A\wedge B)\rightarrow(\lozenge A\wedge \lozenge B)$ ，如果可能有“ $A$ 并且 $B$ ”，那么可能 $A$ 并且可能 $B$ 。<br> $\Box A\rightarrow A$ ，必然 $A$ 真则 $A$ 真。<br> $A\rightarrow\lozenge A$ ，若 $A$ 真则可能 $A$ 真。<br> $\Box A\rightarrow\lozenge A$ ，必然 $A$ 真则可能 $A$ 为真。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数理逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/archives/79666db.html"/>
    <url>/archives/79666db.html</url>
    
    <content type="html"><![CDATA[<p>在学习了一门高级程序语言（比如C++）后，我发现编程离不开对数据的操作，也就离不开形形色色的数据结构。比如C++中的数组，链表，队列，栈等结构，都有着十分广泛的应用。而数据结构这门课的目的就是深入学习这些东西。</p><span id="more"></span><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="C-程序设计"><a href="#C-程序设计" class="headerlink" title="C++程序设计"></a>C++程序设计</h3><p>C++的基本特性：</p><ul><li>参数传递方式，函数返回方式</li><li>模板函数、递归函数、常量函数</li><li>内存分配和释放函数</li><li>异常处理结构</li><li>类与模板</li><li>类的成员（共享、保护、私有）</li><li>友元、操作符重载</li></ul><h2 id="程序性能分析"><a href="#程序性能分析" class="headerlink" title="程序性能分析"></a>程序性能分析</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h4><p>排序的目的：便于查找</p><p>查找：顺序查找，二分查找</p><p>排序的好坏：</p><ul><li><strong>时间效率</strong> —— 排序速度（全部比较次数）</li><li><strong>空间效率</strong> —— 占内存辅助空间的大小</li><li><strong>稳定性</strong> —— 若两个记录关键字值相等，排序后先后次序保持不变，则排序算法稳定。</li></ul><p>排序分为：</p><ul><li><strong>内部排序</strong>：排序过程中不使用计算机外部存储器的排序过程。<br>选择排序<br>插入排序<br>冒泡排序<br>计数排序<br>快速排序<br>归并排序<br>希尔排序<br>堆排序<br>基数排序</li><li><strong>外部排序</strong>：在排序时需要堆外存进行访问的排序过程。</li></ul><p><strong>程序运行的效率</strong>是指程序正确执行的前提下，所用的时间最少、空间最少。</p><p>程序性能是指运行一个程序所需要的的内存大小和时间。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂性：运行一个程序所需要的内存大小。</p><p>空间复杂性的组成：</p><ul><li>指令空间：存储经过编译之后的程序指令。</li><li>数据空间：存储所有常量和所有变量值。</li><li>环境栈空间：保存函数调用时为恢复程序继续运行的有关信息所需的存储空间。</li></ul><p>数据空间：</p><ul><li>对于简单变量和常量，所需要的空间取决于计算机编译器和变量与常量的数目。</li><li>对于复合变量，需要进行计算。</li></ul><p>环境栈空间：</p><ul><li>当函数被调用时，参数的定义，返回地址，局部变量的值以及传值形式参数的值保留在了环境栈中。</li></ul><p>任意程序 $P$ 所需空间 $S(P)$ 可以表示如下：<br>$$S(P)=c+S_p$$</p><p>固定部分，一般包含指令空间，简单变量和定长复合变量的空间以及常量空间。</p><p>可变部分：即与实例特征相关的部分。复合变量所需空间，动态分配的空间以及递归栈所需的空间。</p><p>比较只需比较可变部分所需的空间。</p><p>递归栈空间包括递归深度局部变量和形参的空间。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//顺序搜索</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SequentialSearch</span><span class="hljs-params">(T a[],<span class="hljs-keyword">const</span> T&amp;x,<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n&amp;&amp;a[i]!=x;i++);<br>    <span class="hljs-keyword">if</span>(i==n)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>选实例特征 $n$ ： $S(n)=0$ 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">Sum</span><span class="hljs-params">(T a[],<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    tsum+=a[i];<br>  <span class="hljs-keyword">return</span> tsum;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>$$S(n)=0$$</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">Rsum</span><span class="hljs-params">(T a[],<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">0</span>)<span class="hljs-function">s</span><br><span class="hljs-function">    <span class="hljs-keyword">return</span> <span class="hljs-title">Rsum</span><span class="hljs-params">(a,n<span class="hljs-number">-1</span>)</span>+a[n-1]</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>$$S(n)=(Addr+sizeof(int)+sizeof(ptr))*(n+1)$$</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Factorial</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n*<span class="hljs-built_in">Factorial</span>(n<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>$$S(n)=(Addr+sizeof(int))*Max\{ n,1 \}$$</p><p>小结：</p><ul><li>非递归算法：关注复合变量和动态空间分配</li><li>递归算法：复合变量，动态空间分配，环境栈地址，参数变量，递归深度。</li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂性：运行完该程序所需要的时间。</p><p>时间复杂度的组成：编译时间和运行时间</p><p>识别程序运行的关键操作。</p><p>$$<br>t_p(n)<br>=c_aADD(n)+c_sSUB(n)+c_mMUL(n)+\cdots<br>$$</p><p>计数排序：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Rearrangs</span><span class="hljs-params">(T a[],<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">int</span> r[])</span></span><br><span class="hljs-function"></span>&#123;<br>  T*u = <span class="hljs-keyword">new</span> T[n+<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    u[r[i]]=a[i];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    a[i]=u[i];<br>  <span class="hljs-keyword">delete</span> [] u;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>时间复杂度为： $\dfrac{n(n-1)}{2}+2n$ 。</p><p>选择排序：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectionSort</span><span class="hljs-params">(T a[],<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> size=<span class="hljs-number">0</span>;size&lt;n<span class="hljs-number">-1</span>;size++)<br>  &#123;<br>    <span class="hljs-keyword">int</span> j=<span class="hljs-built_in">Min</span>(a,size,n);<br>    <span class="hljs-built_in">Swap</span>(a[j],a[size]);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>时间复杂度为： $\dfrac{(n-1)n}{2}+3(n-1)$ 。</p><p>冒泡排序：</p><p>元素的比较次数为 $\dfrac{(n-1)n}{2}$ ，与选择排序相同。</p><p>排序的时间复杂度不仅与 $n$ 有关，还与数组的初始排列有关，故有最好的、最坏的的操作数。</p><p>插入排序：</p><p>不是一个稳定的算法。</p><p>最好的比较次数为 $n-1$ ，最坏的为 $\dfrac{(n-1)n}{2}$ 。</p><p>执行步数：</p><ul><li>操作计数忽略了其他操作的开销。</li><li>执行步数统计程序的全部时间开销。</li><li>执行步数也是实例特征的函数。</li></ul><p>执行步数的局限性：</p><ul><li>机器速度的影响</li><li>受指令集的影响</li><li>指令周期</li><li>编译器</li></ul><h3 id="渐进符号"><a href="#渐进符号" class="headerlink" title="渐进符号"></a>渐进符号</h3><p>对于足够大的 $n$ ，我们给出 $f(n)$ 的上限和下限。</p><p>$O,\varOmega,\varTheta,o$</p><h4 id="大写-O-符号（渐进紧密上限）"><a href="#大写-O-符号（渐进紧密上限）" class="headerlink" title="大写 $O$ 符号（渐进紧密上限）"></a>大写 $O$ 符号（渐进紧密上限）</h4><p>定义： $f(n)=O(g(n))$ 当且仅当存在正的常数 $c$ 和 $n_0$ ，使得对于所有的 $n\geq n_0$ ，有 $f(n)\leq cg(n)$ 。</p><h4 id="varOmega-符号（渐进紧密下限）"><a href="#varOmega-符号（渐进紧密下限）" class="headerlink" title="$\varOmega$ 符号（渐进紧密下限）"></a>$\varOmega$ 符号（渐进紧密下限）</h4><p>定义： $f(n)=\varOmega(g(n))$ 当且仅当存在正的常数 $c$ 和 $n_0$ ，使得对所有的 $n\geq n_0$ ，有 $f(n)\geq cg(n)$ 。</p><h4 id="varTheta-符号（渐进紧密限度）"><a href="#varTheta-符号（渐进紧密限度）" class="headerlink" title="$\varTheta$ 符号（渐进紧密限度）"></a>$\varTheta$ 符号（渐进紧密限度）</h4><p>定义： $f(n)=\varTheta(g(n))$ 当且仅当存在正的常数 $c_1$ ， $c_2$ 和某个 $n_0$ ，使得对所有的 $n\geq n_0$ ，有所有的 $n\geq n_0$ ，有 $c_2g(n)\geq f(n)\geq c_1g(n)$ 。</p><h4 id="小写-o-符号（非紧密上限）"><a href="#小写-o-符号（非紧密上限）" class="headerlink" title="小写 $o$ 符号（非紧密上限）"></a>小写 $o$ 符号（非紧密上限）</h4><p>定义： $f(n)=o(g(n))$ 当且仅当 $f(n)=O(g(n))$ 且 $f(n)\neq \varOmega(g(n))$ 。</p><h4 id="小写-omega-符号（非紧密下限）"><a href="#小写-omega-符号（非紧密下限）" class="headerlink" title="小写 $\omega$ 符号（非紧密下限）"></a>小写 $\omega$ 符号（非紧密下限）</h4><h4 id="关于渐进符号的其他定理"><a href="#关于渐进符号的其他定理" class="headerlink" title="关于渐进符号的其他定理"></a>关于渐进符号的其他定理</h4><p>对于任一实数 $x&gt;0$ 和任一个实数 $\delta&gt;0$ 下面的结论都是正确的：</p><ol><li>存在某个 $n_0$ 使得对于任何 $n\geq n_0$ ，有 $(\log{n})^{x}&lt;(\log{n})^{x+\delta}$ 。</li><li>存在某个 $n_0$ 使得对于任何 $n\geq n_0$ ，有 $(\log{n})^{x}&lt;n$ 。</li><li>存在某个 $n_0$ 使得对于任何 $n\geq n_0$ ，有 $n^{x}&lt;n^{x+\delta}$ 。</li><li>对于任意实数 $y$ ，存在某个 $n_0$ 使得对于任何 $n\geq n_0$ ，有 $n^x(\log{n}^y)&lt;n^{x+\delta}$ 。</li><li>存在某个 $n_0$ 使得对于任何 $n\geq n_0$ ，有 $n^x&lt;2^n$ 。</li></ol><h4 id="常用渐进标记"><a href="#常用渐进标记" class="headerlink" title="常用渐进标记"></a>常用渐进标记</h4><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>E1:</td><td>$C$</td><td>$\varTheta(1)$</td></tr><tr><td>E2:</td><td>$\sum_{i=0}^kc_in^i$</td><td>$\varTheta(n^k)$</td></tr><tr><td>E3:</td><td>$\sum_{i=1}^ni$</td><td>$\varTheta(n^2)$</td></tr><tr><td>E4:</td><td>$\sum_{i=1}^ni^2$</td><td>$\varTheta(n^3)$</td></tr><tr><td>E5:</td><td>$\sum_{i=1}^ni^k$</td><td>$\varTheta(n^{k+1})$</td></tr><tr><td>E6:</td><td>$\sum_{i=0}^nr^i(r&gt;1)$</td><td>$\varTheta(r^n)$</td></tr><tr><td>E7:</td><td>$n!$</td><td>$\varTheta((\dfrac{n}{e})^n)$</td></tr><tr><td>E8:</td><td>$\sum_{i=1}^n{\dfrac{1}{i}}$</td><td>$\varTheta(\log {n})$</td></tr></tbody></table><h4 id="实用的规则"><a href="#实用的规则" class="headerlink" title="实用的规则"></a>实用的规则</h4><h2 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>公式化描述：以数学公式来确定元素表中每个元素的存储位置。把所有元素依次连接存储在一片连续的存储空间中，即顺序表。</p><p>链接描述：每个元素存储在存储器的不同区域，包含一个指向下一个元素的指针，以指针把所有元素链接起来，简称链表。</p><p>间接寻址方式也可以描述存储在存储器的不同区域中的元素，保存一张存储元素地址的表，该表的第i项指向元素表中的第i个元素。</p><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>线性表的实例形式为： $(e_1,e_2,\cdots,e_n)$ 。</p><p>其中 $n$ 是有穷自然数，表的长度，当 $n=0$ 时，表为空。</p><p> $e_i$ 是表中的元素。用  表示每个元素的大小。</p><h3 id="公式化描述"><a href="#公式化描述" class="headerlink" title="公式化描述"></a>公式化描述</h3><p>采用数组表示，数组中每个位置被称为单元或节点，单元应足够大以便容纳数据元素。</p><p>一个数组描述：一个线性表或多个线性表</p><p>每个元素在数组中的位置：数学公式映射</p><p>评价：</p><ol><li>在执行插入，删除等操作时复杂度与表的大小呈线性关系。</li><li>空间利用率很低且受初始大小限制。</li><li>例如：维护三个表，元素总数不会超过5000个，但需要总共有15000个元素的空间。</li></ol><p>解决浪费空间的方法（1）：</p><ol><li>将所有线性表放入一个数组中。</li><li>引入附加数组对数组进行索引。</li><li>特点：省空间，费时间，插入规则复杂。</li></ol><p>解决浪费空间的方法（2）：</p><ol><li>动态分配内存：空间不够时重新分配内存，冗余时减少。</li><li>需要考虑增加和减少的量与时机。</li></ol><h3 id="链表描述"><a href="#链表描述" class="headerlink" title="链表描述"></a>链表描述</h3><p>在链表描述中，每个元素放在单元或节点中进行描述。</p><p>每个节点中包含与该节点相关节点的位置信息。称为链或指针。</p><ul><li>每个节点中包含一个链接域，指向表中下一个元素。</li><li>最后一个节点指向NULL。</li><li>第一个指针指向第一个节点。</li></ul><p>链表的操作：</p><ul><li>插入</li><li>删除</li><li>遍历</li><li>搜索</li><li>排序</li></ul><p>循环链表：提高链表效率的方法</p><ul><li>单向循环链表或循环链表：把单链表的最后节点的指针指向第一个节点。</li><li>带头节点循环链表：在链表的前部增加一个附加的节点，称之为头节点。</li></ul><p>与公式化描述方法的比较：</p><ol><li>空间<ul><li>公式化描述：元素的空间及保存表长的空间</li><li>链表：额外空间保存链接指针。</li></ul></li><li>插入和删除操作<ul><li>链表比公式描述方法快很多，当每个元素比较大时，更为明显。</li></ul></li><li>访问第 $k$ 个元素的时间<ul><li>公式化描述为 $\varTheta(1)$ ，链表为 $\varTheta(k)$ 。</li></ul></li><li>使用链表可以描述多个表，并且不会降低空间利用率。公式化描述较为复杂。</li></ol><p>双向链表：</p><ul><li>每个节点有两个指针，一个指向左边的节点，一个指向右边的节点。</li><li>也可以添加头节点及变成循环链表，来提高其性能。</li></ul><p>快慢指针的应用：</p><ul><li>求链表的中间节点</li><li>求链表的倒数第 $k$ 个节点。</li></ul><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>间接寻址是公式化描述和链表描述的组合。</p><ul><li>元素地址则被收集在一张表中。</li><li>保留公式化描述的优点：根据索引在 $\varTheta(1)$ 的时间内访问每个元素</li><li>保留链表描述方法的重要特色，在类似插入，删除等操作是不必对元素进行实际的移动。</li></ul><p>概念：</p><ul><li>地址表与元素表</li><li>存储元素地址的表：第 $i$ 项指向元素表中的第 $i$ 个元素。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="箱子排序"><a href="#箱子排序" class="headerlink" title="箱子排序"></a>箱子排序</h4><p>箱子的实现：每个箱子都描述成一个链表</p><p>对于箱子排序，需要能够：<br>1）从欲排序链表的首部开始，逐个删除每个节点，放入适当的箱子中。<br>2）收集并链接每个箱子中的节点，产生一个排序链表。</p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li><p>对于箱子排序，如果用 $range = n^c$ ，复杂性将变成 $\varTheta(n+range)=\varTheta(n^c)$ 。</p></li><li><p>采用一些基数 $r$ 分解这些数</p></li></ul><p>基数排序：把数按照某种基数分解为数字，然后对数字进行排序。</p><p>基数排序时对箱子排序方法的扩充，可使其在 $\varTheta(n)$ 时间内对范围在 $0\sim n^c-1$ 之间的 $n$ 个整数进行排序，其中 $c$ 是一个常量。</p><ul><li>当使用基数 $r=n$ ，对 $n$ 个介于 $0\sim n^c-1$ 范围内的整数进行排序时，每个数可分解出 $c$ 个数字。可采用 $c$ 次箱子排序。每次排序时取 $range = n$ 。整个排序所需要的时间为 $\varTheta(cn)=\varTheta(n)$ 。（ $c$ 是一个常量）。</li><li>基数排序的局限性，关键字的特殊性。</li></ul><h2 id="数组和矩阵"><a href="#数组和矩阵" class="headerlink" title="数组和矩阵"></a>数组和矩阵</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组：数组是数据结构中最基本的类型，是一种循序的结构，是存储同一类数据的数据结构。</p><p>二维数组：以行为主与以列为主，判断内存位置</p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>矩阵：一个 $m\times n$ 的矩阵是一个 $m$ 行， $n$ 列的表，其中 $m$ 和 $n$ 是矩阵的维数。</p><p>矩阵转置，矩阵加，矩阵乘</p><h3 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h3><ul><li>对角矩阵</li><li>三对角矩阵</li><li>下三角矩阵</li><li>上三角矩阵</li><li>对称矩阵</li></ul><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>稀疏矩阵：如果一个 $m\times n$ 的矩阵有许多元素为0，则称该矩阵为稀疏矩阵，反之为稠密矩阵。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>栈：栈是一个线性表，其插入和删除操作都在表的同一端进行，其中一端被称为栈顶，另一端被称为栈底。</p><p>栈是一个后进先出表。</p><h3 id="公式化描述-1"><a href="#公式化描述-1" class="headerlink" title="公式化描述"></a>公式化描述</h3><p>令栈顶元素存储在 element[length-1] 中，栈底元素存储在 element[0] 中。</p><h3 id="链表描述-1"><a href="#链表描述-1" class="headerlink" title="链表描述"></a>链表描述</h3><p>一个数组中可以描述多个堆栈。</p><ul><li>使 Add 操作在最坏情况下的时间复杂性从 $\varTheta(1)\rightarrow O(ArraySize)$ 。</li><li>Delete 操作复杂度仍为 $\varTheta(1)$ 。</li></ul><p>特殊：同时使用两个栈的共享。</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><p>从左到右扫描一个字符串，把所遇到的左括号入栈，每个右括号与最近的未匹配的左括号相匹配（栈顶的左括号），同时从栈顶删除该左括号。当括号不匹配或者扫描后栈不为空时，字符串括号就不是匹配的。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>stack&lt;<span class="hljs-keyword">char</span>&gt; op;<br><span class="hljs-keyword">char</span> s;<br><span class="hljs-keyword">while</span> ((s = <span class="hljs-built_in">getchar</span>()) != <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br><span class="hljs-keyword">if</span> (s == <span class="hljs-string">&#x27;(&#x27;</span> || s == <span class="hljs-string">&#x27;[&#x27;</span> || s == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>op.<span class="hljs-built_in">push</span>(s);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br><span class="hljs-keyword">if</span> (op.<span class="hljs-built_in">empty</span>())&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;False&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (op.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>op.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;False&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br><span class="hljs-keyword">if</span> (op.<span class="hljs-built_in">empty</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;False&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (op.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>op.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;False&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&#x27;&#125;&#x27;</span>) &#123;<br><span class="hljs-keyword">if</span> (op.<span class="hljs-built_in">empty</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;False&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (op.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>op.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;False&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (op.<span class="hljs-built_in">empty</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;True&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;False&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h4><p>用栈组织三座塔。</p><h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><h4 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h4><h4 id="火车车厢重排"><a href="#火车车厢重排" class="headerlink" title="火车车厢重排"></a>火车车厢重排</h4><p>缓冲铁轨</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="抽象数据类型-1"><a href="#抽象数据类型-1" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>队列：队列是一个线性表，其插入和删除操作分别在表的不同端进行。添加新元素的一端被称为队尾（rear），而删除元素的一端被称为队首（front）。</p><h3 id="公式化描述-2"><a href="#公式化描述-2" class="headerlink" title="公式化描述"></a>公式化描述</h3><p>公式化描述：用公式location(i)=i-1来描述一个队列。</p><p>location(i)=location(1)+i-1</p><p>location(i)=(location(1)+i-1)%MaxSize</p><h3 id="链表描述-2"><a href="#链表描述-2" class="headerlink" title="链表描述"></a>链表描述</h3><p>通过两个变量front和rear来分别跟踪队列的两端</p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><h4 id="火车车厢重排-1"><a href="#火车车厢重排-1" class="headerlink" title="火车车厢重排"></a>火车车厢重排</h4><p>车厢进入缓冲铁轨的原则</p><ul><li>该缓冲铁轨中现有各车厢编号小于该车厢</li><li>优先选择一个左端车厢编号最大的缓冲铁轨</li><li>否则选择一个空的缓冲铁轨</li></ul><h2 id="跳表和散列"><a href="#跳表和散列" class="headerlink" title="跳表和散列"></a>跳表和散列</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找的概念：</p><ul><li>查找表是记录的集合，每个记录至少包含一个关键字。</li><li>查找：关键字值-&gt;一个记录</li><li>主关键字：唯一对应一个记录的关键字值。</li><li>查找的结果：<ul><li>成功查找</li><li>不成功查找</li></ul></li></ul><p>常用的查找方法：</p><ul><li>顺序表查找（顺序查找，折半查找，索引顺序表查找）</li><li>数表查找（二叉搜索树，AVL树，B-树）</li><li>跳表和哈希表</li></ul><p>平均查找长度：$ASL=\sum_{i=1}^np_ic_i$<br>$p_i$:查找第i个记录的概率<br>$c_i$：查找第i个记录的比较次数</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典是一些形如$(k,v)$的数对的计划，是检索功能和存储结构的统一。<br>随机访问或逐个访问</p><h3 id="线性表描述"><a href="#线性表描述" class="headerlink" title="线性表描述"></a>线性表描述</h3><h3 id="跳表描述"><a href="#跳表描述" class="headerlink" title="跳表描述"></a>跳表描述</h3><p>给链表增加一些指针，当链表有序时，可以通过比较待查元素与指针的大小来缩小元素查找范围。</p><h3 id="散列表（哈希表）描述"><a href="#散列表（哈希表）描述" class="headerlink" title="散列表（哈希表）描述"></a>散列表（哈希表）描述</h3><p>理想散列</p><h3 id="文本压缩"><a href="#文本压缩" class="headerlink" title="文本压缩"></a>文本压缩</h3><h2 id="二叉树和其他树"><a href="#二叉树和其他树" class="headerlink" title="二叉树和其他树"></a>二叉树和其他树</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树：一种层次化的数据，祖先-后代、上级-下属、整体-部分以及其他类似的关系。</p><p>树：一个非空的有限元素的集合，其中一个元素为根，余下的元素（如果有的话）组成t的子树。</p><p>树根是数中唯一一个没有父节点的元素。</p><p>级：树根的级为1，其孩子级为2，以此类推。</p><p>元素的度：孩子的个数，叶节点的度为零。</p><p>树的度：所有元素度的最大值。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h3 id="二叉树的特性"><a href="#二叉树的特性" class="headerlink" title="二叉树的特性"></a>二叉树的特性</h3><h3 id="二叉树的描述"><a href="#二叉树的描述" class="headerlink" title="二叉树的描述"></a>二叉树的描述</h3><h3 id="二叉树的常用操作"><a href="#二叉树的常用操作" class="headerlink" title="二叉树的常用操作"></a>二叉树的常用操作</h3><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h3 id="抽象数据类型-2"><a href="#抽象数据类型-2" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><h3 id="二叉树类"><a href="#二叉树类" class="headerlink" title="二叉树类"></a>二叉树类</h3><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
